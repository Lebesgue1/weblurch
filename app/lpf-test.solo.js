// Generated by CoffeeScript 1.8.0
(function() {
  var Module, checkTimer, compileLPF, fullOutputArray, loadTest, myLeanOutputTracker, myTimer, now, removeTest, runLeanOn, saveTest, savedTests, startTimer,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  saveTest = function(name, code) {
    var object, _ref;
    object = JSON.parse((_ref = window.localStorage.testData) != null ? _ref : "{}");
    object[name] = code;
    return window.localStorage.testData = JSON.stringify(object);
  };

  savedTests = function() {
    var object, _ref;
    object = JSON.parse((_ref = window.localStorage.testData) != null ? _ref : "{}");
    return Object.keys(object).sort();
  };

  loadTest = function(name) {
    var object, _ref;
    object = JSON.parse((_ref = window.localStorage.testData) != null ? _ref : "{}");
    return object[name];
  };

  removeTest = function(name) {
    var object, _ref;
    object = JSON.parse((_ref = window.localStorage.testData) != null ? _ref : "{}");
    delete object[name];
    return window.localStorage.testData = JSON.stringify(object);
  };

  myTimer = null;

  now = function() {
    return (new Date).getTime();
  };

  startTimer = function() {
    return myTimer = now();
  };

  checkTimer = function() {
    return "(took " + (now() - myTimer) + " ms)";
  };

  Module = window.Module = {};

  Module.TOTAL_MEMORY = 64 * 1024 * 1024;

  Module.noExitRuntime = true;

  myLeanOutputTracker = null;

  fullOutputArray = null;

  Module.print = function(text) {
    var match;
    match = null;
    if (match = /FLYCHECK_BEGIN (.*)/.exec(text)) {
      return myLeanOutputTracker = {
        type: match[1],
        text: []
      };
    } else if (!myLeanOutputTracker) {
      throw new Error('Unexpected output from Lean: ' + text);
    } else if (match = /([^:]+):(\d+):(\d+): (.*)/.exec(text)) {
      myLeanOutputTracker.file = match[1];
      myLeanOutputTracker.line = match[2];
      myLeanOutputTracker.char = match[3];
      return myLeanOutputTracker.info = match[4];
    } else if (/FLYCHECK_END/.test(text)) {
      fullOutputArray.push(myLeanOutputTracker);
      return myLeanOutputTracker = null;
    } else {
      return myLeanOutputTracker.text.push(text);
    }
  };

  Module.preRun = [
    function() {
      return startTimer();
    }
  ];

  runLeanOn = window.runLeanOn = function(code) {
    startTimer();
    Module.lean_init();
    startTimer();
    FS.writeFile('test.lean', code, {
      encoding: 'utf8'
    });
    startTimer();
    fullOutputArray = [];
    Module.lean_process_file('test.lean');
    return fullOutputArray;
  };

  $(function() {
    var clickTab, lastInputCode, lastOutputLeanCode, lastOutputLeanMsgs, lastOutputTranslated, lastSavedFilename, showOutput, tabNumber;
    ($('[data-toggle="tooltip"]')).tooltip();
    lastInputCode = null;
    lastOutputLeanCode = null;
    lastOutputLeanMsgs = null;
    lastOutputTranslated = null;
    tabNumber = function() {
      var outputLink;
      outputLink = ($('.output-tabs > li.active > a')).get(0);
      return parseInt(outputLink.getAttribute('id').slice(-1));
    };
    clickTab = function(number) {
      var link;
      ($('.output-tabs > li')).removeClass('active');
      link = ($(".output-tabs > li > a#tab" + number)).get(0);
      ($(link.parentNode)).addClass('active');
      return showOutput();
    };
    showOutput = function() {
      return ($('#output')).val((function() {
        switch (tabNumber()) {
          case 1:
            return lastOutputLeanCode;
          case 2:
            return lastOutputLeanMsgs;
          case 3:
            return lastOutputTranslated;
        }
      })());
    };
    ($('.output-tabs > li > a')).click(function(event) {
      ($('.output-tabs > li')).removeClass('active');
      ($(this.parentNode)).addClass('active');
      return showOutput();
    });
    setInterval(function() {
      var newInputCode;
      newInputCode = ($('#input')).val();
      if (newInputCode === lastInputCode) {
        return;
      }
      lastInputCode = newInputCode;
      ($('#output')).val('...RUNNING...');
      return setTimeout(function() {
        var compiled, d, e, element, k, lastOutputLeanObjs, line, object, v, _i, _j, _len, _len1, _ref, _ref1;
        try {
          compiled = compileLPF(lastInputCode);
          lastOutputLeanCode = compiled.code();
        } catch (_error) {
          e = _error;
          lastOutputLeanCode = 'Error in compilation!\n' + e.stack;
        }
        try {
          lastOutputLeanObjs = runLeanOn(lastOutputLeanCode);
          lastOutputLeanMsgs = JSON.stringify(lastOutputLeanObjs, null, 4);
        } catch (_error) {
          e = _error;
          lastOutputLeanObjs = null;
          lastOutputLeanMsgs = 'Error in Lean run!\n' + e.stack;
        }
        try {
          if (lastOutputLeanObjs === null) {
            throw Error('Previous step encountered an error... Check earlier tabs for details.');
          }
          for (_i = 0, _len = lastOutputLeanObjs.length; _i < _len; _i++) {
            object = lastOutputLeanObjs[_i];
            line = parseInt((_ref = object.line) != null ? _ref : 1);
            compiled.lineToElement(line).feedback = object;
          }
          lastOutputTranslated = '';
          _ref1 = compiled.elements;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            element = _ref1[_j];
            if (!element.lpfCode) {
              continue;
            }
            lastOutputTranslated += element.lpfCode;
            if (lastOutputTranslated.slice(-1) !== '\n') {
              lastOutputTranslated += '\n';
            }
            if (d = element.feedbackData()) {
              lastOutputTranslated += "    " + d.result + "\n";
              if (d.reason) {
                lastOutputTranslated += "    " + d.reason + "\n";
              }
              for (k in d) {
                if (!__hasProp.call(d, k)) continue;
                v = d[k];
                if (k === 'result' || k === 'reason') {
                  continue;
                }
                lastOutputTranslated += "    " + k + " = " + v + "\n";
              }
            }
          }
        } catch (_error) {
          e = _error;
          lastOutputTranslated = 'Error in translation!\n' + e.stack;
        }
        return showOutput();
      }, 0);
    }, 1000);
    ($('#loadButton')).click(function(event) {
      var loaded, thingsToLoad, toLoad;
      thingsToLoad = savedTests();
      if (thingsToLoad.length === 0) {
        return alert('You have not saved any LPF arrays yet.');
      } else {
        toLoad = prompt("Type the name of the LPF array to load, chosen from the following list:\n \n" + (thingsToLoad.join('\n')), thingsToLoad[0]);
        if (toLoad == null) {
          return;
        }
        loaded = loadTest(toLoad);
        if (!loaded) {
          return alert("I could not load the LPF array \"" + toLoad + ".\"");
        } else {
          return ($('#input')).val(loadTest(toLoad));
        }
      }
    });
    lastSavedFilename = null;
    ($('#saveButton')).click(function(event) {
      var toSave;
      toSave = prompt("Type the name under which to save this LPF array.", lastSavedFilename);
      if (toSave == null) {
        return;
      }
      if (__indexOf.call(savedTests, toSave) >= 0) {
        if (!confirm("Save over LPF array of that same name?")) {
          return;
        }
      }
      saveTest(toSave, ($('#input')).val());
      return lastSavedFilename = toSave;
    });
    ($('#eraseButton')).click(function(event) {
      var thingsToErase, toErase;
      thingsToErase = savedTests();
      if (thingsToErase.length === 0) {
        return alert('You have not saved any LPF arrays yet.');
      } else {
        toErase = prompt("Type the name of the LPF array to erase, chosen from the following list:\n \n" + (thingsToErase.join('\n')), thingsToErase[0]);
        if (toErase == null) {
          return;
        }
        if (__indexOf.call(thingsToErase, toErase) < 0) {
          return;
        }
        if (!confirm("Are you SURE you want to ERASE " + toErase + "?")) {
          return;
        }
        return removeTest(toErase);
      }
    });
    ($('#input')).keydown(function(event) {
      var down, up;
      up = {
        1: 2,
        2: 3,
        3: 1
      };
      down = {
        1: 3,
        2: 1,
        3: 2
      };
      if (event.altKey) {
        if (event.keyCode === 219) {
          clickTab(down[tabNumber()]);
          event.preventDefault();
          return false;
        } else if (event.keyCode === 221) {
          clickTab(up[tabNumber()]);
          event.preventDefault();
          return false;
        }
      }
    });
    ($('#input')).val('// \n// EXAMPLE CODE TO GET YOU STARTED \n// \nGlobal(SYMBOL,_true,[],Prop,[]) \nGlobal(SYMBOL,_false,[],Prop,[]) \nGlobal(SYMBOL,_or,[Prop,Prop],Prop,[]) \nGlobal(RULE,_true_intro,[],_true,[]) \nGlobal(RULE,_or_intro_left,[A:Prop,B:Prop,B],_or A B,[A,B]) \nGlobal(RULE,_or_intro_right,[A:Prop,B:Prop,A],_or A B,[A,B]) \nBegin() \nLocal(X,Prop,[]) \nStep(_true,[],_true_intro,[]) \nStep(_or X _true,[X],_or_intro_left,[8]) \nEnd()');
    return ($('#input')).focus();
  });

  compileLPF = function(code) {
    var allfrees, beginRE, commentRE, conclusion, count, declarations, dot2comma, endRE, entry, env, feedbackData, free, frees, freevars, getTypeOf, globalRE, i, inames, index, inputs, last, lastType, lines, localRE, match, name, okayToAdd, originalCode, output, pair, positionInCode, premise, premises, reason, result, stepRE, t, type, typeRE, undeclared, v, whitespaceRE, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1;
    result = {};
    commentRE = /^\/\/(.*)(\n|$)/;
    whitespaceRE = /^\s+/;
    globalRE = /^Global\s*\(\s*(SYMBOL|RULE)\s*,\s*(\w+)\s*,\s*\[([^\]]*)\]\s*,\s*([^,]+)\s*,\s*\[([^\]]*)\]\s*\)/;
    stepRE = /^Step\s*\(\s*([^,]+)\s*,\s*\[([^\]]*)\]\s*,\s*(\w+)\s*,\s*\[((\s|\d|,)*)\]\s*\)/;
    typeRE = /^Type\s*\(\s*(\w+)\s*\)/;
    beginRE = /^Begin\s*\(\s*\)/;
    endRE = /^End\s*\(\s*\)/;
    localRE = /^Local\s*\(\s*(\w+)\s*,\s*(\w+)\s*,\s*\[([^\]]*)\]\s*\)/;
    result = [];
    lines = {};
    frees = {};
    env = [];
    lastType = null;
    count = 0;
    originalCode = code;
    positionInCode = null;
    match = null;
    result.elements = [
      {
        lpfCode: '',
        lpfPosition: -1,
        leanCode: 'notation `Prop` := Type.{0}',
        numLines: 1
      }
    ];
    feedbackData = function() {
      if (this.feedback == null) {
        return null;
      }
      console.log(this.feedback);
      if (this.feedback.info === 'information:check result:') {
        return {
          result: 'VALID'
        };
      } else if (this.feedback.info === 'error: type mismatch at application') {
        return {
          result: 'INVALID',
          reason: 'bad premise',
          premiseIndex: parseInt(this.feedback.text[2].trim().slice(5)) + 1,
          correctType: this.feedback.text[4].trim(),
          assertedType: this.feedback.text[6].trim()
        };
      } else if (match = /error: unknown identifier '([^']+)'/.exec(this.feedback.info)) {
        return {
          result: 'INVALID',
          reason: 'undeclared identifier',
          identifier: match[1]
        };
      } else if (this.feedback.info === 'error: type mismatch at term') {
        return {
          result: 'INVALID',
          reason: 'bad conclusion',
          correctType: this.feedback.text[2].trim(),
          assertedType: this.feedback.text[4].trim()
        };
      } else {
        return {
          result: 'INVALID',
          reason: this.feedback.info,
          warning: 'Unknown error type -- could not translate'
        };
      }
    };
    result.lineToElement = function(lineNum) {
      var element, linesFound, _i, _len, _ref;
      linesFound = 0;
      _ref = this.elements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        linesFound += element.numLines;
        if (linesFound >= lineNum) {
          return element;
        }
      }
      return null;
    };
    result.code = function() {
      var elt;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = this.elements;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elt = _ref[_i];
          _results.push(elt.leanCode);
        }
        return _results;
      }).call(this)).join('\n');
    };
    result.add = function(code) {
      return this.elements.push({
        lpfCode: match[0],
        lpfPosition: positionInCode,
        leanCode: code,
        numLines: code.split('\n').length,
        feedbackData: feedbackData
      });
    };
    dot2comma = function(code) {
      return code.replace(/\./g, ',');
    };
    while (code.length > 0) {
      positionInCode = originalCode.length - code.length;
      if (match = commentRE.exec(code)) {
        result.add('-- ' + match[1]);
      } else if (match = whitespaceRE.exec(code)) {

      } else if (match = globalRE.exec(code)) {
        type = match[1];
        name = "" + match[2];
        inputs = match[3];
        if (!/^\s*$/.test(inputs)) {
          inputs = (function() {
            var _i, _len, _ref, _results;
            _ref = inputs.split(',');
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              i = _ref[_i];
              _results.push(i.trim());
            }
            return _results;
          })();
        } else {
          inputs = [];
        }
        output = match[4];
        freevars = match[5];
        if (!/^\s*$/.test(freevars)) {
          freevars = (function() {
            var _i, _len, _ref, _results;
            _ref = freevars.split(',');
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              t = _ref[_i];
              _results.push(t.trim());
            }
            return _results;
          })();
        } else {
          freevars = [];
        }
        inputs = (function() {
          var _i, _len, _results;
          _results = [];
          for (index = _i = 0, _len = inputs.length; _i < _len; index = ++_i) {
            entry = inputs[index];
            if (/^\s*[a-zA-Z_][a-zA-Z_0-9]*\s*:/.test(entry)) {
              _results.push(__slice.call((function() {
                  var _j, _len1, _ref, _results1;
                  _ref = entry.split(':');
                  _results1 = [];
                  for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                    t = _ref[_j];
                    _results1.push(t.trim());
                  }
                  return _results1;
                })()).concat(['pair']));
            } else {
              _results.push(["dummy" + index, entry, 'singleton']);
            }
          }
          return _results;
        })();
        if (type === 'SYMBOL' && inputs.length === 0) {
          result.add("constant " + name + " : " + (dot2comma(output)));
        } else if (type === 'SYMBOL') {
          inames = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = inputs.length; _i < _len; _i++) {
              v = inputs[_i];
              _results.push(v[0]);
            }
            return _results;
          })();
          inputs = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = inputs.length; _i < _len; _i++) {
              v = inputs[_i];
              _results.push("(" + v[0] + " : " + (dot2comma(v[1])) + ")");
            }
            return _results;
          })();
          result.add("inductive " + name + " " + (inputs.join(' ')) + " : " + output + " := mk : " + (inames.join(' -> ')) + " -> " + name + " " + (inames.join(' ')));
        } else if (type === 'RULE') {
          inputs = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = inputs.length; _i < _len; _i++) {
              v = inputs[_i];
              if (v[2] === 'pair') {
                _results.push("{" + v[0] + " : " + (dot2comma(v[1])) + "}");
              } else {
                _results.push("(" + v[0] + " : " + (dot2comma(v[1])) + ")");
              }
            }
            return _results;
          })();
          result.add("constant " + name + " " + (inputs.join(' ')) + " : " + (dot2comma(output)));
        } else {
          result.add('-- Invalid Global type: ' + type);
        }
        count++;
      } else if (match = stepRE.exec(code)) {
        conclusion = dot2comma(match[1]);
        freevars = match[2];
        if (!/^\s*$/.test(freevars)) {
          freevars = (function() {
            var _i, _len, _ref, _results;
            _ref = freevars.split(',');
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              t = _ref[_i];
              _results.push(t.trim());
            }
            return _results;
          })();
        } else {
          freevars = [];
        }
        reason = "" + match[3];
        premises = match[4];
        allfrees = freevars.slice(0);
        if (!/^\s*$/.test(premises)) {
          premises = (function() {
            var _i, _len, _ref, _results;
            _ref = premises.split(',');
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              i = _ref[_i];
              _results.push(parseInt(i.trim()));
            }
            return _results;
          })();
          for (_i = 0, _len = premises.length; _i < _len; _i++) {
            i = premises[_i];
            _ref1 = (_ref = frees[i]) != null ? _ref : [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              free = _ref1[_j];
              if (__indexOf.call(allfrees, free) < 0) {
                allfrees.push(free);
              }
            }
          }
          premises = (function() {
            var _k, _len2, _results;
            _results = [];
            for (_k = 0, _len2 = premises.length; _k < _len2; _k++) {
              i = premises[_k];
              _results.push("(" + lines[i] + ")");
            }
            return _results;
          })();
        } else {
          premises = [];
        }
        declarations = '';
        getTypeOf = function(name) {
          var pair, _k, _len2, _ref2;
          i = env.length - 1;
          while (i >= 0) {
            _ref2 = env[i];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              pair = _ref2[_k];
              if (pair[0] === name) {
                return pair[1];
              }
            }
            i--;
          }
          return lastType;
        };
        if (allfrees.length > 0) {
          undeclared = [];
          for (_k = 0, _len2 = allfrees.length; _k < _len2; _k++) {
            v = allfrees[_k];
            if (!getTypeOf(v)) {
              undeclared.push(v);
            }
          }
          if (undeclared.length > 0) {
            result.add('-- Undeclared variable(s): ' + undeclared.join(', '));
            break;
          }
          allfrees = (function() {
            var _l, _len3, _results;
            _results = [];
            for (_l = 0, _len3 = allfrees.length; _l < _len3; _l++) {
              v = allfrees[_l];
              _results.push("(" + v + " : " + (dot2comma(getTypeOf(v))) + ")");
            }
            return _results;
          })();
          declarations = allfrees.join(' ');
        }
        if (premises.length > 0) {
          for (index = _l = 0, _len3 = premises.length; _l < _len3; index = ++_l) {
            premise = premises[index];
            declarations += " (dummy" + index + " : " + premise + ")";
            premises[index] = "dummy" + index;
          }
        }
        if (declarations.length > 0) {
          declarations = 'variables ' + declarations;
        } else {
          declarations = '-- no variable declarations needed';
        }
        result.add("section \n  " + declarations + " \n  check ((" + reason + " " + (premises.join(' ')) + ") : " + conclusion + ") \nend");
        lines[count] = conclusion;
        frees[count] = freevars.slice(0);
        count++;
      } else if (match = typeRE.exec(code)) {
        result.add('-- Type ' + dot2comma(match[1]));
        lastType = dot2comma(match[1]);
        count++;
      } else if (match = beginRE.exec(code)) {
        result.add('-- Begin');
        env.push([]);
        count++;
      } else if (match = endRE.exec(code)) {
        result.add('-- End');
        if (env.length === 0) {
          result.add('-- Cannot do End here!');
          break;
        }
        if ((conclusion = lines[count - 1]) == null) {
          result.add('-- Subproof had no conclusion!');
          break;
        }
        premises = (function() {
          var _len4, _m, _ref2, _results;
          _ref2 = env.pop();
          _results = [];
          for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
            pair = _ref2[_m];
            _results.push("(" + pair[0] + " : " + pair[1] + ")");
          }
          return _results;
        })();
        lines[count] = "Pi " + (premises.join(' ')) + ", (" + conclusion + ")";
        count++;
      } else if (match = localRE.exec(code)) {
        result.add('-- Local ' + match[1] + ' ' + match[2] + ' ' + match[3]);
        if (env.length === 0) {
          result.add('-- Cannot do Local here!');
          break;
        }
        last = env[env.length - 1];
        okayToAdd = true;
        for (_m = 0, _len4 = last.length; _m < _len4; _m++) {
          pair = last[_m];
          if (pair[0] === match[1]) {
            result.add("-- Cannot redeclare " + match[1] + " here!");
            okayToAdd = false;
            break;
          }
        }
        if (okayToAdd) {
          last.push([match[1], dot2comma(match[2])]);
        }
        lines[count] = dot2comma(match[2]);
        count++;
      } else {
        result.add('-- Cannot understand: ' + code);
        break;
      }
      code = code.slice(match[0].length);
    }
    console.log(lines);
    return result;
  };

}).call(this);

//# sourceMappingURL=lpf-test.solo.js.map
