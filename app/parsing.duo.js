// Generated by CoffeeScript 1.8.0
(function() {
  var Grammar, Tokenizer, copyState, debugNestedArrays, debugState, equalArrays, exports, getNext, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  if (typeof exports === "undefined" || exports === null) {
    exports = (_ref = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref : window;
  }

  if (typeof require !== "undefined" && require !== null) {
    require('./utils');
  }

  getNext = function(state) {
    if (state.pos < state.rhs.length) {
      return state.rhs[state.pos];
    } else {
      return null;
    }
  };

  copyState = function(state) {
    return {
      lhs: state.lhs,
      rhs: state.rhs,
      pos: state.pos,
      ori: state.ori,
      got: state.got.slice(0)
    };
  };

  equalArrays = function(array1, array2) {
    var entry1, entry2, index, _i, _len;
    if (array1.length !== array2.length) {
      return false;
    }
    for (index = _i = 0, _len = array1.length; _i < _len; index = ++_i) {
      entry1 = array1[index];
      entry2 = array2[index];
      if (entry1 instanceof RegExp) {
        if (!(entry2 instanceof RegExp) || entry1.source !== entry2.source) {
          return false;
        }
      } else {
        if (entry1 !== entry2) {
          return false;
        }
      }
    }
    return true;
  };

  exports.Grammar = Grammar = (function() {
    function Grammar(START) {
      this.START = START;
      this.parse = __bind(this.parse, this);
      this.addRule = __bind(this.addRule, this);
      this.setOption = __bind(this.setOption, this);
      this.rules = {};
      this.defaults = {
        addCategories: true,
        collapseBranches: false,
        showDebuggingOutput: false,
        expressionBuilder: null,
        tokenizer: null,
        comparator: JSON.equals,
        maxIterations: -1
      };
    }

    Grammar.prototype.setOption = function(optionName, optionValue) {
      return this.defaults[optionName] = optionValue;
    };

    Grammar.prototype.addRule = function() {
      var categoryName, entry, index, sequence, sequences, _base, _i, _j, _len, _len1, _results;
      categoryName = arguments[0], sequences = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _results = [];
      for (_i = 0, _len = sequences.length; _i < _len; _i++) {
        sequence = sequences[_i];
        if (sequence instanceof RegExp) {
          sequence = [sequence];
        }
        if (!(sequence instanceof Array)) {
          sequence = ("" + sequence).split(' ');
        }
        for (index = _j = 0, _len1 = sequence.length; _j < _len1; index = ++_j) {
          entry = sequence[index];
          if (entry instanceof RegExp) {
            sequence[index] = new RegExp("^" + entry.source + "$");
          }
        }
        _results.push(((_base = this.rules)[categoryName] != null ? _base[categoryName] : _base[categoryName] = []).push(sequence));
      }
      return _results;
    };

    Grammar.prototype.parse = function(input, options) {
      var copy, debug, expressionBuilderFlag, found, got, i, j, k, next, numIterationsDone, previous, recur, result, results, rhs, rhss, s, skipped, state, stateGrid, stateSet, tmpi, tmpj, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _p, _q, _r, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      if (options == null) {
        options = {};
      }
      if (options.addCategories == null) {
        options.addCategories = this.defaults.addCategories;
      }
      if (options.collapseBranches == null) {
        options.collapseBranches = this.defaults.collapseBranches;
      }
      if (options.showDebuggingOutput == null) {
        options.showDebuggingOutput = this.defaults.showDebuggingOutput;
      }
      if (options.expressionBuilder == null) {
        options.expressionBuilder = this.defaults.expressionBuilder;
      }
      expressionBuilderFlag = {};
      if (options.tokenizer == null) {
        options.tokenizer = this.defaults.tokenizer;
      }
      if (options.comparator == null) {
        options.comparator = this.defaults.comparator;
      }
      if (options.maxIterations == null) {
        options.maxIterations = this.defaults.maxIterations;
      }
      debug = options.showDebuggingOutput ? function() {
        return console.log.apply(console, arguments);
      } : function() {};
      debug('\n\n');
      if ((options.tokenizer != null) && typeof input === 'string') {
        input = options.tokenizer.tokenize(input);
      }
      stateGrid = (function() {
        var _i, _ref1, _results;
        _results = [];
        for (i = _i = 0, _ref1 = input.length; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          _results.push([]);
        }
        return _results;
      })();
      stateGrid[0].push({
        lhs: '',
        rhs: [this.START],
        pos: 0,
        ori: 0,
        got: []
      });
      numIterationsDone = 0;
      for (i = _i = 0, _len = stateGrid.length; _i < _len; i = ++_i) {
        stateSet = stateGrid[i];
        debug("processing stateSet " + i + " in this stateGrid (with input " + input + "):");
        debug('----------------------');
        for (tmpi = _j = 0, _ref1 = stateGrid.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; tmpi = 0 <= _ref1 ? ++_j : --_j) {
          debug("|    state set " + tmpi + ":");
          skipped = 0;
          for (tmpj = _k = 0, _ref2 = stateGrid[tmpi].length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; tmpj = 0 <= _ref2 ? ++_k : --_k) {
            if (stateGrid[tmpi].length < 15 || stateGrid[tmpi][tmpj].pos > 0) {
              debug("|        entry " + tmpj + ": " + (debugState(stateGrid[tmpi][tmpj])));
            } else {
              skipped++;
            }
          }
          if (skipped > 0) {
            debug("|    (plus " + skipped + " at pos 0 not shown)");
          }
        }
        debug('----------------------');
        j = 0;
        while (j < stateSet.length) {
          state = stateSet[j];
          debug("entry " + j + ":", debugState(state));
          next = getNext(state);
          debug('next:', next);
          if (next === null) {
            debug('considering if this completion matters to state set', state.ori);
            _ref3 = stateGrid[state.ori];
            for (k = _l = 0, _len1 = _ref3.length; _l < _len1; k = ++_l) {
              s = _ref3[k];
              if (getNext(s) === state.lhs) {
                s = copyState(s);
                s.pos++;
                got = state.got.slice(0);
                if (options.addCategories) {
                  got.unshift(state.lhs);
                }
                if (options.expressionBuilder != null) {
                  got.unshift(expressionBuilderFlag);
                }
                if (options.collapseBranches && got.length === 1) {
                  got = got[0];
                }
                s.got.push(got);
                stateGrid[i].push(s);
                debug("completer added this to " + i + ":", debugState(s));
                if ((numIterationsDone++ > (_ref4 = options.maxIterations) && _ref4 > 0)) {
                  throw 'Maximum number of iterations reached.';
                }
              }
            }
            j++;
            continue;
          }
          if (i >= input.length) {
            j++;
            continue;
          }
          debug('is it a terminal?', next instanceof RegExp);
          if (next instanceof RegExp) {
            if (next.test(input[i])) {
              copy = copyState(state);
              copy.pos++;
              copy.got.push(input[i]);
              stateGrid[i + 1].push(copy);
              debug("scanner added this to " + (i + 1) + ":", debugState(copy));
            }
            j++;
            continue;
          }
          if (!this.rules.hasOwnProperty(next)) {
            throw "Unknown non-terminal in grammar rule: " + next;
          }
          rhss = this.rules[next];
          debug("rhss: [" + (rhss.join('],[')) + "]");
          for (k = _m = 0, _len2 = rhss.length; _m < _len2; k = ++_m) {
            rhs = rhss[k];
            found = false;
            for (_n = 0, _len3 = stateSet.length; _n < _len3; _n++) {
              s = stateSet[_n];
              if (s.lhs === next && equalArrays(s.rhs, rhs) && s.pos === 0) {
                found = true;
                break;
              }
            }
            if (!found) {
              stateSet.push({
                lhs: next,
                rhs: rhs,
                pos: 0,
                ori: i,
                got: []
              });
              debug('adding this state:', debugState(stateSet[stateSet.length - 1]));
            }
          }
          j++;
          if ((numIterationsDone++ > (_ref5 = options.maxIterations) && _ref5 > 0)) {
            throw 'Maximum number of iterations reached.';
          }
        }
      }
      debug("finished processing this stateGrid (with input " + input + "):");
      debug('----------------------');
      for (tmpi = _o = 0, _ref6 = stateGrid.length; 0 <= _ref6 ? _o < _ref6 : _o > _ref6; tmpi = 0 <= _ref6 ? ++_o : --_o) {
        debug("|    state set " + tmpi + ":");
        skipped = 0;
        for (tmpj = _p = 0, _ref7 = stateGrid[tmpi].length; 0 <= _ref7 ? _p < _ref7 : _p > _ref7; tmpj = 0 <= _ref7 ? ++_p : --_p) {
          if (stateGrid[tmpi].length < 15 || stateGrid[tmpi][tmpj].pos > 0) {
            debug("|        entry " + tmpj + ": " + (debugState(stateGrid[tmpi][tmpj])));
          } else {
            skipped++;
          }
        }
        if (skipped > 0) {
          debug("|    (plus " + skipped + " at pos 0 not shown)");
        }
      }
      debug('----------------------');
      results = [];
      _ref8 = stateGrid[stateGrid.length - 1];
      for (_q = 0, _len4 = _ref8.length; _q < _len4; _q++) {
        stateSet = _ref8[_q];
        if (stateSet.lhs === '' && getNext(stateSet) === null) {
          result = stateSet.got[0];
          if (options.expressionBuilder != null) {
            recur = function(obj) {
              var args, o;
              if (!(obj instanceof Array) || obj[0] !== expressionBuilderFlag) {
                return obj;
              }
              args = (function() {
                var _len5, _r, _ref9, _results;
                _ref9 = obj.slice(1);
                _results = [];
                for (_r = 0, _len5 = _ref9.length; _r < _len5; _r++) {
                  o = _ref9[_r];
                  _results.push(recur(o));
                }
                return _results;
              })();
              if (args.length === 1 && options.collapseBranches) {
                args = args[0];
              }
              if (args.indexOf(void 0) > -1) {
                return void 0;
              }
              return options.expressionBuilder(args);
            };
            result = recur(result);
            if (result == null) {
              continue;
            }
          }
          found = false;
          for (_r = 0, _len5 = results.length; _r < _len5; _r++) {
            previous = results[_r];
            if (options.comparator(previous, result)) {
              found = true;
              break;
            }
          }
          if (!found) {
            results.push(result);
          }
        }
      }
      return results;
    };

    return Grammar;

  })();

  exports.Tokenizer = Tokenizer = (function() {
    function Tokenizer() {
      this.tokenize = __bind(this.tokenize, this);
      this.addType = __bind(this.addType, this);
      this.tokenTypes = [];
    }

    Tokenizer.prototype.addType = function(regexp, formatter) {
      if (formatter == null) {
        formatter = function(x) {
          return x;
        };
      }
      if (regexp.source[0] !== '^') {
        regexp = new RegExp("^(?:" + regexp.source + ")");
      }
      return this.tokenTypes.push({
        regexp: regexp,
        formatter: formatter
      });
    };

    Tokenizer.prototype.tokenize = function(input) {
      var format, match, next, original, result, token, type, _i, _len, _ref1;
      result = [];
      while (input.length > 0) {
        original = input.length;
        _ref1 = this.tokenTypes;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          type = _ref1[_i];
          if (!(match = type.regexp.exec(input))) {
            continue;
          }
          input = input.slice(match[0].length);
          if (type.formatter instanceof Function) {
            next = type.formatter(match[0], match);
            if (next != null) {
              result.push(next);
            }
          } else {
            format = "" + type.formatter;
            token = '';
            while (next = /\%([0-9]+)/.exec(format)) {
              token += format.slice(0, next.index) + match[next[1]];
              format = format.slice(next.index + next[0].length);
            }
            result.push(token + format);
          }
          break;
        }
        if (input.length === original) {
          return null;
        }
      }
      return result;
    };

    return Tokenizer;

  })();

  debugNestedArrays = function(ary) {
    if (ary instanceof Array) {
      if ('{}' === JSON.stringify(ary[0])) {
        ary = ary.slice(1);
      }
      return '[' + ary.map(debugNestedArrays).join(',') + ']';
    } else {
      return ary;
    }
  };

  debugState = function(state) {
    return "(" + state.lhs + " -> " + state.pos + "in[" + state.rhs + "], " + state.ori + ") got " + (debugNestedArrays(state.got));
  };

}).call(this);

//# sourceMappingURL=parsing.duo.js.map
