// Generated by CoffeeScript 1.7.1
(function() {
  var DOMEditAction, DOMEditTracker, LurchEditor,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.DOMEditAction = DOMEditAction = (function() {
    function DOMEditAction() {
      var action, data, end, i, node, process, that, type, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
      type = arguments[0], node = arguments[1], data = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (type === 'compound') {
        this.type = type;
        if (node == null) {
          this.subactions = [];
        } else if (node instanceof Array) {
          this.subactions = node;
        } else {
          this.subactions = [node].concat(data);
        }
        _ref = this.subactions;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          action = _ref[_i];
          if (!(action instanceof DOMEditAction)) {
            throw Error("Compound action array contained a non-action: " + action);
          }
        }
        if (this.subactions.length === 0) {
          this.node = [];
          this.tracker = null;
        } else {
          this.node = this.subactions[0].node;
          this.tracker = this.subactions[0].tracker;
          _ref1 = this.subactions.slice(1);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            action = _ref1[_j];
            end = action.length;
            if (end > this.node.length) {
              end = this.node.length;
            }
            for (i = _k = 1; 1 <= end ? _k < end : _k > end; i = 1 <= end ? ++_k : --_k) {
              if (this.node[i] !== action[i]) {
                this.node = this.node.slice(0, i);
                break;
              }
            }
          }
        }
        this.description = 'Document edit';
        return this;
      }
      if (!(node instanceof Node)) {
        throw Error('This is not a node: ' + node);
      }
      this.tracker = DOMEditTracker.instanceOver(node);
      this.type = type;
      this.node = node.address((_ref2 = this.tracker) != null ? _ref2.getElement() : void 0);
      if (type === 'appendChild') {
        if (data.length !== 1) {
          throw Error('Wrong # of parameters: ' + data);
        }
        if (!(data[0] instanceof Node)) {
          throw Error('Invalid parameter: ' + data);
        }
        this.toAppend = data[0].toJSON();
      } else if (type === 'insertBefore') {
        if (data.length !== 1 && data.length !== 2) {
          throw Error('Wrong # of parameters: ' + data);
        }
        if (!(data[0] instanceof Node)) {
          throw Error('Invalid parameter: ' + data[0]);
        }
        this.toInsert = data[0].toJSON();
        if (data.length === 2) {
          if (!(data[1] instanceof Node)) {
            throw Error('Invalid parameter: ' + data[1]);
          }
          if (data[1].parentNode !== node) {
            throw Error('Invalid child: ' + data[1]);
          }
          this.insertBefore = data[1].indexInParent();
        } else {
          this.insertBefore = node.childNodes.length;
        }
      } else if (type === 'normalize') {
        if (data.length !== 0) {
          throw Error('Wrong # of parameters: ' + data);
        }
        this.sequences = {};
        that = this;
        process = (function(_this) {
          return function(N, address) {
            var child, index, key, nextAddr, strings, _results;
            if (address == null) {
              address = [];
            }
            child = N.childNodes[0];
            index = 0;
            _results = [];
            while (child) {
              nextAddr = address.concat([index]);
              if (child instanceof Text && child.nextSibling instanceof Text) {
                strings = [];
                while (child instanceof Text) {
                  strings.push(child.textContent);
                  child = child.nextSibling;
                }
                key = JSON.stringify(nextAddr);
                _this.sequences[key] = strings;
              } else {
                process(child, nextAddr);
                child = child.nextSibling;
              }
              _results.push(index++);
            }
            return _results;
          };
        })(this);
        process(node);
      } else if (type === 'removeAttribute') {
        if (data.length !== 1) {
          throw Error('Wrong # of parameters: ' + data);
        }
        this.name = data[0] + '';
        this.value = node.getAttribute(this.name);
      } else if (type === 'removeAttributeNode') {
        if (data.length !== 1) {
          throw Error('Wrong # of parameters: ' + data);
        }
        if (!(data[0] instanceof Attr)) {
          throw Error('Invalid attribute node: ' + data[0]);
        }
        this.name = data[0].name;
        this.value = node.getAttribute(this.name);
      } else if (type === 'removeChild') {
        if (data.length !== 1) {
          throw Error('Wrong # of parameters: ' + data);
        }
        if (!(data[0] instanceof Node)) {
          throw Error('Invalid parameter: ' + data[0]);
        }
        if (data[0].parentNode !== node) {
          throw Error('Invalid child: ' + data[0]);
        }
        this.childIndex = data[0].indexInParent();
        this.child = data[0].toJSON();
      } else if (type === 'replaceChild') {
        if (data.length !== 2) {
          throw Error('Wrong # of parameters: ' + data);
        }
        if (!(data[0] instanceof Node)) {
          throw Error('Invalid parameter: ' + data[0]);
        }
        if (!(data[1] instanceof Node)) {
          throw Error('Invalid parameter: ' + data[1]);
        }
        if (data[1].parentNode !== node) {
          throw Error('Invalid child: ' + data[1]);
        }
        this.childIndex = data[1].indexInParent();
        this.oldChild = data[1].toJSON();
        this.newChild = data[0].toJSON();
      } else if (type === 'setAttribute') {
        if (data.length !== 2) {
          throw Error('Wrong # of parameters: ' + data);
        }
        this.name = data[0] + '';
        this.newValue = data[1] + '';
        this.oldValue = (node.getAttribute(this.name)) || '';
      } else if (type === 'setAttributeNode') {
        if (data.length !== 1) {
          throw Error('Wrong # of parameters: ' + data);
        }
        if (!(data[0] instanceof Attr)) {
          throw Error('Invalid parameter: ' + data[0]);
        }
        this.name = data[0].name;
        this.newValue = data[0].value;
        this.oldValue = (node.getAttribute(this.name)) || '';
      } else {
        throw Error('Invalid DOMEditAction type: ' + type);
      }
    }

    DOMEditAction.prototype.isNullAction = function() {
      var subaction, _i, _len, _ref;
      if (this.type === 'appendChild' || this.type === 'insertBefore' || this.type === 'removeChild') {
        return false;
      }
      if (this.type === 'removeAttribute' || this.type === 'removeAttributeNode') {
        return this.value === null;
      } else if (this.type === 'normalize') {
        return JSON.equals(this.sequences, {});
      } else if (this.type === 'replaceChild') {
        return JSON.equals(this.oldChild, this.newChild);
      } else if (this.type === 'setAttribute' || this.type === 'setAttributeNode') {
        return this.oldValue === this.newValue;
      } else if (this.type === 'compound') {
        _ref = this.subactions;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          subaction = _ref[_i];
          if (!subaction.isNullAction()) {
            return false;
          }
        }
        return true;
      } else {
        throw Error('Invalid DOMEditAction type: ' + this.type);
      }
    };

    DOMEditAction.prototype.toString = function() {
      var max, newv, oldv, orig, repl, text;
      max = 50;
      if (this.type === 'appendChild') {
        text = Node.fromJSON(this.toAppend).textContent;
        if (text.length > max) {
          text = text.slice(0, +max + 1 || 9e9) + '...';
        }
        if (text.length === 0) {
          text = 'a node';
        }
        return "Add " + text;
      } else if (this.type === 'insertBefore') {
        text = Node.fromJSON(this.toInsert).textContent;
        if (text.length > max) {
          text = text.slice(0, +max + 1 || 9e9) + '...';
        }
        if (text.length === 0) {
          text = 'a node';
        }
        return "Insert " + text;
      } else if (this.type === 'normalize') {
        return "Normalize text";
      } else if (this.type === 'removeAttribute' || this.type === 'removeAttributeNode') {
        return "Remove " + this.name + " attribute";
      } else if (this.type === 'removeChild') {
        text = Node.fromJSON(this.child).textContent;
        if (text.length > max) {
          text = text.slice(0, +max + 1 || 9e9) + '...';
        }
        if (text.length === 0) {
          text = 'a node';
        }
        return "Remove " + text;
      } else if (this.type === 'replaceChild') {
        orig = Node.fromJSON(this.oldChild).textContent;
        if (orig.length > max) {
          orig = orig.slice(0, +max + 1 || 9e9) + '...';
        }
        if (orig.length === 0) {
          orig = 'a node';
        }
        repl = Node.fromJSON(this.newChild).textContent;
        if (repl.length > max) {
          repl = repl.slice(0, +max + 1 || 9e9) + '...';
        }
        if (repl.length === 0) {
          repl = 'a node';
        }
        return "Replace " + orig + " with " + repl;
      } else if (this.type === 'setAttribute' || this.type === 'setAttributeNode') {
        oldv = this.oldValue || 'empty';
        newv = this.newValue || 'empty';
        return "Change " + this.name + " from " + oldv + " to " + newv;
      } else if (this.type === 'compound') {
        return this.description;
      } else {
        return "Error, unknown edit action type: " + this.type;
      }
    };

    DOMEditAction.prototype.toJSON = function() {
      return {
        type: this.type,
        node: this.node,
        toAppend: this.toAppend,
        toInsert: this.toInsert,
        insertBefore: this.insertBefore,
        sequences: this.sequences,
        name: this.name,
        value: this.value,
        child: this.child,
        childIndex: this.childIndex,
        oldChild: this.oldChild,
        newChild: this.newChild,
        oldValue: this.oldValue,
        newValue: this.newValue,
        description: this.description,
        subactions: this.subactions
      };
    };

    DOMEditAction.prototype.redo = function() {
      var action, newnode, original, replacement, _i, _len, _ref, _results;
      if (!this.tracker) {
        throw Error('Cannot redo action with no DOMEditTracker');
      }
      original = this.tracker.getElement().index(this.node);
      if (this.type === 'appendChild') {
        return original.appendChild(Node.fromJSON(this.toAppend));
      } else if (this.type === 'insertBefore') {
        newnode = Node.fromJSON(this.toInsert);
        if (this.insertBefore === original.childNodes.length) {
          return original.appendChild(newnode);
        } else {
          return original.insertBefore(newnode, original.childNodes[this.insertBefore]);
        }
      } else if (this.type === 'normalize') {
        return original.normalize();
      } else if (this.type === 'removeAttribute' || this.type === 'removeAttributeNode') {
        return original.removeAttribute(this.name);
      } else if (this.type === 'removeChild') {
        return original.removeChild(original.childNodes[this.childIndex]);
      } else if (this.type === 'replaceChild') {
        replacement = Node.fromJSON(this.newChild);
        return original.replaceChild(replacement, original.childNodes[this.childIndex]);
      } else if (this.type === 'setAttribute' || this.type === 'setAttributeNode') {
        return original.setAttribute(this.name, this.newValue);
      } else if (this.type === 'compound') {
        _ref = this.subactions;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          action = _ref[_i];
          _results.push(action.redo());
        }
        return _results;
      }
    };

    DOMEditAction.prototype.undo = function() {
      var action, addBack, d, descendants, key, original, replacement, string, _i, _len, _ref, _ref1, _ref2, _results, _results1;
      if (!this.tracker) {
        throw Error('Cannot undo action with no DOMEditTracker');
      }
      original = this.tracker.getElement().index(this.node);
      if (this.type === 'appendChild') {
        return original.removeChild(original.childNodes[original.childNodes.length - 1]);
      } else if (this.type === 'insertBefore') {
        return original.removeChild(original.childNodes[this.insertBefore]);
      } else if (this.type === 'normalize') {
        descendants = {};
        _ref = this.sequences;
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          descendants[key] = original.index(JSON.parse(key));
        }
        _ref1 = this.sequences;
        _results = [];
        for (key in _ref1) {
          if (!__hasProp.call(_ref1, key)) continue;
          d = descendants[key];
          _results.push((function() {
            var _i, _len, _ref2, _results1;
            _ref2 = this.sequences[key];
            _results1 = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              string = _ref2[_i];
              if (string.length < d.textContent.length) {
                d.splitText(string.length);
                _results1.push(d = d.nextSibling);
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        }
        return _results;
      } else if (this.type === 'removeAttribute' || this.type === 'removeAttributeNode') {
        return original.setAttribute(this.name, this.value);
      } else if (this.type === 'removeChild') {
        addBack = Node.fromJSON(this.child);
        if (this.childIndex === original.childNodes.length) {
          return original.appendChild(addBack);
        } else {
          return original.insertBefore(addBack, original.childNodes[this.childIndex]);
        }
      } else if (this.type === 'replaceChild') {
        replacement = Node.fromJSON(this.oldChild);
        return original.replaceChild(replacement, original.childNodes[this.childIndex]);
      } else if (this.type === 'setAttribute' || this.type === 'setAttributeNode') {
        if (this.oldValue !== '') {
          return original.setAttribute(this.name, this.oldValue);
        } else {
          return original.removeAttribute(this.name);
        }
      } else if (this.type === 'compound') {
        _ref2 = this.subactions.slice(0).reverse();
        _results1 = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          action = _ref2[_i];
          _results1.push(action.undo());
        }
        return _results1;
      }
    };

    return DOMEditAction;

  })();

  window.DOMEditTracker = DOMEditTracker = (function() {
    DOMEditTracker.instances = [];

    DOMEditTracker.instanceOver = function(node) {
      var tracker, _i, _len, _ref;
      if (!(node instanceof Node)) {
        return null;
      }
      _ref = this.instances;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tracker = _ref[_i];
        if (tracker.getElement() === node) {
          return tracker;
        }
      }
      return this.instanceOver(node.parentNode);
    };

    function DOMEditTracker(div) {
      if (div && (div != null ? div.tagName : void 0) !== 'DIV') {
        throw new Error('DOMEditTracker can only be ' + 'constructed in a DIV node');
      }
      this.element = div || null;
      this.stack = [];
      this.stackPointer = 0;
      this.stackRecording = true;
      this.compoundActions = null;
      this.compoundName = null;
      this.listeners = [];
      DOMEditTracker.instances.push(this);
    }

    DOMEditTracker.prototype.getElement = function() {
      return this.element;
    };

    DOMEditTracker.prototype.getEditActions = function() {
      return this.stack.slice(0);
    };

    DOMEditTracker.prototype.clearStack = function() {
      return this.stack = [];
    };

    DOMEditTracker.prototype.nodeEditHappened = function(action) {
      var listener, _i, _len, _ref;
      if (!(action instanceof DOMEditAction)) {
        return;
      }
      if (action.isNullAction()) {
        return;
      }
      _ref = this.listeners;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        listener = _ref[_i];
        listener(action);
      }
      if (!this.stackRecording) {
        return;
      }
      if (this.compoundActions !== null) {
        this.compoundActions.push(action);
        return;
      }
      if (this.stackPointer < this.stack.length) {
        this.stack = this.stack.slice(0, this.stackPointer);
      }
      this.stack.push(action);
      return this.stackPointer = this.stack.length;
    };

    DOMEditTracker.prototype.startCompoundAction = function(name) {
      if (this.compoundActions !== null) {
        return;
      }
      this.compoundActions = [];
      return this.compoundName = name;
    };

    DOMEditTracker.prototype.endCompoundAction = function() {
      var action;
      if (this.compoundActions === null) {
        return;
      }
      action = new DOMEditAction('compound', this.compoundActions);
      if (this.compoundName) {
        action.name = this.compoundName;
      }
      this.compoundActions = null;
      this.compoundName = null;
      return this.nodeEditHappened(action);
    };

    DOMEditTracker.prototype.canUndo = function() {
      return this.stackPointer > 0;
    };

    DOMEditTracker.prototype.canRedo = function() {
      return this.stackPointer < this.stack.length;
    };

    DOMEditTracker.prototype.undoDescription = function() {
      if (this.stackPointer === 0) {
        return '';
      } else {
        return "Undo " + (this.stack[this.stackPointer - 1].toString());
      }
    };

    DOMEditTracker.prototype.redoDescription = function() {
      if (this.stackPointer === this.stack.length) {
        return '';
      } else {
        return "Redo " + (this.stack[this.stackPointer].toString());
      }
    };

    DOMEditTracker.prototype.undo = function() {
      this.endCompoundAction();
      if (this.stackPointer > 0) {
        this.stackRecording = false;
        this.stack[this.stackPointer - 1].undo();
        this.stackRecording = true;
        return this.stackPointer--;
      }
    };

    DOMEditTracker.prototype.redo = function() {
      if (this.compoundActions !== null) {
        return;
      }
      if (this.stackPointer < this.stack.length) {
        this.stackRecording = false;
        this.stack[this.stackPointer].redo();
        this.stackRecording = true;
        return this.stackPointer++;
      }
    };

    DOMEditTracker.prototype.listen = function(callback) {
      return this.listeners.push(callback);
    };

    return DOMEditTracker;

  })();

  Node.prototype.address = function(ancestor) {
    var recur;
    if (ancestor == null) {
      ancestor = null;
    }
    if (this === ancestor) {
      return [];
    }
    if (!this.parentNode) {
      if (ancestor) {
        return null;
      } else {
        return [];
      }
    }
    recur = this.parentNode.address(ancestor);
    if (recur === null) {
      return null;
    }
    return recur.concat([this.indexInParent()]);
  };

  Node.prototype.indexInParent = function() {
    if (this.parentNode) {
      return Array.prototype.slice.apply(this.parentNode.childNodes).indexOf(this);
    } else {
      return -1;
    }
  };

  Node.prototype.index = function(address) {
    var _ref;
    if (!(address instanceof Array)) {
      throw Error('Node address function requires an array');
    }
    if (address.length === 0) {
      return this;
    }
    if (typeof address[0] !== 'number') {
      return void 0;
    }
    return (_ref = this.childNodes[address[0]]) != null ? _ref.index(address.slice(1)) : void 0;
  };

  Node.prototype.toJSON = function(verbose) {
    var attribute, chi, result, _i, _len, _ref;
    if (verbose == null) {
      verbose = true;
    }
    if (this instanceof Text) {
      return this.textContent;
    }
    if (this instanceof Comment) {
      if (verbose) {
        return {
          comment: true,
          content: this.textContent
        };
      } else {
        return {
          m: true,
          n: this.textContent
        };
      }
    }
    if (!(this instanceof Element)) {
      throw Error("Cannot serialize this node: " + this);
    }
    result = {
      tagName: this.tagName
    };
    if (this.attributes.length) {
      result.attributes = {};
      _ref = this.attributes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attribute = _ref[_i];
        result.attributes[attribute.name] = attribute.value;
      }
    }
    if (this.childNodes.length) {
      result.children = (function() {
        var _j, _len1, _ref1, _results;
        _ref1 = this.childNodes;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          chi = _ref1[_j];
          _results.push(chi.toJSON(verbose));
        }
        return _results;
      }).call(this);
    }
    if (!verbose) {
      result.t = result.tagName;
      delete result.tagName;
      result.a = result.attributes;
      delete result.attributes;
      result.c = result.children;
      delete result.children;
    }
    return result;
  };

  Node.fromJSON = function(json) {
    var attributes, child, children, key, result, value, _i, _len;
    if (typeof json === 'string') {
      return document.createTextNode(json);
    }
    if ('comment' in json && json.comment) {
      return document.createComment(json.content);
    }
    if ('m' in json && json.m) {
      return document.createComment(json.n);
    }
    if (!'tagName' in json && !'t' in json) {
      throw Error("Object has no t[agName]: " + this);
    }
    result = document.createElement(json.tagName || json.t);
    if (attributes = json.attributes || json.a) {
      for (key in attributes) {
        if (!__hasProp.call(attributes, key)) continue;
        value = attributes[key];
        result.setAttribute(key, value);
      }
    }
    if (children = json.children || json.c) {
      for (_i = 0, _len = children.length; _i < _len; _i++) {
        child = children[_i];
        result.appendChild(Node.fromJSON(child));
      }
    }
    return result;
  };

  'appendChild insertBefore normalize removeAttribute removeAttributeNode removeChild replaceChild setAttribute setAttributeNode'.split(/\s+/).map(function(methodName) {
    var original, which;
    which = Node.prototype[methodName] ? Node : Element;
    original = which.prototype[methodName];
    return which.prototype[methodName] = function() {
      var args, event, result, tracker;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      tracker = DOMEditTracker.instanceOver(this);
      if (tracker) {
        event = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(DOMEditAction, [methodName, this].concat(__slice.call(args)), function(){});
      }
      result = original.call.apply(original, [this].concat(__slice.call(args)));
      if (tracker) {
        tracker.nodeEditHappened(event);
      }
      return result;
    };
  });

  Node.prototype.nextLeaf = function(container) {
    var walk;
    if (container == null) {
      container = null;
    }
    walk = this;
    while (walk && walk !== container && !walk.nextSibling) {
      walk = walk.parentNode;
    }
    walk = walk != null ? walk.nextSibling : void 0;
    if (!walk) {
      return null;
    }
    while (walk.childNodes.length > 0) {
      walk = walk.childNodes[0];
    }
    return walk;
  };

  Node.prototype.previousLeaf = function(container) {
    var walk;
    if (container == null) {
      container = null;
    }
    walk = this;
    while (walk && walk !== container && !walk.previousSibling) {
      walk = walk.parentNode;
    }
    walk = walk != null ? walk.previousSibling : void 0;
    if (!walk) {
      return null;
    }
    while (walk.childNodes.length > 0) {
      walk = walk.childNodes[walk.childNodes.length - 1];
    }
    return walk;
  };

  Node.prototype.remove = function() {
    var _ref;
    return (_ref = this.parentNode) != null ? _ref.removeChild(this) : void 0;
  };

  Element.prototype.hasClass = function(name) {
    var classes, _ref;
    classes = (_ref = this.getAttribute('class')) != null ? _ref.split(/\s+/) : void 0;
    return classes && __indexOf.call(classes, name) >= 0;
  };

  Element.prototype.addClass = function(name) {
    var classes, _ref;
    classes = ((_ref = this.getAttribute('class')) != null ? _ref.split(/\s+/) : void 0) || [];
    if (__indexOf.call(classes, name) < 0) {
      classes.push(name);
    }
    return this.setAttribute('class', classes.join(' '));
  };

  Element.prototype.removeClass = function(name) {
    var c, classes, _ref;
    classes = ((_ref = this.getAttribute('class')) != null ? _ref.split(/\s+/) : void 0) || [];
    classes = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = classes.length; _i < _len; _i++) {
        c = classes[_i];
        if (c !== name) {
          _results.push(c);
        }
      }
      return _results;
    })();
    if (classes.length > 0) {
      return this.setAttribute('class', classes.join(' '));
    } else {
      return this.removeAttribute('class');
    }
  };

  window.LurchEditor = LurchEditor = (function(_super) {
    var t;

    __extends(LurchEditor, _super);

    LurchEditor.prototype.nextFreeId = function() {
      if (this.freeIds.length > 1) {
        return this.freeIds.shift();
      } else {
        return this.freeIds[0]++;
      }
    };

    LurchEditor.prototype.addFreeId = function(id) {
      if (id < this.freeIds[this.freeIds.length - 1]) {
        this.freeIds.push(id);
        return this.freeIds.sort(function(a, b) {
          return a - b;
        });
      }
    };

    LurchEditor.prototype.cursorTimerId = null;

    function LurchEditor(div) {
      var i, usedIds;
      LurchEditor.__super__.constructor.call(this, div);
      usedIds = this.cleanIds(div);
      this.freeIds = usedIds.length === 0 ? [0] : (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = (Math.max.apply(Math, usedIds)) + 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (__indexOf.call(usedIds, i) < 0) {
            _results.push(i);
          }
        }
        return _results;
      })();
      this.assignIds(div);
      this.clearStack();
      this.cursor = {
        position: null,
        anchor: null
      };
      if (LurchEditor.prototype.cursorTimerId === null) {
        LurchEditor.prototype.cursorTimerId = setInterval(LurchEditor.prototype.blinkCursors, 500);
      }
    }

    LurchEditor.prototype.cleanIds = function(node) {
      var child, id, result, _i, _len, _ref;
      result = [];
      if (!(node instanceof Node)) {
        return result;
      }
      if (node.id) {
        if (/^\d+$/.test(node.id)) {
          result.push(parseInt(node.id));
        } else {
          node.removeAttribute('id');
        }
      }
      _ref = node.childNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        result = result.concat((function() {
          var _j, _len1, _ref1, _results;
          _ref1 = this.cleanIds(child);
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            id = _ref1[_j];
            if (__indexOf.call(result, id) < 0) {
              _results.push(id);
            }
          }
          return _results;
        }).call(this));
      }
      return result;
    };

    LurchEditor.prototype.assignIds = function(node) {
      var child, _i, _len, _ref, _results;
      if (!(node instanceof Node)) {
        return;
      }
      if (node instanceof HTMLElement && !node.id) {
        node.id = this.nextFreeId();
      }
      _ref = node.childNodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        _results.push(this.assignIds(child));
      }
      return _results;
    };

    LurchEditor.prototype.address = function(node) {
      if (this.element) {
        return node != null ? node.address(this.element) : void 0;
      } else {
        return null;
      }
    };

    LurchEditor.prototype.index = function(address) {
      if (this.element) {
        return this.element.index(address);
      } else {
        return null;
      }
    };

    LurchEditor.prototype.positionId = 'lurch-cursor-position';

    LurchEditor.prototype.anchorId = 'lurch-cursor-anchor';

    LurchEditor.prototype.selectionClass = 'lurch-cursor-selection';

    LurchEditor.prototype.updateCursor = function() {
      var start, walk;
      this.cursor = {
        position: null,
        anchor: null
      };
      walk = start = document.getElementById(LurchEditor.prototype.positionId);
      while (walk && !this.cursor.position) {
        if (walk === this.element) {
          this.cursor.position = start;
        }
        walk = walk.parentNode;
      }
      walk = start = document.getElementById(LurchEditor.prototype.anchorId);
      while (walk && !this.cursor.anchor) {
        if (walk === this.element) {
          this.cursor.anchor = start;
        }
        walk = walk.parentNode;
      }
      return this.cursor.anchor = this.cursor.anchor || this.cursor.position;
    };

    LurchEditor.prototype.elementsSupportingCursor = (function() {
      var _i, _len, _ref, _results;
      _ref = 'a abbr acronym address article aside b bdi bdo big blockquote caption center cite code dd details dfn div dl dt em fieldset figcaption figure footer form header h1 h2 h3 h4 h5 h6 i kbd label legend li mark nav ol p pre q s samp section small span strong sub summary sup td th time u ul var'.trim().split(/\s+/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        _results.push(t.toUpperCase());
      }
      return _results;
    })();

    LurchEditor.prototype.shouldBeCounted = function(tagName) {
      if (tagName instanceof Node) {
        tagName = tagName.tagName;
      }
      if (__indexOf.call(LurchEditor.prototype.elementsSupportingCursor, tagName) >= 0) {
        return 1;
      } else {
        return 0;
      }
    };

    LurchEditor.prototype.selectionWrapClass = 'lurch-selection-wrap';

    LurchEditor.prototype.wrapForSelection = function(textNode) {
      var wrap, _ref;
      wrap = document.createElement('span');
      wrap.addClass(LurchEditor.prototype.selectionWrapClass);
      wrap.addClass(LurchEditor.prototype.selectionClass);
      if ((_ref = textNode.parentNode) != null) {
        _ref.replaceChild(wrap, textNode);
      }
      return wrap.appendChild(textNode);
    };

    LurchEditor.prototype.unwrapFromSelection = function(wrapSpan) {
      var textNode;
      textNode = wrapSpan.childNodes[0];
      return wrapSpan.parentNode.replaceChild(textNode, wrapSpan);
    };

    LurchEditor.prototype.isWrappedForSelection = function(node) {
      return typeof node.hasClass === "function" ? node.hasClass(LurchEditor.prototype.selectionWrapClass) : void 0;
    };

    LurchEditor.prototype.cursorPositionsIn = function(node) {
      var child, id, index, interstice, result, _i, _len, _ref;
      if (!(node instanceof Node)) {
        throw Error("cursorPositionsIn requires a Node as the parameter, but got this: " + node);
      }
      if (node instanceof Text) {
        return node.length - 1;
      } else if (this.isWrappedForSelection(node)) {
        return this.cursorPositionsIn(node.childNodes[0]);
      } else if (node.childNodes.length === 0) {
        return this.shouldBeCounted(node);
      } else {
        interstice = this.shouldBeCounted(node);
        result = interstice;
        _ref = Array.prototype.slice.apply(node.childNodes);
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          child = _ref[index];
          id = typeof child.getAttribute === "function" ? child.getAttribute('id') : void 0;
          if (id !== LurchEditor.prototype.positionId && id !== LurchEditor.prototype.anchorId) {
            result += interstice + this.cursorPositionsIn(child);
          }
        }
        return result;
      }
    };

    LurchEditor.prototype.cursorPositionOf = function(node, ancestor) {
      var id, interstice, positionInParent, sibling;
      if (ancestor == null) {
        ancestor = this.getElement();
      }
      if (!node.parentNode) {
        return 0;
      }
      positionInParent = 0;
      sibling = node.parentNode.childNodes[0];
      interstice = this.shouldBeCounted(node.parentNode);
      while (sibling !== node) {
        id = typeof sibling.getAttribute === "function" ? sibling.getAttribute('id') : void 0;
        if (id !== LurchEditor.prototype.positionId && id !== LurchEditor.prototype.anchorId) {
          positionInParent += interstice + this.cursorPositionsIn(sibling);
        }
        sibling = sibling.nextSibling;
      }
      if (node.parentNode === ancestor) {
        return positionInParent;
      }
      return positionInParent + (this.shouldBeCounted(node.parentNode.parentNode)) + this.cursorPositionOf(node.parentNode, ancestor);
    };

    LurchEditor.prototype.cursorPosition = function() {
      this.updateCursor();
      if (!this.cursor.position) {
        return -1;
      }
      return this.cursorPositionOf(this.cursor.position);
    };

    LurchEditor.prototype.anchorPosition = function() {
      this.updateCursor();
      if (!this.cursor.anchor) {
        return -1;
      }
      return this.cursorPositionOf(this.cursor.anchor);
    };

    LurchEditor.prototype.insertNodeAt = function(toInsert, position, inNode) {
      var child, count, id, interstice, size, split, _i, _len, _ref;
      if (position == null) {
        position = 0;
      }
      if (inNode == null) {
        inNode = this.getElement();
      }
      if (this.isWrappedForSelection(inNode)) {
        return this.insertNodeAt(toInsert, position, inNode.childNodes[0]);
      }
      if (inNode instanceof Text) {
        if (position + 1 <= 0) {
          inNode.parentNode.insertBefore(toInsert, inNode);
        } else if (position + 1 >= inNode.textContent.length) {
          inNode.parentNode.appendChild(toInsert);
        } else {
          split = inNode.splitText(position + 1);
          inNode.parentNode.insertBefore(toInsert, split);
        }
        return;
      }
      interstice = this.shouldBeCounted(inNode);
      count = 0;
      _ref = Array.prototype.slice.apply(inNode.childNodes);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        if (interstice > 0 && count === position) {
          inNode.insertBefore(toInsert, child);
          return;
        }
        id = typeof child.getAttribute === "function" ? child.getAttribute('id') : void 0;
        if (id === LurchEditor.prototype.positionId || id === LurchEditor.prototype.anchorId) {
          continue;
        }
        count += interstice;
        size = this.cursorPositionsIn(child);
        if (position < count + size) {
          this.insertNodeAt(toInsert, position - count, child);
          return;
        }
        count += size;
      }
      if (interstice > 0) {
        return inNode.appendChild(toInsert);
      }
    };

    LurchEditor.prototype.removeCursor = function() {
      var element, selection, _i, _len, _ref, _ref1, _ref2;
      this.updateCursor();
      if ((_ref = this.cursor.position) != null) {
        _ref.remove();
      }
      if ((_ref1 = this.cursor.anchor) != null) {
        _ref1.remove();
      }
      this.cursor.position = this.cursor.anchor = null;
      selection = Array.prototype.slice.apply(this.element.getElementsByClassName(LurchEditor.prototype.selectionClass));
      for (_i = 0, _len = selection.length; _i < _len; _i++) {
        element = selection[_i];
        if (this.isWrappedForSelection(element)) {
          this.unwrapFromSelection(element);
        } else {
          element.removeClass(LurchEditor.prototype.selectionClass);
        }
      }
      return (_ref2 = this.getElement()) != null ? _ref2.normalize() : void 0;
    };

    LurchEditor.prototype.placeCursor = function(position, moveAnchor) {
      var anchor, anchorIndex, cursor, marker1, marker2, selectUpTo, stepRight, textNode, textNodesToSelect, walk, _i, _len, _ref, _ref1, _results;
      if (position == null) {
        position = 0;
      }
      if (moveAnchor == null) {
        moveAnchor = true;
      }
      anchorIndex = this.anchorPosition();
      this.removeCursor();
      cursor = document.createElement('span');
      cursor.setAttribute('id', LurchEditor.prototype.positionId);
      this.insertNodeAt(cursor, position);
      this.cursor.position = cursor;
      if (moveAnchor || anchorIndex === -1) {
        this.cursor.anchor = this.cursor.position;
        return;
      }
      anchor = document.createElement('span');
      anchor.setAttribute('id', LurchEditor.prototype.anchorId);
      this.insertNodeAt(anchor, anchorIndex);
      this.cursor.anchor = anchor;
      if (anchor.previousSibling === cursor || anchor.nextSibling === cursor) {
        anchor.remove();
        this.cursor.anchor = this.cursor.position;
        return;
      }
      _ref = position < anchorIndex ? [cursor, anchor] : [anchor, cursor], marker1 = _ref[0], marker2 = _ref[1];
      stepRight = (function(_this) {
        return function(fromHere) {
          if (fromHere === null || fromHere === _this.getElement()) {
            return null;
          }
          return fromHere.nextSibling || stepRight(fromHere.parentNode);
        };
      })(this);
      textNodesToSelect = [];
      selectUpTo = function(inThis, stopHere) {
        var child, _i, _len, _ref1;
        if (inThis === stopHere) {
          return true;
        }
        if (!(inThis instanceof Element)) {
          if (inThis instanceof Text) {
            textNodesToSelect.push(inThis);
          }
          return false;
        }
        _ref1 = Array.prototype.slice.apply(inThis.childNodes);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          child = _ref1[_i];
          if (selectUpTo(child, stopHere)) {
            return true;
          }
        }
        inThis.addClass(LurchEditor.prototype.selectionClass);
        return false;
      };
      walk = marker1;
      while (walk = stepRight(walk)) {
        if (selectUpTo(walk, marker2)) {
          break;
        }
      }
      _results = [];
      for (_i = 0, _len = textNodesToSelect.length; _i < _len; _i++) {
        textNode = textNodesToSelect[_i];
        if (!((_ref1 = textNode.parentNode) != null ? _ref1.hasClass(LurchEditor.prototype.selectionClass) : void 0)) {
          _results.push(this.wrapForSelection(textNode));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    LurchEditor.prototype.moveCursor = function(delta, moveAnchor) {
      var current, newpos;
      if (delta == null) {
        delta = 0;
      }
      if (moveAnchor == null) {
        moveAnchor = true;
      }
      console.log('moveCursor', this.cursorPosition());
      if ((current = this.cursorPosition()) === -1) {
        return;
      }
      console.log('current', current);
      if ((newpos = current + delta) < 0) {
        newpos = 0;
      }
      console.log('newpos', newpos);
      this.placeCursor(newpos, moveAnchor);
      return console.log('done');
    };

    LurchEditor.prototype.cursorVisible = 'lurch-cursor-visible';

    LurchEditor.prototype.blinkCursors = function(onOff) {
      var LE, cssClass, oldValue, _i, _len, _ref, _results;
      if (onOff == null) {
        onOff = 'toggle';
      }
      cssClass = LurchEditor.prototype.cursorVisible;
      _ref = DOMEditTracker.instances;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        LE = _ref[_i];
        if (LE instanceof LurchEditor) {
          LE.updateCursor();
          if (!LE.cursor.position) {
            continue;
          }
          oldValue = LE.stackRecording;
          LE.stackRecording = false;
          if (onOff === 'toggle') {
            onOff = !LE.cursor.position.hasClass(cssClass);
          }
          if (onOff) {
            LE.cursor.position.addClass(cssClass);
          } else {
            LE.cursor.position.removeClass(cssClass);
          }
          _results.push(LE.stackRecording = oldValue);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return LurchEditor;

  })(DOMEditTracker);

  JSON.equals = function(x, y) {
    var key, xkeys, ykeys, _i, _len;
    if ((x instanceof Object) !== (y instanceof Object)) {
      return false;
    }
    if ((x instanceof Array) !== (y instanceof Array)) {
      return false;
    }
    if (!(x instanceof Object)) {
      return x === y;
    }
    xkeys = (Object.keys(x)).sort();
    ykeys = (Object.keys(y)).sort();
    if ((JSON.stringify(xkeys)) !== (JSON.stringify(ykeys))) {
      return false;
    }
    for (_i = 0, _len = xkeys.length; _i < _len; _i++) {
      key = xkeys[_i];
      if (!JSON.equals(x[key], y[key])) {
        return false;
      }
    }
    return true;
  };

}).call(this);

//# sourceMappingURL=weblurch.map
