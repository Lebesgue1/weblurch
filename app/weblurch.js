// Generated by CoffeeScript 1.8.0
(function() {
  var BackgroundFunction, Grammar, Match, OM, OMNode, Tokenizer, addToCache, cacheLookup, clearMetavariable, copyState, debugNestedArrays, debugState, drawHTMLCache, equalArrays, exports, getNext, isMetavariable, makeBlob, markUsed, matchDebuggingEnabled, matches, mdebug, metavariableSymbol, pruneCache, setMetavariable, trueValue, _ref, _ref1, _ref2, _ref3,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  JSON.equals = function(x, y) {
    var key, xkeys, ykeys, _i, _len;
    if ((x instanceof Object) !== (y instanceof Object)) {
      return false;
    }
    if ((x instanceof Array) !== (y instanceof Array)) {
      return false;
    }
    if (!(x instanceof Object)) {
      return x === y;
    }
    xkeys = (Object.keys(x)).sort();
    ykeys = (Object.keys(y)).sort();
    if ((JSON.stringify(xkeys)) !== (JSON.stringify(ykeys))) {
      return false;
    }
    for (_i = 0, _len = xkeys.length; _i < _len; _i++) {
      key = xkeys[_i];
      if (!JSON.equals(x[key], y[key])) {
        return false;
      }
    }
    return true;
  };

  if (typeof exports === "undefined" || exports === null) {
    exports = (_ref = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref : window;
  }

  exports.OMNode = exports.OM = OM = OMNode = (function() {
    var tokenTypes;

    OMNode.checkJSON = function(object) {
      var checkKeys, child, e, identRE, key, reason, symbol, value, variable, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _ref4;
      if (!(object instanceof Object)) {
        return "Expected an object, found " + (typeof object);
      }
      if (object.hasOwnProperty('a')) {
        _ref1 = object.a;
        for (key in _ref1) {
          if (!__hasProp.call(_ref1, key)) continue;
          value = _ref1[key];
          try {
            symbol = JSON.parse(key);
          } catch (_error) {
            e = _error;
            return "Key " + key + " invalid JSON";
          }
          if (symbol.t !== 'sy') {
            return "Key " + key + " is not a symbol";
          }
          if (reason = this.checkJSON(symbol)) {
            return reason;
          }
          if (reason = this.checkJSON(value)) {
            return reason;
          }
        }
      }
      checkKeys = function() {
        var list, _i, _len, _ref2;
        list = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        _ref2 = Object.keys(object);
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          key = _ref2[_i];
          if (__indexOf.call(list, key) < 0 && key !== 't' && key !== 'a') {
            return "Key " + key + " not valid in object of type " + object.t;
          }
        }
        return null;
      };
      identRE = /^[:A-Za-z_\u0374-\u03FF][:A-Za-z_\u0374-\u03FF.0-9-]*$/;
      switch (object.t) {
        case 'i':
          if (reason = checkKeys('v')) {
            return reason;
          }
          if (!/^[+-]?[0-9]+$/.test("" + object.v)) {
            return "Not an integer: " + object.v;
          }
          break;
        case 'f':
          if (reason = checkKeys('v')) {
            return reason;
          }
          if (typeof object.v !== 'number') {
            return "Not a number: " + object.v + " of type " + (typeof object.v);
          }
          if (isNaN(object.v)) {
            return 'OpenMath floats cannot be NaN';
          }
          if (!isFinite(object.v)) {
            return 'OpenMath floats must be finite';
          }
          break;
        case 'st':
          if (reason = checkKeys('v')) {
            return reason;
          }
          if (typeof object.v !== 'string') {
            return "Value for st type was " + (typeof object.v) + ", not string";
          }
          break;
        case 'ba':
          if (reason = checkKeys('v')) {
            return reason;
          }
          if (!(object.v instanceof Uint8Array)) {
            return "Value for ba type was not an instance of Uint8Array";
          }
          break;
        case 'sy':
          if (reason = checkKeys('n', 'cd', 'uri')) {
            return reason;
          }
          if (typeof object.n !== 'string') {
            return "Name for sy type was " + (typeof object.n) + ", not string";
          }
          if (typeof object.cd !== 'string') {
            return "CD for sy type was " + (typeof object.cd) + ", not string";
          }
          if ((object.uri != null) && typeof object.uri !== 'string') {
            return "URI for sy type was " + (typeof object.uri) + ", not string";
          }
          if (!identRE.test(object.n)) {
            return "Invalid identifier as symbol name: " + object.n;
          }
          if (!identRE.test(object.cd)) {
            return "Invalid identifier as symbol CD: " + object.cd;
          }
          break;
        case 'v':
          if (reason = checkKeys('n')) {
            return reason;
          }
          if (typeof object.n !== 'string') {
            return "Name for v type was " + (typeof object.n) + ", not string";
          }
          if (!identRE.test(object.n)) {
            return "Invalid identifier as variable name: " + object.n;
          }
          break;
        case 'a':
          if (reason = checkKeys('c')) {
            return reason;
          }
          if (!(object.c instanceof Array)) {
            return "Children of application object was not an array";
          }
          if (object.c.length === 0) {
            return "Application object must have at least one child";
          }
          _ref2 = object.c;
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            child = _ref2[_i];
            if (reason = this.checkJSON(child)) {
              return reason;
            }
          }
          break;
        case 'bi':
          if (reason = checkKeys('s', 'v', 'b')) {
            return reason;
          }
          if (reason = this.checkJSON(object.s)) {
            return reason;
          }
          if (object.s.t !== 'sy') {
            return "Head of a binding must be a symbol";
          }
          if (!(object.v instanceof Array)) {
            return "In a binding, the v value must be an array";
          }
          _ref3 = object.v;
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            variable = _ref3[_j];
            if (reason = this.checkJSON(variable)) {
              return reason;
            }
            if (variable.t !== 'v') {
              return "In a binding, all values in the v array must have type v";
            }
          }
          if (reason = this.checkJSON(object.b)) {
            return reason;
          }
          break;
        case 'e':
          if (reason = checkKeys('s', 'c')) {
            return reason;
          }
          if (reason = this.checkJSON(object.s)) {
            return reason;
          }
          if (object.s.t !== 'sy') {
            return "Head of an error must be a symbol";
          }
          if (!(object.c instanceof Array)) {
            return "In an error, the c key must be an array";
          }
          _ref4 = object.c;
          for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
            child = _ref4[_k];
            if (reason = this.checkJSON(child)) {
              return reason;
            }
          }
          break;
        default:
          return "Invalid type: " + object.t;
      }
      return null;
    };

    OMNode.decode = function(json) {
      var e, reason, setParents;
      if (typeof json === 'string') {
        try {
          json = JSON.parse(json);
        } catch (_error) {
          e = _error;
          return e.message;
        }
      }
      if (reason = this.checkJSON(json)) {
        return reason;
      }
      setParents = function(node) {
        var c, k, v, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
        _ref2 = (_ref1 = node.c) != null ? _ref1 : [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          c = _ref2[_i];
          c.p = node;
          setParents(c);
        }
        _ref4 = (_ref3 = node.v) != null ? _ref3 : [];
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          v = _ref4[_j];
          v.p = node;
          setParents(v);
        }
        _ref6 = (_ref5 = node.a) != null ? _ref5 : {};
        for (k in _ref6) {
          if (!__hasProp.call(_ref6, k)) continue;
          v = _ref6[k];
          v.p = node;
          setParents(v);
        }
        if (node.s != null) {
          node.s.p = node;
          setParents(node.s);
        }
        if (node.b != null) {
          node.b.p = node;
          return setParents(node.b);
        }
      };
      setParents(json);
      json.p = null;
      return new OMNode(json);
    };

    function OMNode(tree) {
      this.tree = tree;
      this.hasDescendantSatisfying = __bind(this.hasDescendantSatisfying, this);
      this.descendantsSatisfying = __bind(this.descendantsSatisfying, this);
      this.childrenSatisfying = __bind(this.childrenSatisfying, this);
      this.replaceFree = __bind(this.replaceFree, this);
      this.isFreeToReplace = __bind(this.isFreeToReplace, this);
      this.occursFree = __bind(this.occursFree, this);
      this.isFree = __bind(this.isFree, this);
      this.freeVariables = __bind(this.freeVariables, this);
      this.setAttribute = __bind(this.setAttribute, this);
      this.removeAttribute = __bind(this.removeAttribute, this);
      this.getAttribute = __bind(this.getAttribute, this);
      this.replaceWith = __bind(this.replaceWith, this);
      this.remove = __bind(this.remove, this);
      this.index = __bind(this.index, this);
      this.address = __bind(this.address, this);
      this.findChild = __bind(this.findChild, this);
      this.findInParent = __bind(this.findInParent, this);
      this.simpleEncode = __bind(this.simpleEncode, this);
      this.copy = __bind(this.copy, this);
      this.sameObjectAs = __bind(this.sameObjectAs, this);
      this.equals = __bind(this.equals, this);
      this.encode = __bind(this.encode, this);
      Object.defineProperty(this, 'parent', {
        get: function() {
          if (this.tree.p) {
            return new OMNode(this.tree.p);
          } else {
            return void 0;
          }
        }
      });
      Object.defineProperty(this, 'type', {
        get: function() {
          return this.tree.t;
        }
      });
      Object.defineProperty(this, 'value', {
        get: function() {
          if (this.tree.t !== 'bi') {
            return this.tree.v;
          } else {
            return void 0;
          }
        }
      });
      Object.defineProperty(this, 'name', {
        get: function() {
          return this.tree.n;
        }
      });
      Object.defineProperty(this, 'cd', {
        get: function() {
          return this.tree.cd;
        }
      });
      Object.defineProperty(this, 'uri', {
        get: function() {
          return this.tree.uri;
        }
      });
      Object.defineProperty(this, 'symbol', {
        get: function() {
          if (this.tree.s) {
            return new OMNode(this.tree.s);
          } else {
            return void 0;
          }
        }
      });
      Object.defineProperty(this, 'body', {
        get: function() {
          if (this.tree.b) {
            return new OMNode(this.tree.b);
          } else {
            return void 0;
          }
        }
      });
      Object.defineProperty(this, 'children', {
        get: function() {
          var child, _i, _len, _ref1, _ref2, _results;
          _ref2 = (_ref1 = this.tree.c) != null ? _ref1 : [];
          _results = [];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            child = _ref2[_i];
            _results.push(new OMNode(child));
          }
          return _results;
        }
      });
      Object.defineProperty(this, 'variables', {
        get: function() {
          var variable, _i, _len, _ref1, _results;
          if (this.tree.t === 'bi') {
            _ref1 = this.tree.v;
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              variable = _ref1[_i];
              _results.push(new OMNode(variable));
            }
            return _results;
          } else {
            return [];
          }
        }
      });
    }

    OMNode.prototype.encode = function() {
      return JSON.stringify(this.tree, function(k, v) {
        if (k === 'p') {
          return void 0;
        } else {
          return v;
        }
      });
    };

    OMNode.prototype.equals = function(other, attributes) {
      var recur;
      if (attributes == null) {
        attributes = true;
      }
      recur = function(a, b) {
        var element, index, key, value, _i, _len;
        if (a === b) {
          return true;
        }
        if (a instanceof Array || a instanceof Uint8Array) {
          if ((a instanceof Array) && (!(b instanceof Array))) {
            return false;
          }
          if ((a instanceof Uint8Array) && (!(b instanceof Uint8Array))) {
            return false;
          }
          if (a.length !== b.length) {
            return false;
          }
          for (index = _i = 0, _len = a.length; _i < _len; index = ++_i) {
            element = a[index];
            if (!recur(element, b[index])) {
              return false;
            }
          }
          return true;
        }
        if (!(a instanceof Object)) {
          return false;
        }
        if (!(b instanceof Object)) {
          return false;
        }
        for (key in a) {
          if (!__hasProp.call(a, key)) continue;
          value = a[key];
          if (key === 'p' || !attributes && key === 'a') {
            continue;
          }
          if (!b.hasOwnProperty(key)) {
            return false;
          }
          if (!recur(value, b[key])) {
            return false;
          }
        }
        for (key in b) {
          if (!__hasProp.call(b, key)) continue;
          value = b[key];
          if (key === 'p' || !attributes && key === 'a') {
            continue;
          }
          if (!a.hasOwnProperty(key)) {
            return false;
          }
        }
        return true;
      };
      return recur(this.tree, other.tree);
    };

    OMNode.prototype.sameObjectAs = function(other) {
      return this.tree === (other != null ? other.tree : void 0);
    };

    OMNode.prototype.copy = function() {
      var recur;
      recur = function(tree) {
        var child, key, result, value, variable, _ref1, _ref2;
        result = (function() {
          switch (tree.t) {
            case 'i':
            case 'f':
            case 'st':
              return {
                t: tree.t,
                v: tree.v
              };
            case 'v':
              return {
                t: 'v',
                n: tree.n
              };
            case 'sy':
              result = {
                t: 'sy',
                n: tree.n,
                cd: tree.cd
              };
              if (tree.hasOwnProperty('uri')) {
                result.uri = tree.uri;
              }
              return result;
            case 'ba':
              return {
                t: 'ba',
                v: new Uint8Array(tree.v)
              };
            case 'e':
            case 'a':
              result = {
                t: tree.t,
                c: (function() {
                  var _i, _len, _ref1, _results;
                  _ref1 = tree.c;
                  _results = [];
                  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                    child = _ref1[_i];
                    _results.push(recur(child));
                  }
                  return _results;
                })()
              };
              if (tree.t === 'e') {
                result.s = recur(tree.s);
              }
              return result;
            case 'bi':
              return {
                t: 'bi',
                s: recur(tree.s),
                v: (function() {
                  var _i, _len, _ref1, _results;
                  _ref1 = tree.v;
                  _results = [];
                  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                    variable = _ref1[_i];
                    _results.push(recur(variable));
                  }
                  return _results;
                })(),
                b: recur(tree.b)
              };
          }
        })();
        _ref2 = (_ref1 = tree.a) != null ? _ref1 : {};
        for (key in _ref2) {
          if (!__hasProp.call(_ref2, key)) continue;
          value = _ref2[key];
          (result.a != null ? result.a : result.a = {})[key] = recur(value);
        }
        return result;
      };
      return OMNode.decode(recur(this.tree));
    };

    OMNode.integer = function(value) {
      return OMNode.decode({
        t: 'i',
        v: value
      });
    };

    OMNode.float = function(value) {
      return OMNode.decode({
        t: 'f',
        v: value
      });
    };

    OMNode.string = function(value) {
      return OMNode.decode({
        t: 'st',
        v: value
      });
    };

    OMNode.bytearray = function(value) {
      return OMNode.decode({
        t: 'ba',
        v: value
      });
    };

    OMNode.symbol = function(name, cd, uri) {
      return OMNode.decode(uri != null ? {
        t: 'sy',
        n: name,
        cd: cd,
        uri: uri
      } : {
        t: 'sy',
        n: name,
        cd: cd
      });
    };

    OMNode.variable = function(name) {
      return OMNode.decode({
        t: 'v',
        n: name
      });
    };

    OMNode.application = function() {
      var arg, args, result, _i, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      result = {
        t: 'a',
        c: []
      };
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        result.c.push(arg instanceof OMNode ? JSON.parse(arg.encode()) : arg);
      }
      return OMNode.decode(result);
    };

    OMNode.attribution = function() {
      var attrs, key, node, value;
      node = arguments[0], attrs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!(node instanceof Object)) {
        return 'Invalid first parameter to attribution';
      }
      if (attrs.length % 2 !== 0) {
        return 'Incomplete key-value pair in attribution';
      }
      if (node instanceof OMNode) {
        node = JSON.parse(node.encode());
      }
      while (attrs.length > 0) {
        if (node.a == null) {
          node.a = {};
        }
        key = attrs.shift();
        key = key instanceof OMNode ? key.encode() : JSON.stringify(key);
        value = attrs.shift();
        node.a[key] = value instanceof OMNode ? JSON.parse(value.encode()) : value;
      }
      return OMNode.decode(node);
    };

    OMNode.binding = function() {
      var body, head, result, variable, vars, _i, _j, _len;
      head = arguments[0], vars = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), body = arguments[_i++];
      if (!(head instanceof Object)) {
        return 'Invalid first parameter to binding';
      }
      if (!(body instanceof Object)) {
        return 'Invalid last parameter to binding';
      }
      result = {
        t: 'bi',
        s: head instanceof OMNode ? JSON.parse(head.encode()) : head,
        v: [],
        b: body instanceof OMNode ? JSON.parse(body.encode()) : body
      };
      for (_j = 0, _len = vars.length; _j < _len; _j++) {
        variable = vars[_j];
        result.v.push(variable instanceof OMNode ? JSON.parse(variable.encode()) : variable);
      }
      return OMNode.decode(result);
    };

    OMNode.error = function() {
      var head, other, others, result, _i, _len;
      head = arguments[0], others = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!(head instanceof Object)) {
        return 'Invalid first parameter to binding';
      }
      result = {
        t: 'e',
        s: head instanceof OMNode ? JSON.parse(head.encode()) : head,
        c: []
      };
      for (_i = 0, _len = others.length; _i < _len; _i++) {
        other = others[_i];
        result.c.push(other instanceof OMNode ? JSON.parse(other.encode()) : other);
      }
      return OMNode.decode(result);
    };

    tokenTypes = [
      {
        name: 'symbol',
        pattern: /[:A-Za-z_][:A-Za-z_0-9-]*\.[:A-Za-z_][:A-Za-z_0-9-]*/
      }, {
        name: 'variable',
        pattern: /[:A-Za-z_][:A-Za-z_0-9-]*/
      }, {
        name: 'float',
        pattern: /[+-]?(?:[0-9]+\.[0-9]*|[0-9]*\.[0-9]+)/
      }, {
        name: 'integer',
        pattern: /[+-]?[0-9]+/
      }, {
        name: 'string',
        pattern: /"(?:[^"\\]|\\"|\\\\)*"|'(?:[^'\\]|\\'|\\\\)*'/
      }, {
        name: 'comma',
        pattern: /,/
      }, {
        name: 'openParen',
        pattern: /\(/
      }, {
        name: 'closeParen',
        pattern: /\)/
      }, {
        name: 'openBracket',
        pattern: /\[/
      }, {
        name: 'closeBracket',
        pattern: /\]/
      }
    ];

    OMNode.simpleDecode = function(input) {
      var children, expr, halves, i, index, int, match, next, originally, stack, state, tokenType, tokens, type, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref1;
      if (typeof input !== 'string') {
        return 'Input was not a string';
      }
      tokens = [];
      while (input.length > 0) {
        originally = input.length;
        for (_i = 0, _len = tokenTypes.length; _i < _len; _i++) {
          tokenType = tokenTypes[_i];
          match = tokenType.pattern.exec(input);
          if ((match != null) && match.index === 0) {
            tokens.push({
              type: tokenType.name,
              text: match[0]
            });
            input = input.slice(match[0].length);
          }
        }
        if (input.length === originally) {
          return "Could not understand from here: " + input.slice(0, 11);
        }
      }
      state = 'expression about to start';
      stack = [];
      while (tokens.length > 0) {
        next = tokens.shift();
        switch (state) {
          case 'expression about to start':
            switch (next.type) {
              case 'symbol':
                halves = next.text.split('.');
                stack.unshift({
                  node: OMNode.symbol(halves[1], halves[0])
                });
                break;
              case 'variable':
                stack.unshift({
                  node: OMNode.variable(next.text)
                });
                break;
              case 'integer':
                int = parseInt(next.text);
                if (/\./.test(int)) {
                  int = next.text;
                }
                stack.unshift({
                  node: OMNode.integer(int)
                });
                break;
              case 'float':
                stack.unshift({
                  node: OMNode.float(parseFloat(next.text))
                });
                break;
              case 'string':
                type = next.text[0];
                next = next.text.slice(1, -1).replace(RegExp("\\\\" + type, 'g'), type);
                stack.unshift({
                  node: OMNode.string(next)
                });
                break;
              default:
                return "Unexpected " + next.text;
            }
            state = 'expression ended';
            break;
          case 'expression ended':
            switch (next.type) {
              case 'comma':
                state = 'expression about to start';
                break;
              case 'openParen':
                stack[0].head = 'application';
                if ((tokens != null ? (_ref1 = tokens[0]) != null ? _ref1.type : void 0 : void 0) === 'closeParen') {
                  tokens.shift();
                  stack.unshift({
                    node: OMNode.application(stack.shift().node)
                  });
                  state = 'expression ended';
                } else {
                  state = 'expression about to start';
                }
                break;
              case 'openBracket':
                stack[0].head = 'binding';
                state = 'expression about to start';
                break;
              case 'closeParen':
                for (index = _j = 0, _len1 = stack.length; _j < _len1; index = ++_j) {
                  expr = stack[index];
                  if (expr.head === 'application') {
                    break;
                  }
                  if (expr.head === 'binding') {
                    return "Mismatch: [ closed by )";
                  }
                }
                if (index === stack.length) {
                  return "Unexpected )";
                }
                children = [];
                for (i = _k = 0; 0 <= index ? _k <= index : _k >= index; i = 0 <= index ? ++_k : --_k) {
                  children.unshift(stack.shift().node);
                }
                stack.unshift({
                  node: OMNode.application.apply(null, children)
                });
                break;
              case 'closeBracket':
                for (index = _l = 0, _len2 = stack.length; _l < _len2; index = ++_l) {
                  expr = stack[index];
                  if (expr.head === 'binding') {
                    break;
                  }
                  if (expr.head === 'application') {
                    return "Mismatch: ( closed by ]";
                  }
                }
                if (index === stack.length) {
                  return "Unexpected ]";
                }
                children = [];
                for (i = _m = 0; 0 <= index ? _m <= index : _m >= index; i = 0 <= index ? ++_m : --_m) {
                  children.unshift(stack.shift().node);
                }
                stack.unshift({
                  node: OMNode.binding.apply(null, children)
                });
                break;
              default:
                return "Unexpected " + next.text;
            }
        }
        if (typeof (stack != null ? stack[0].node : void 0) === 'string') {
          return stack[0].node;
        }
      }
      if (stack.length > 1) {
        return "Unexpected end of input";
      } else {
        return stack[0].node;
      }
    };

    OMNode.prototype.simpleEncode = function() {
      var recur;
      recur = function(tree) {
        var body, c, children, head, v, variables;
        switch (tree != null ? tree.t : void 0) {
          case 'i':
          case 'f':
            return "" + tree.v;
          case 'v':
            return tree.n;
          case 'st':
            return "'" + (tree.v.replace(/'/g, '\\\'')) + "'";
          case 'sy':
            return "" + tree.cd + "." + tree.n;
          case 'ba':
            return "'byte array'";
          case 'e':
            return "'error'";
          case 'a':
            children = (function() {
              var _i, _len, _ref1, _results;
              _ref1 = tree.c;
              _results = [];
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                c = _ref1[_i];
                _results.push(recur(c));
              }
              return _results;
            })();
            head = children.shift();
            return "" + head + "(" + (children.join(',')) + ")";
          case 'bi':
            variables = (function() {
              var _i, _len, _ref1, _results;
              _ref1 = tree.v;
              _results = [];
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                v = _ref1[_i];
                _results.push(recur(v));
              }
              return _results;
            })();
            head = recur(tree.s);
            body = recur(tree.b);
            return "" + head + "[" + (variables.join(',')) + "," + body + "]";
          default:
            return "Error: Invalid OpenMath type " + (tree != null ? tree.t : void 0);
        }
      };
      return recur(this.tree);
    };

    OMNode.prototype.findInParent = function() {
      var child, index, key, value, variable, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4;
      if (!this.parent) {
        return void 0;
      }
      _ref1 = this.parent.children;
      for (index = _i = 0, _len = _ref1.length; _i < _len; index = ++_i) {
        child = _ref1[index];
        if (this.sameObjectAs(child)) {
          return "c" + index;
        }
      }
      if (this.type === 'v') {
        _ref2 = this.parent.variables;
        for (index = _j = 0, _len1 = _ref2.length; _j < _len1; index = ++_j) {
          variable = _ref2[index];
          if (this.sameObjectAs(variable)) {
            return "v" + index;
          }
        }
      }
      if (this.sameObjectAs(this.parent.symbol)) {
        return 's';
      }
      if (this.sameObjectAs(this.parent.body)) {
        return 'b';
      }
      _ref4 = (_ref3 = this.parent.tree.a) != null ? _ref3 : {};
      for (key in _ref4) {
        if (!__hasProp.call(_ref4, key)) continue;
        value = _ref4[key];
        if (this.tree === value) {
          return key;
        }
      }
      return void 0;
    };

    OMNode.prototype.findChild = function(indexInParent) {
      switch (indexInParent[0]) {
        case 'c':
          return this.children[parseInt(indexInParent.slice(1))];
        case 'v':
          return this.variables[parseInt(indexInParent.slice(1))];
        case 's':
          return this.symbol;
        case 'b':
          return this.body;
        case '{':
          return this.getAttribute(OMNode.decode(indexInParent));
      }
    };

    OMNode.prototype.address = function(inThis) {
      if (!this.parent || this.sameObjectAs(inThis)) {
        return [];
      }
      return this.parent.address(inThis).concat([this.findInParent()]);
    };

    OMNode.prototype.index = function(address) {
      var _ref1;
      if (!(address instanceof Array)) {
        return void 0;
      }
      if (address.length === 0) {
        return this;
      }
      return (_ref1 = this.findChild(address[0])) != null ? _ref1.index(address.slice(1)) : void 0;
    };

    OMNode.prototype.remove = function() {
      var index;
      if (!(index = this.findInParent())) {
        return;
      }
      switch (index[0]) {
        case 'c':
          this.parent.tree.c.splice(parseInt(index.slice(1)), 1);
          break;
        case 'v':
          this.parent.tree.v.splice(parseInt(index.slice(1)), 1);
          break;
        case 'b':
          delete this.parent.tree.b;
          break;
        case 's':
          delete this.parent.tree.s;
          break;
        case '{':
          delete this.parent.tree.a[index];
      }
      return delete this.tree.p;
    };

    OMNode.prototype.replaceWith = function(other) {
      var index, original;
      if (this.sameObjectAs(other)) {
        return;
      }
      index = this.findInParent();
      if (index === 's' && other.type !== 'sy') {
        return;
      }
      if ((index != null ? index[0] : void 0) === 'v' && other.type !== 'v') {
        return;
      }
      other.remove();
      original = new OMNode(this.tree);
      this.tree = other.tree;
      switch (index != null ? index[0] : void 0) {
        case 'c':
          original.parent.tree.c[parseInt(index.slice(1))] = this.tree;
          break;
        case 'v':
          original.parent.tree.v[parseInt(index.slice(1))] = this.tree;
          break;
        case 'b':
          original.parent.tree.b = this.tree;
          break;
        case 's':
          original.parent.tree.s = this.tree;
          break;
        case '{':
          original.parent.tree.a[index] = this.tree;
          break;
        default:
          return;
      }
      this.tree.p = original.tree.p;
      delete original.tree.p;
      return original;
    };

    OMNode.prototype.getAttribute = function(keySymbol) {
      var cdRE, key, nameRE, value, _ref1, _ref2;
      if (!(keySymbol instanceof OMNode)) {
        return void 0;
      }
      if (keySymbol.type !== 'sy') {
        return void 0;
      }
      nameRE = RegExp("\"n\":\"" + keySymbol.name + "\"");
      cdRE = RegExp("\"cd\":\"" + keySymbol.cd + "\"");
      _ref2 = (_ref1 = this.tree.a) != null ? _ref1 : {};
      for (key in _ref2) {
        if (!__hasProp.call(_ref2, key)) continue;
        value = _ref2[key];
        if (nameRE.test(key) && cdRE.test(key)) {
          return new OMNode(value);
        }
      }
    };

    OMNode.prototype.removeAttribute = function(keySymbol) {
      var cdRE, key, nameRE, value, _ref1, _ref2;
      if (!(keySymbol instanceof OMNode)) {
        return;
      }
      if (keySymbol.type !== 'sy') {
        return;
      }
      nameRE = RegExp("\"n\":\"" + keySymbol.name + "\"");
      cdRE = RegExp("\"cd\":\"" + keySymbol.cd + "\"");
      _ref2 = (_ref1 = this.tree.a) != null ? _ref1 : {};
      for (key in _ref2) {
        if (!__hasProp.call(_ref2, key)) continue;
        value = _ref2[key];
        if (nameRE.test(key) && cdRE.test(key)) {
          (new OMNode(value)).remove();
          delete this.tree.a[key];
          return;
        }
      }
    };

    OMNode.prototype.setAttribute = function(keySymbol, newValue) {
      var _base;
      if (!(keySymbol instanceof OMNode) || !(newValue instanceof OMNode)) {
        return;
      }
      if (keySymbol.type !== 'sy') {
        return;
      }
      this.removeAttribute(keySymbol);
      newValue.remove();
      ((_base = this.tree).a != null ? _base.a : _base.a = {})[keySymbol.encode()] = newValue.tree;
      return newValue.tree.p = this.tree;
    };

    OMNode.prototype.freeVariables = function() {
      var boundByThis, child, free, result, v, varname, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _results;
      switch (this.type) {
        case 'v':
          return [this.name];
        case 'a':
        case 'c':
          result = [];
          _ref1 = this.children;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            child = _ref1[_i];
            _ref2 = child.freeVariables();
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              free = _ref2[_j];
              if (__indexOf.call(result, free) < 0) {
                result.push(free);
              }
            }
          }
          return result;
        case 'bi':
          boundByThis = (function() {
            var _k, _len2, _ref3, _results;
            _ref3 = this.variables;
            _results = [];
            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
              v = _ref3[_k];
              _results.push(v.name);
            }
            return _results;
          }).call(this);
          _ref3 = this.body.freeVariables();
          _results = [];
          for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
            varname = _ref3[_k];
            if (__indexOf.call(boundByThis, varname) < 0) {
              _results.push(varname);
            }
          }
          return _results;
        default:
          return [];
      }
    };

    OMNode.prototype.isFree = function(inThis) {
      var boundHere, freeVariables, v, variable, walk, _i, _len;
      freeVariables = this.freeVariables();
      walk = this;
      while (walk) {
        if (walk.type === 'bi') {
          boundHere = (function() {
            var _i, _len, _ref1, _results;
            _ref1 = walk.variables;
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              v = _ref1[_i];
              _results.push(v.name);
            }
            return _results;
          })();
          for (_i = 0, _len = freeVariables.length; _i < _len; _i++) {
            variable = freeVariables[_i];
            if (__indexOf.call(boundHere, variable) >= 0) {
              return false;
            }
          }
        }
        if (walk.sameObjectAs(inThis)) {
          break;
        }
        walk = walk.parent;
      }
      return true;
    };

    OMNode.prototype.occursFree = function(findThis) {
      var child, _i, _len, _ref1, _ref2, _ref3;
      if (this.equals(findThis) && this.isFree()) {
        return true;
      }
      if ((_ref1 = this.symbol) != null ? _ref1.equals(findThis) : void 0) {
        return true;
      }
      if ((_ref2 = this.body) != null ? _ref2.occursFree(findThis) : void 0) {
        return true;
      }
      _ref3 = this.children;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        child = _ref3[_i];
        if (child.occursFree(findThis)) {
          return true;
        }
      }
      return false;
    };

    OMNode.prototype.isFreeToReplace = function(subtreeToReplace, inThis) {
      var context, result, saved;
      if (this.sameObjectAs(subtreeToReplace)) {
        return true;
      }
      if (subtreeToReplace.parent == null) {
        return true;
      }
      context = subtreeToReplace;
      while (context.parent) {
        context = context.parent;
      }
      saved = new OMNode(subtreeToReplace.tree);
      if (!subtreeToReplace.replaceWith(this.copy())) {
        return false;
      }
      result = subtreeToReplace.isFree(inThis);
      subtreeToReplace.replaceWith(saved);
      return result;
    };

    OMNode.prototype.replaceFree = function(original, replacement, inThis) {
      var child, save, variable, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _results;
      if (inThis == null) {
        inThis = this;
      }
      if (this.isFree(inThis) && this.equals(original)) {
        save = new OMNode(this.tree);
        this.replaceWith(replacement.copy());
        if (!this.isFree(inThis)) {
          this.replaceWith(save);
        }
        return;
      }
      if ((_ref1 = this.symbol) != null) {
        _ref1.replaceFree(original, replacement, inThis);
      }
      if ((_ref2 = this.body) != null) {
        _ref2.replaceFree(original, replacement, inThis);
      }
      _ref3 = this.variables;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        variable = _ref3[_i];
        variable.replaceFree(original, replacement, inThis);
      }
      _ref4 = this.children;
      _results = [];
      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
        child = _ref4[_j];
        _results.push(child.replaceFree(original, replacement, inThis));
      }
      return _results;
    };

    OMNode.prototype.childrenSatisfying = function(filter) {
      var child, children, _i, _len, _results;
      if (filter == null) {
        filter = function() {
          return true;
        };
      }
      children = this.children;
      if (this.symbol != null) {
        children.push(this.symbol);
      }
      children = children.concat(this.variables);
      if (this.body != null) {
        children.push(this.body);
      }
      _results = [];
      for (_i = 0, _len = children.length; _i < _len; _i++) {
        child = children[_i];
        if (filter(child)) {
          _results.push(child);
        }
      }
      return _results;
    };

    OMNode.prototype.descendantsSatisfying = function(filter) {
      var child, results, _i, _len, _ref1;
      if (filter == null) {
        filter = function() {
          return true;
        };
      }
      results = [];
      if (filter(this)) {
        results.push(this);
      }
      _ref1 = this.childrenSatisfying();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        child = _ref1[_i];
        results = results.concat(child.descendantsSatisfying(filter));
      }
      return results;
    };

    OMNode.prototype.hasDescendantSatisfying = function(filter) {
      var child, _i, _len, _ref1;
      if (filter == null) {
        filter = function() {
          return true;
        };
      }
      if (filter(this)) {
        return true;
      }
      _ref1 = this.childrenSatisfying();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        child = _ref1[_i];
        if (child.hasDescendantSatisfying(filter)) {
          return true;
        }
      }
      return false;
    };

    return OMNode;

  })();

  OM.int = OM.integer;

  OM.flo = OM.float;

  OM.str = OM.string;

  OM.byt = OM.bytearray;

  OM.sym = OM.symbol;

  OM["var"] = OM.variable;

  OM.app = OM.application;

  OM.att = OM.attribution;

  OM.bin = OM.binding;

  OM.err = OM.error;

  OM.simple = OM.simpleDecode;

  if (exports == null) {
    exports = (_ref1 = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref1 : window;
  }

  if (typeof require !== "undefined" && require !== null) {
    _ref2 = require('./openmath.duo'), OM = _ref2.OM, OMNode = _ref2.OMNode;
  }

  metavariableSymbol = OM.symbol('metavariable', 'lurch');

  trueValue = OM.string('true');

  exports.setMetavariable = setMetavariable = function(variable) {
    var _ref3;
    if (!(variable instanceof OMNode) || ((_ref3 = variable.type) !== 'v' && _ref3 !== 'sy')) {
      return;
    }
    return variable.setAttribute(metavariableSymbol, trueValue.copy());
  };

  exports.clearMetavariable = clearMetavariable = function(metavariable) {
    return metavariable.removeAttribute(metavariableSymbol);
  };

  exports.isMetavariable = isMetavariable = function(variable) {
    var _ref3, _ref4;
    return variable instanceof OMNode && ((_ref3 = variable.type) === 'v' || _ref3 === 'sy') && ((_ref4 = variable.getAttribute(metavariableSymbol)) != null ? _ref4.equals(trueValue) : void 0);
  };

  exports.Match = Match = (function() {
    function _Class() {
      this.toString = __bind(this.toString, this);
      this.copy = __bind(this.copy, this);
      this.complete = __bind(this.complete, this);
      this.storeTopmostPair = __bind(this.storeTopmostPair, this);
      this.getSubstitutionNode = __bind(this.getSubstitutionNode, this);
      this.getSubstitutionRight = __bind(this.getSubstitutionRight, this);
      this.getSubstitutionLeft = __bind(this.getSubstitutionLeft, this);
      this.getSubstitutionRoot = __bind(this.getSubstitutionRoot, this);
      this.getSubstitutionRequired = __bind(this.getSubstitutionRequired, this);
      this.hasSubstitution = __bind(this.hasSubstitution, this);
      this.clearSubstitution = __bind(this.clearSubstitution, this);
      this.setSubstitution = __bind(this.setSubstitution, this);
      this.applyTo = __bind(this.applyTo, this);
      this.keys = __bind(this.keys, this);
      this.has = __bind(this.has, this);
      this.clear = __bind(this.clear, this);
      this.get = __bind(this.get, this);
      this.set = __bind(this.set, this);
      this.map = {};
    }

    _Class.prototype.set = function(varOrSym, expr) {
      var vname;
      if (varOrSym.simpleEncode != null) {
        varOrSym = varOrSym.simpleEncode();
      }
      this.map[varOrSym] = expr.copy();
      if (this.substitution != null) {
        return this.substitution.unavailable = (function() {
          var _i, _len, _ref3, _results;
          _ref3 = this.substitution.unavailable;
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            vname = _ref3[_i];
            if (vname !== varOrSym) {
              _results.push(vname);
            }
          }
          return _results;
        }).call(this);
      }
    };

    _Class.prototype.get = function(varOrSym) {
      var _ref3;
      return this.map[(_ref3 = typeof varOrSym.simpleEncode === "function" ? varOrSym.simpleEncode() : void 0) != null ? _ref3 : varOrSym];
    };

    _Class.prototype.clear = function(varOrSym) {
      var _ref3, _ref4, _ref5;
      varOrSym = (_ref3 = typeof varOrSym.simpleEncode === "function" ? varOrSym.simpleEncode() : void 0) != null ? _ref3 : varOrSym;
      delete this.map[varOrSym];
      if (__indexOf.call((_ref4 = (_ref5 = this.substitution) != null ? _ref5.metavariables : void 0) != null ? _ref4 : [], varOrSym) >= 0) {
        if (__indexOf.call(this.substitution.unavailable, varOrSym) < 0) {
          return this.substitution.unavailable.push(varOrSym);
        }
      }
    };

    _Class.prototype.has = function(varOrSym) {
      var _ref3;
      return this.map.hasOwnProperty((_ref3 = typeof varOrSym.simpleEncode === "function" ? varOrSym.simpleEncode() : void 0) != null ? _ref3 : varOrSym);
    };

    _Class.prototype.keys = function() {
      return Object.keys(this.map);
    };

    _Class.prototype.applyTo = function(pattern) {
      var metavariable, result, _i, _len, _ref3;
      result = pattern.copy();
      _ref3 = result.descendantsSatisfying(isMetavariable);
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        metavariable = _ref3[_i];
        if (this.has(metavariable)) {
          metavariable.replaceWith(this.get(metavariable).copy());
        }
      }
      return result;
    };

    _Class.requiredSubstitution = OM.symbol('replaceAll', 'lurch');

    _Class.optionalSubstitution = OM.symbol('replaceSome', 'lurch');

    _Class.prototype.setSubstitution = function(substitution) {
      var leftMetavariables, rightMetavariables, v, vname, _i, _j, _len, _len1, _ref3, _ref4;
      this.substitution = {
        original: substitution,
        required: substitution.children[0].equals(Match.requiredSubstitution),
        root: substitution.children[1],
        leftHandSide: substitution.children[2],
        rightHandSide: substitution.children[3],
        metavariables: []
      };
      leftMetavariables = this.substitution.leftHandSide.descendantsSatisfying(isMetavariable);
      for (_i = 0, _len = leftMetavariables.length; _i < _len; _i++) {
        v = leftMetavariables[_i];
        if (_ref3 = v.name, __indexOf.call(this.substitution.metavariables, _ref3) < 0) {
          this.substitution.metavariables.push(v.name);
        }
      }
      rightMetavariables = this.substitution.rightHandSide.descendantsSatisfying(isMetavariable);
      for (_j = 0, _len1 = rightMetavariables.length; _j < _len1; _j++) {
        v = rightMetavariables[_j];
        if (_ref4 = v.name, __indexOf.call(this.substitution.metavariables, _ref4) < 0) {
          this.substitution.metavariables.push(v.name);
        }
      }
      return this.substitution.unavailable = (function() {
        var _k, _len2, _ref5, _results;
        _ref5 = this.substitution.metavariables;
        _results = [];
        for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
          vname = _ref5[_k];
          if (!this.map.hasOwnProperty(vname)) {
            _results.push(vname);
          }
        }
        return _results;
      }).call(this);
    };

    _Class.prototype.clearSubstitution = function() {
      return delete this.substitution;
    };

    _Class.prototype.hasSubstitution = function() {
      return this.substitution != null;
    };

    _Class.prototype.getSubstitutionRequired = function() {
      var _ref3;
      return (_ref3 = this.substitution) != null ? _ref3.required : void 0;
    };

    _Class.prototype.getSubstitutionRoot = function() {
      var _ref3;
      return (_ref3 = this.substitution) != null ? _ref3.root : void 0;
    };

    _Class.prototype.getSubstitutionLeft = function() {
      var _ref3;
      return (_ref3 = this.substitution) != null ? _ref3.leftHandSide : void 0;
    };

    _Class.prototype.getSubstitutionRight = function() {
      var _ref3;
      return (_ref3 = this.substitution) != null ? _ref3.rightHandSide : void 0;
    };

    _Class.prototype.getSubstitutionNode = function() {
      var _ref3;
      return (_ref3 = this.substitution) != null ? _ref3.original : void 0;
    };

    _Class.prototype.storeTopmostPair = function(pattern, expression) {
      this.pattern = pattern;
      return this.expression = expression;
    };

    _Class.prototype.complete = function() {
      var integers, key, last, match, metavariable, metavariables, unused, unusedCheck, unusedRE, value, variable, _i, _j, _len, _len1, _ref3, _results;
      if (!((this.pattern != null) && (this.expression != null))) {
        return;
      }
      unusedRE = /^unused_([0-9]+)$/;
      unusedCheck = function(node) {
        return node.type === 'v' && unusedRE.test(node.name);
      };
      unused = this.pattern.descendantsSatisfying(unusedCheck).concat(this.expression.descendantsSatisfying(unusedCheck));
      _ref3 = this.map;
      for (key in _ref3) {
        if (!__hasProp.call(_ref3, key)) continue;
        value = _ref3[key];
        unused = unused.concat(value.descendantsSatisfying(unusedCheck));
      }
      integers = [0];
      for (_i = 0, _len = unused.length; _i < _len; _i++) {
        variable = unused[_i];
        match = unusedRE.exec(variable.name);
        integers.push(parseInt(match[1]));
      }
      integers = integers.sort(function(a, b) {
        return a - b;
      });
      last = integers[integers.length - 1];
      metavariables = this.pattern.descendantsSatisfying(isMetavariable);
      _results = [];
      for (_j = 0, _len1 = metavariables.length; _j < _len1; _j++) {
        metavariable = metavariables[_j];
        if (!this.has(metavariable)) {
          _results.push(this.set(metavariable, OM.variable("unused_" + (++last))));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    _Class.prototype.copy = function() {
      var key, result, value, _ref3;
      result = new Match;
      _ref3 = this.map;
      for (key in _ref3) {
        if (!__hasProp.call(_ref3, key)) continue;
        value = _ref3[key];
        result.map[key] = value.copy();
      }
      if (this.substitution != null) {
        result.substitution = {
          original: this.substitution.original,
          root: this.substitution.root,
          leftHandSide: this.substitution.leftHandSide,
          rightHandSide: this.substitution.rightHandSide,
          required: this.substitution.required,
          metavariables: this.substitution.metavariables.slice(0),
          unavailable: this.substitution.unavailable.slice(0)
        };
      }
      if (this.pattern != null) {
        result.pattern = this.pattern;
      }
      if (this.expression != null) {
        result.expression = this.expression;
      }
      return result;
    };

    _Class.prototype.toString = function() {
      var key, result, value, _ref3, _ref4;
      result = '{';
      _ref4 = (_ref3 = this.map) != null ? _ref3 : {};
      for (key in _ref4) {
        if (!__hasProp.call(_ref4, key)) continue;
        value = _ref4[key];
        if (result.length > 1) {
          result += ',';
        }
        result += "" + key + ":" + (value.simpleEncode());
      }
      result += '}';
      if (this.hasSubstitution()) {
        result += '[' + this.getSubstitutionLeft().simpleEncode() + (this.getSubstitutionRequired() ? '=' : '~') + this.getSubstitutionRight().simpleEncode() + ' in ' + this.getSubstitutionRoot().simpleEncode() + ']';
      }
      return result;
    };

    return _Class;

  })();

  matchDebuggingEnabled = false;

  mdebug = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (matchDebuggingEnabled) {
      return console.log.apply(console, args);
    }
  };

  exports.matches = matches = function(pattern, expression, soFar) {
    var d, descs, e, echild, echildren, einstantiated, existUnusedMetavars, expr, exprs, freeToReplace, fullRHS, index, isASubstitution, last, left, lhs, many, newRHS, newResults, outermost, p, pchild, pchildren, r, recur, recurResult, result, results, rhs, right, rinstantiated, root, sf, substIndex, substitution, substitutions, test, trySubs, tuple, _i, _j, _k, _l, _len, _len1, _len10, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _s;
    outermost = soFar == null;
    if (soFar == null) {
      soFar = new Match;
    }
    mdebug("" + (outermost ? '\n' : '') + "MATCHES:", (_ref3 = pattern != null ? typeof pattern.simpleEncode === "function" ? pattern.simpleEncode() : void 0 : void 0) != null ? _ref3 : pattern, (_ref4 = expression != null ? typeof expression.simpleEncode === "function" ? expression.simpleEncode() : void 0 : void 0) != null ? _ref4 : expression, "" + soFar);
    if (outermost) {
      soFar.storeTopmostPair(pattern, expression);
      substitutions = expression.descendantsSatisfying(function(x) {
        return x.type === 'a' && x.children.length === 4 && x.children[0].equals(Match.requiredSubstitution);
      });
      for (_i = 0, _len = substitutions.length; _i < _len; _i++) {
        substitution = substitutions[_i];
        left = substitution.children[2];
        right = substitution.children[3];
        substitution.replaceWith(substitution.children[1]);
        substitution.replaceFree(left, right);
      }
    }
    mdebug('  --pattern inside topmost pattern?', soFar.pattern.hasDescendantSatisfying(function(d) {
      return d.sameObjectAs(pattern);
    }));
    mdebug('  --expression inside topmost expression?', soFar.expression.hasDescendantSatisfying(function(d) {
      return d.sameObjectAs(expression);
    }));
    mdebug('  --pattern inside substitution root?', (_ref5 = soFar.getSubstitutionRoot()) != null ? _ref5.hasDescendantSatisfying(function(d) {
      return d.sameObjectAs(pattern);
    }) : void 0);
    trySubs = function() {
      var fullRHS, instantiated, lhsInThere, lhsLocation, match, pair, result, results, rhs, root, save, sub, walk1, walk2, _j, _k, _len1, _len2, _ref6, _ref7, _ref8;
      if (!soFar.hasSubstitution()) {
        return [];
      }
      mdebug('    match of', pattern.simpleEncode(), 'to', expression.simpleEncode(), 'failed; trying subs...', soFar.toString());
      save = soFar.getSubstitutionNode();
      root = soFar.getSubstitutionRoot();
      rhs = soFar.getSubstitutionRight();
      pair = OM.application;
      sub = pair(soFar.getSubstitutionLeft(), rhs);
      soFar.clearSubstitution();
      _ref6 = [pattern, expression, []], walk1 = _ref6[0], walk2 = _ref6[1], results = _ref6[2];
      while ((walk1 != null) && (walk2 != null)) {
        mdebug('    attempting subs at this level:', sub.simpleEncode(), pair(walk1, walk2).simpleEncode(), "" + soFar + "...");
        _ref7 = matches(sub, pair(walk1, walk2), soFar, false);
        for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
          match = _ref7[_j];
          mdebug('        checking this:', "" + match);
          lhsLocation = walk1.address(root);
          instantiated = match.applyTo(root);
          lhsInThere = instantiated.index(lhsLocation);
          fullRHS = match.applyTo(rhs);
          mdebug("        is " + (fullRHS != null ? typeof fullRHS.simpleEncode === "function" ? fullRHS.simpleEncode() : void 0 : void 0) + " free to replace " + (lhsInThere != null ? typeof lhsInThere.simpleEncode === "function" ? lhsInThere.simpleEncode() : void 0 : void 0) + " in " + (instantiated != null ? typeof instantiated.simpleEncode === "function" ? instantiated.simpleEncode() : void 0 : void 0) + "? " + (fullRHS.isFreeToReplace(lhsInThere, instantiated)));
          if (fullRHS.isFreeToReplace(lhsInThere, instantiated)) {
            results.push(match);
          }
        }
        if (walk1.sameObjectAs(root)) {
          break;
        }
        _ref8 = [walk1.parent, walk2.parent], walk1 = _ref8[0], walk2 = _ref8[1];
      }
      for (_k = 0, _len2 = results.length; _k < _len2; _k++) {
        result = results[_k];
        result.setSubstitution(save);
      }
      mdebug('    done attempting all subs; results:', (function() {
        var _l, _len3, _results;
        _results = [];
        for (_l = 0, _len3 = results.length; _l < _len3; _l++) {
          result = results[_l];
          _results.push("" + result);
        }
        return _results;
      })());
      return results;
    };
    if (pattern.type === 'a' && pattern.children.length === 4 && (pattern.children[0].equals(Match.requiredSubstitution) || pattern.children[0].equals(Match.optionalSubstitution))) {
      mdebug('    pattern is a substitution...');
      if (soFar.hasSubstitution()) {
        throw 'Only one substitution permitted in a pattern';
      }
      soFar.setSubstitution(pattern);
      rhs = soFar.getSubstitutionRight();
      results = matches(pattern.children[1], expression, soFar);
      newResults = [];
      for (_j = 0, _len1 = results.length; _j < _len1; _j++) {
        result = results[_j];
        mdebug('    checking substitution match', "" + result);
        if (pattern.children[0].equals(Match.optionalSubstitution)) {
          mdebug('        optional, so we approve it');
          result.clearSubstitution();
          newResults.push(result);
          continue;
        }
        lhs = result.getSubstitutionLeft();
        existUnusedMetavars = lhs.hasDescendantSatisfying(function(d) {
          return isMetavariable(d) && !result.has(d);
        });
        if (existUnusedMetavars) {
          mdebug('        approved because of unused metavars');
          result.clearSubstitution();
          newResults.push(result);
          continue;
        }
        root = result.getSubstitutionRoot();
        rinstantiated = result.applyTo(root);
        lhs = result.applyTo(lhs);
        descs = rinstantiated.descendantsSatisfying(function(d) {
          return d.equals(lhs) && !d.hasDescendantSatisfying(isMetavariable) && d.isFree(rinstantiated);
        });
        mdebug('        instantiated root:', rinstantiated.simpleEncode());
        mdebug('        instances of lhs:', (function() {
          var _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = descs.length; _k < _len2; _k++) {
            d = descs[_k];
            _results.push(d.address(pattern));
          }
          return _results;
        })());
        einstantiated = result.applyTo(expression);
        mdebug('        instantiated expression:', einstantiated.simpleEncode());
        exprs = (function() {
          var _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = descs.length; _k < _len2; _k++) {
            d = descs[_k];
            _results.push(einstantiated.index(d.address(rinstantiated)));
          }
          return _results;
        })();
        mdebug('        corresponding expression subtrees:', (function() {
          var _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = exprs.length; _k < _len2; _k++) {
            e = exprs[_k];
            _results.push(e.simpleEncode());
          }
          return _results;
        })());
        tuple = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return OM.application.apply(OM, [OM.string("tuple")].concat(__slice.call(args)));
        };
        fullRHS = result.applyTo(rhs);
        many = (function() {
          var _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = exprs.length; _k < _len2; _k++) {
            e = exprs[_k];
            _results.push(fullRHS);
          }
          return _results;
        })();
        mdebug('        will now recur on these tuples:');
        mdebug("        " + (tuple.apply(null, many).simpleEncode()));
        mdebug("        " + (tuple.apply(null, exprs).simpleEncode()));
        result.clearSubstitution();
        recur = matches(tuple.apply(null, many), tuple.apply(null, exprs), result);
        mdebug('        recursion on tuples complete; testing...');
        for (_k = 0, _len2 = recur.length; _k < _len2; _k++) {
          recurResult = recur[_k];
          mdebug('        testing:', "" + recurResult);
          newRHS = recurResult.applyTo(rhs);
          freeToReplace = true;
          for (_l = 0, _len3 = exprs.length; _l < _len3; _l++) {
            expr = exprs[_l];
            if (!newRHS.isFreeToReplace(expr, expression)) {
              freeToReplace = false;
              break;
            }
          }
          if (freeToReplace) {
            mdebug('        approved after extending:', "" + recurResult);
            newResults.push(recurResult);
          } else {
            mdebug('        rejected after extending:', "" + recurResult);
          }
        }
      }
      results = newResults;
      if (outermost) {
        for (_m = 0, _len4 = results.length; _m < _len4; _m++) {
          result = results[_m];
          result.complete();
        }
      }
      mdebug('    results have been completed:', (function() {
        var _len5, _n, _results;
        _results = [];
        for (_n = 0, _len5 = results.length; _n < _len5; _n++) {
          r = results[_n];
          _results.push("" + r);
        }
        return _results;
      })());
      mdebug('<--', (function() {
        var _len5, _n, _results;
        _results = [];
        for (_n = 0, _len5 = newResults.length; _n < _len5; _n++) {
          r = newResults[_n];
          _results.push("" + r);
        }
        return _results;
      })());
      return newResults;
    }
    if (isMetavariable(pattern)) {
      mdebug('    pattern is a metavariable');
      if (test = soFar.get(pattern)) {
        mdebug('    we use its already-determined value:');
        result = matches(test, expression, soFar);
        mdebug('<--', (function() {
          var _len5, _n, _results;
          _results = [];
          for (_n = 0, _len5 = result.length; _n < _len5; _n++) {
            r = result[_n];
            _results.push("" + r);
          }
          return _results;
        })());
        return result;
      }
      soFar.set(pattern, expression);
      mdebug('    stored new assignment', pattern.simpleEncode(), '=', expression.simpleEncode(), 'yielding', "" + soFar);
      results = [soFar];
      if (outermost) {
        for (_n = 0, _len5 = results.length; _n < _len5; _n++) {
          result = results[_n];
          result.complete();
        }
      }
      mdebug('    results have been completed:', (function() {
        var _len6, _o, _results;
        _results = [];
        for (_o = 0, _len6 = results.length; _o < _len6; _o++) {
          r = results[_o];
          _results.push("" + r);
        }
        return _results;
      })());
      mdebug('<--', (function() {
        var _len6, _o, _results;
        _results = [];
        for (_o = 0, _len6 = results.length; _o < _len6; _o++) {
          r = results[_o];
          _results.push("" + r);
        }
        return _results;
      })());
      return results;
    }
    mdebug('    comparing types...', pattern.type, expression.type);
    if (pattern.type !== expression.type) {
      result = trySubs();
      mdebug('<--', (function() {
        var _len6, _o, _results;
        _results = [];
        for (_o = 0, _len6 = result.length; _o < _len6; _o++) {
          r = result[_o];
          _results.push("" + r);
        }
        return _results;
      })());
      return result;
    }
    if ((_ref6 = pattern.type) === 'i' || _ref6 === 'f' || _ref6 === 'st' || _ref6 === 'ba' || _ref6 === 'sy' || _ref6 === 'v') {
      if (pattern.equals(expression, false)) {
        results = [soFar];
        if (outermost) {
          for (_o = 0, _len6 = results.length; _o < _len6; _o++) {
            result = results[_o];
            result.complete();
          }
        }
        mdebug('    results have been completed:', (function() {
          var _len7, _p, _results;
          _results = [];
          for (_p = 0, _len7 = results.length; _p < _len7; _p++) {
            r = results[_p];
            _results.push("" + r);
          }
          return _results;
        })());
      } else {
        results = trySubs();
      }
      mdebug('<--', (function() {
        var _len7, _p, _results;
        _results = [];
        for (_p = 0, _len7 = results.length; _p < _len7; _p++) {
          r = results[_p];
          _results.push("" + r);
        }
        return _results;
      })());
      return results;
    }
    pchildren = pattern.childrenSatisfying();
    mdebug('    pattern children:', (function() {
      var _len7, _p, _results;
      _results = [];
      for (_p = 0, _len7 = pchildren.length; _p < _len7; _p++) {
        p = pchildren[_p];
        _results.push(p.simpleEncode());
      }
      return _results;
    })());
    echildren = expression.childrenSatisfying();
    mdebug('    expression children:', (function() {
      var _len7, _p, _results;
      _results = [];
      for (_p = 0, _len7 = echildren.length; _p < _len7; _p++) {
        e = echildren[_p];
        _results.push(e.simpleEncode());
      }
      return _results;
    })());
    if (pchildren.length !== echildren.length) {
      result = trySubs();
      mdebug('<--', (function() {
        var _len7, _p, _results;
        _results = [];
        for (_p = 0, _len7 = result.length; _p < _len7; _p++) {
          r = result[_p];
          _results.push("" + r);
        }
        return _results;
      })());
      return result;
    }
    substIndex = -1;
    isASubstitution = function(node) {
      return node.type === 'a' && ((node.children[0].equals(Match.requiredSubstitution)) || (node.children[0].equals(Match.optionalSubstitution)));
    };
    for (index = _p = 0, _len7 = pchildren.length; _p < _len7; index = ++_p) {
      pchild = pchildren[index];
      if (pchild.descendantsSatisfying(isASubstitution).length > 0) {
        if (substIndex > -1) {
          throw 'Only one substitution permitted in a pattern';
        }
        substIndex = index;
      }
    }
    if (substIndex > -1) {
      last = pchildren.length - 1;
      _ref7 = [pchildren[last], pchildren[substIndex]], pchildren[substIndex] = _ref7[0], pchildren[last] = _ref7[1];
      _ref8 = [echildren[last], echildren[substIndex]], echildren[substIndex] = _ref8[0], echildren[last] = _ref8[1];
      mdebug('    reordered children to put substitution at end...');
      mdebug('    pattern children:', (function() {
        var _len8, _q, _results;
        _results = [];
        for (_q = 0, _len8 = pchildren.length; _q < _len8; _q++) {
          p = pchildren[_q];
          _results.push(p.simpleEncode());
        }
        return _results;
      })());
      mdebug('    expression children:', (function() {
        var _len8, _q, _results;
        _results = [];
        for (_q = 0, _len8 = echildren.length; _q < _len8; _q++) {
          e = echildren[_q];
          _results.push(e.simpleEncode());
        }
        return _results;
      })());
    }
    results = [soFar];
    for (index = _q = 0, _len8 = pchildren.length; _q < _len8; index = ++_q) {
      pchild = pchildren[index];
      echild = echildren[index];
      mdebug('    recurring at', index, 'on', pchild.simpleEncode(), 'and', echild.simpleEncode(), 'with results', (function() {
        var _len9, _r, _results;
        _results = [];
        for (_r = 0, _len9 = results.length; _r < _len9; _r++) {
          r = results[_r];
          _results.push("" + r);
        }
        return _results;
      })());
      newResults = [];
      for (_r = 0, _len9 = results.length; _r < _len9; _r++) {
        sf = results[_r];
        newResults = newResults.concat(matches(pchild, echild, sf.copy()));
      }
      if ((results = newResults).length === 0) {
        break;
      }
    }
    mdebug('    recursion complete; new result set:', (function() {
      var _len10, _results, _s;
      _results = [];
      for (_s = 0, _len10 = results.length; _s < _len10; _s++) {
        r = results[_s];
        _results.push("" + r);
      }
      return _results;
    })());
    if (outermost) {
      for (_s = 0, _len10 = results.length; _s < _len10; _s++) {
        result = results[_s];
        result.complete();
      }
    }
    mdebug('    results have been completed:', (function() {
      var _len11, _results, _t;
      _results = [];
      for (_t = 0, _len11 = results.length; _t < _len11; _t++) {
        r = results[_t];
        _results.push("" + r);
      }
      return _results;
    })());
    mdebug('<--', (function() {
      var _len11, _results, _t;
      _results = [];
      for (_t = 0, _len11 = results.length; _t < _len11; _t++) {
        r = results[_t];
        _results.push("" + r);
      }
      return _results;
    })());
    return results;
  };

  window.Background = {
    functions: {},
    registerFunction: function(name, func, globals, scripts) {
      if (globals == null) {
        globals = {};
      }
      if (scripts == null) {
        scripts = [];
      }
      return window.Background.functions[name] = {
        "function": func,
        globals: globals,
        scripts: scripts
      };
    },
    runningTasks: [],
    waitingTasks: [],
    addTask: function(funcName, inputGroups, callback) {
      var group, index, newTask, task, _i, _j, _len, _len1, _ref3, _ref4, _ref5, _ref6;
      newTask = {
        name: funcName,
        inputs: inputGroups,
        callback: callback,
        id: "" + funcName + "," + ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = inputGroups.length; _i < _len; _i++) {
            group = inputGroups[_i];
            _results.push(group.id());
          }
          return _results;
        })())
      };
      _ref3 = window.Background.waitingTasks;
      for (index = _i = 0, _len = _ref3.length; _i < _len; index = ++_i) {
        task = _ref3[index];
        if (task.id === newTask.id) {
          window.Background.waitingTasks.splice(index, 1);
          break;
        }
      }
      _ref4 = window.Background.runningTasks;
      for (index = _j = 0, _len1 = _ref4.length; _j < _len1; index = ++_j) {
        task = _ref4[index];
        if (task.id === newTask.id) {
          if ((_ref5 = task.runner) != null) {
            if ((_ref6 = _ref5.worker) != null) {
              if (typeof _ref6.terminate === "function") {
                _ref6.terminate();
              }
            }
          }
          window.Background.runningTasks.splice(index, 1);
          break;
        }
      }
      window.Background.waitingTasks.push(newTask);
      return window.Background.update();
    },
    available: {},
    update: function() {
      var B, data, runner, toStart, _ref3;
      B = window.Background;
      while (B.runningTasks.length < B.concurrency()) {
        if ((toStart = B.waitingTasks.shift()) == null) {
          return;
        }
        runner = (_ref3 = B.available[toStart.name]) != null ? _ref3.pop() : void 0;
        if (runner == null) {
          data = B.functions[toStart.name];
          if (data == null) {
            continue;
          }
          runner = new BackgroundFunction(data["function"], data.globals, data.scripts);
        }
        toStart.runner = runner;
        B.runningTasks.push(toStart);
        (function(toStart) {
          var cleanup;
          cleanup = function() {
            var index, _base, _name;
            index = B.runningTasks.indexOf(toStart);
            B.runningTasks.splice(index, 1);
            ((_base = B.available)[_name = toStart.name] != null ? _base[_name] : _base[_name] = []).push(runner);
            return window.Background.update();
          };
          return runner.call.apply(runner, toStart.inputs).sendTo(function(result) {
            cleanup();
            return typeof toStart.callback === "function" ? toStart.callback(result) : void 0;
          }).orElse(cleanup);
        })(toStart);
      }
    }
  };

  navigator.getHardwareConcurrency(function() {});

  window.Background.concurrency = function() {
    var _ref3;
    return Math.max(1, ((_ref3 = navigator.hardwareConcurrency) != null ? _ref3 : 1) - 1);
  };

  BackgroundFunction = (function() {
    function _Class(_function, globals, scripts) {
      var func, name, _ref3;
      this["function"] = _function;
      this.globals = globals;
      this.scripts = scripts;
      this.call = __bind(this.call, this);
      this.promise = {
        sendTo: (function(_this) {
          return function(callback) {
            _this.promise.resultCallback = callback;
            if (_this.promise.hasOwnProperty('result')) {
              _this.promise.resultCallback(_this.promise.result);
            }
            return _this.promise;
          };
        })(this),
        orElse: (function(_this) {
          return function(callback) {
            _this.promise.errorCallback = callback;
            if (_this.promise.hasOwnProperty('error')) {
              _this.promise.errorCallback(_this.promise.error);
            }
            return _this.promise;
          };
        })(this)
      };
      if (window.Worker) {
        this.worker = new window.Worker('worker.solo.js');
        this.worker.addEventListener('message', (function(_this) {
          return function(event) {
            var _ref3;
            _this.promise.result = event.data;
            return (_ref3 = _this.promise) != null ? typeof _ref3.resultCallback === "function" ? _ref3.resultCallback(event.data) : void 0 : void 0;
          };
        })(this), false);
        this.worker.addEventListener('error', (function(_this) {
          return function(event) {
            var _ref3;
            _this.promise.error = event;
            return (_ref3 = _this.promise) != null ? typeof _ref3.errorCallback === "function" ? _ref3.errorCallback(event) : void 0 : void 0;
          };
        })(this), false);
        this.worker.postMessage({
          setFunction: "" + this["function"]
        });
        _ref3 = this.globals;
        for (name in _ref3) {
          if (!__hasProp.call(_ref3, name)) continue;
          func = _ref3[name];
          this.globals[name] = "" + func;
        }
        this.worker.postMessage({
          install: this.globals
        });
        this.worker.postMessage({
          "import": this.scripts
        });
      }
    }

    _Class.prototype.call = function() {
      var args, group, groups, _i, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      delete this.promise.result;
      delete this.promise.resultCallback;
      delete this.promise.error;
      delete this.promise.errorCallback;
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        group = arguments[_i];
        if (group.deleted) {
          return;
        }
      }
      groups = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
          group = args[_j];
          _results.push(group.toJSON());
        }
        return _results;
      })();
      if (this.worker != null) {
        this.worker.postMessage({
          runOn: groups
        });
      } else {
        setTimeout((function(_this) {
          return function() {
            var e, _base, _base1;
            try {
              with ( this.globals ) {;
              _this.promise.result = _this["function"].apply(_this, groups);
              };
            } catch (_error) {
              e = _error;
              _this.promise.error = e;
              if (typeof (_base = _this.promise).errorCallback === "function") {
                _base.errorCallback(_this.promise.error);
              }
              return;
            }
            return typeof (_base1 = _this.promise).resultCallback === "function" ? _base1.resultCallback(_this.promise.result) : void 0;
          };
        })(this), 0);
      }
      return this.promise;
    };

    return _Class;

  })();

  CanvasRenderingContext2D.prototype.roundedRect = function(x1, y1, x2, y2, radius) {
    this.beginPath();
    this.moveTo(x1 + radius, y1);
    this.lineTo(x2 - radius, y1);
    this.arcTo(x2, y1, x2, y1 + radius, radius);
    this.lineTo(x2, y2 - radius);
    this.arcTo(x2, y2, x2 - radius, y2, radius);
    this.lineTo(x1 + radius, y2);
    this.arcTo(x1, y2, x1, y2 - radius, radius);
    this.lineTo(x1, y1 + radius);
    this.arcTo(x1, y1, x1 + radius, y1, radius);
    return this.closePath();
  };

  CanvasRenderingContext2D.prototype.roundedZone = function(x1, y1, x2, y2, upperLine, lowerLine, leftMargin, rightMargin, radius) {
    this.beginPath();
    this.moveTo(x1 + radius, y1);
    this.lineTo(this.canvas.width - rightMargin, y1);
    this.lineTo(this.canvas.width - rightMargin, lowerLine);
    this.lineTo(x2, lowerLine);
    this.lineTo(x2, y2 - radius);
    this.arcTo(x2, y2, x2 - radius, y2, radius);
    this.lineTo(leftMargin, y2);
    this.lineTo(leftMargin, upperLine);
    this.lineTo(x1, upperLine);
    this.lineTo(x1, y1 + radius);
    this.arcTo(x1, y1, x1 + radius, y1, radius);
    return this.closePath();
  };

  window.rectanglesCollide = function(x1, y1, x2, y2, x3, y3, x4, y4) {
    return !(x3 >= x2 || x4 <= x1 || y3 >= y2 || y4 <= y1);
  };

  window.svgBlobForHTML = function(html, style) {
    var height, span, width;
    if (style == null) {
      style = 'font-size:12px';
    }
    span = document.createElement('span');
    span.setAttribute('style', style);
    span.innerHTML = html;
    document.body.appendChild(span);
    span = $(span);
    width = span.width() + 2;
    height = span.height() + 2;
    span.remove();
    return makeBlob("<svg xmlns='http://www.w3.org/2000/svg' width='" + width + "' height='" + height + "'><foreignObject width='100%' height='100%'><div xmlns='http://www.w3.org/1999/xhtml' style='" + style + "'>" + html + "</div></foreignObject></svg>", 'image/svg+xml;charset=utf-8');
  };

  makeBlob = function(data, type) {
    var bb, e, _ref3, _ref4, _ref5;
    try {
      return new Blob([data], {
        type: type
      });
    } catch (_error) {
      e = _error;
      window.BlobBuilder = (_ref3 = (_ref4 = (_ref5 = window.BlobBuilder) != null ? _ref5 : window.WebKitBlobBuilder) != null ? _ref4 : window.MozBlobBuilder) != null ? _ref3 : window.MSBlobBuilder;
      if (e.name === 'TypeError' && (window.BlobBuilder != null)) {
        bb = new BlobBuilder();
        bb.append(data.buffer);
        return bb.getBlob(type);
      } else if (e.name === 'InvalidStateError') {
        return new Blob([data.buffer], {
          type: type
        });
      }
    }
  };

  drawHTMLCache = {
    order: [],
    maxSize: 100
  };

  cacheLookup = function(html, style) {
    var key;
    key = JSON.stringify([html, style]);
    if (drawHTMLCache.hasOwnProperty(key)) {
      return drawHTMLCache[key];
    } else {
      return null;
    }
  };

  addToCache = function(html, style, image) {
    var key;
    key = JSON.stringify([html, style]);
    drawHTMLCache[key] = image;
    return markUsed(html, style);
  };

  markUsed = function(html, style) {
    var index, key;
    key = JSON.stringify([html, style]);
    if ((index = drawHTMLCache.order.indexOf(key)) > -1) {
      drawHTMLCache.order.splice(index, 1);
    }
    drawHTMLCache.order.unshift(key);
    return pruneCache();
  };

  pruneCache = function() {
    var _results;
    _results = [];
    while (drawHTMLCache.order.length > drawHTMLCache.maxSize) {
      _results.push(delete drawHTMLCache[drawHTMLCache.order.pop()]);
    }
    return _results;
  };

  CanvasRenderingContext2D.prototype.drawHTML = function(html, x, y, style) {
    var image, url;
    if (style == null) {
      style = 'font-size:12px';
    }
    if (image = cacheLookup(html, style)) {
      this.drawImage(image, x, y);
      markUsed(html, style);
      return true;
    }
    url = objectURLForBlob(svgBlobForHTML(html, style));
    image = new Image();
    image.onload = function() {
      var _ref3, _ref4;
      addToCache(html, style, image);
      return ((_ref3 = (_ref4 = window.URL) != null ? _ref4 : window.webkitURL) != null ? _ref3 : window).revokeObjectURL(url);
    };
    image.onerror = function(error) {
      addToCache(html, style, new Image());
      return console.log('Failed to load SVG with this <foreignObject> div content:', html);
    };
    image.src = url;
    return false;
  };

  CanvasRenderingContext2D.prototype.measureHTML = function(html, style) {
    var image;
    if (style == null) {
      style = 'font-size:12px';
    }
    if (image = cacheLookup(html, style)) {
      markUsed(html, style);
      return {
        width: image.width,
        height: image.height
      };
    } else {
      this.drawHTML(html, 0, 0, style);
      return null;
    }
  };

  window.objectURLForBlob = function(blob) {
    var _ref3, _ref4;
    return ((_ref3 = (_ref4 = window.URL) != null ? _ref4 : window.webkitURL) != null ? _ref3 : window).createObjectURL(blob);
  };

  window.base64URLForBlob = function(blob, callback) {
    var reader;
    reader = new FileReader;
    reader.onload = function(event) {
      return callback(event.target.result);
    };
    return reader.readAsDataURL(blob);
  };

  window.installDOMUtilitiesIn = function(window) {
    window.Node.prototype.address = function(ancestor) {
      var recur;
      if (ancestor == null) {
        ancestor = null;
      }
      if (this === ancestor) {
        return [];
      }
      if (!this.parentNode) {
        if (ancestor) {
          return null;
        } else {
          return [];
        }
      }
      recur = this.parentNode.address(ancestor);
      if (recur === null) {
        return null;
      }
      return recur.concat([this.indexInParent()]);
    };
    window.Node.prototype.indexInParent = function() {
      if (this.parentNode) {
        return Array.prototype.slice.apply(this.parentNode.childNodes).indexOf(this);
      } else {
        return -1;
      }
    };
    window.Node.prototype.index = function(address) {
      var _ref3;
      if (!(address instanceof Array)) {
        throw Error('Node address function requires an array');
      }
      if (address.length === 0) {
        return this;
      }
      if (typeof address[0] !== 'number') {
        return void 0;
      }
      return (_ref3 = this.childNodes[address[0]]) != null ? _ref3.index(address.slice(1)) : void 0;
    };
    window.Node.prototype.toJSON = function(verbose) {
      var attribute, chi, result, _i, _len, _ref3;
      if (verbose == null) {
        verbose = true;
      }
      if (this instanceof window.Text) {
        return this.textContent;
      }
      if (this instanceof window.Comment) {
        if (verbose) {
          return {
            comment: true,
            content: this.textContent
          };
        } else {
          return {
            m: true,
            n: this.textContent
          };
        }
      }
      if (!(this instanceof window.Element)) {
        throw Error("Cannot serialize this node: " + this);
      }
      result = {
        tagName: this.tagName
      };
      if (this.attributes.length) {
        result.attributes = {};
        _ref3 = this.attributes;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          attribute = _ref3[_i];
          result.attributes[attribute.name] = attribute.value;
        }
      }
      if (this.childNodes.length) {
        result.children = (function() {
          var _j, _len1, _ref4, _results;
          _ref4 = this.childNodes;
          _results = [];
          for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
            chi = _ref4[_j];
            _results.push(chi.toJSON(verbose));
          }
          return _results;
        }).call(this);
      }
      if (!verbose) {
        result.t = result.tagName;
        delete result.tagName;
        result.a = result.attributes;
        delete result.attributes;
        result.c = result.children;
        delete result.children;
      }
      return result;
    };
    window.Node.fromJSON = function(json) {
      var attributes, child, children, key, result, value, _i, _len;
      if (typeof json === 'string') {
        return window.document.createTextNode(json);
      }
      if ('comment' in json && json.comment) {
        return window.document.createComment(json.content);
      }
      if ('m' in json && json.m) {
        return window.document.createComment(json.n);
      }
      if (!'tagName' in json && !'t' in json) {
        throw Error("Object has no t[agName]: " + this);
      }
      result = window.document.createElement(json.tagName || json.t);
      if (attributes = json.attributes || json.a) {
        for (key in attributes) {
          if (!__hasProp.call(attributes, key)) continue;
          value = attributes[key];
          result.setAttribute(key, value);
        }
      }
      if (children = json.children || json.c) {
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          child = children[_i];
          result.appendChild(Node.fromJSON(child));
        }
      }
      return result;
    };
    window.Node.prototype.nextLeaf = function(container) {
      var walk;
      if (container == null) {
        container = null;
      }
      walk = this;
      while (walk && walk !== container && !walk.nextSibling) {
        walk = walk.parentNode;
      }
      walk = walk != null ? walk.nextSibling : void 0;
      if (!walk) {
        return null;
      }
      while (walk.childNodes.length > 0) {
        walk = walk.childNodes[0];
      }
      return walk;
    };
    window.Node.prototype.previousLeaf = function(container) {
      var walk;
      if (container == null) {
        container = null;
      }
      walk = this;
      while (walk && walk !== container && !walk.previousSibling) {
        walk = walk.parentNode;
      }
      walk = walk != null ? walk.previousSibling : void 0;
      if (!walk) {
        return null;
      }
      while (walk.childNodes.length > 0) {
        walk = walk.childNodes[walk.childNodes.length - 1];
      }
      return walk;
    };
    window.Node.prototype.remove = function() {
      var _ref3;
      return (_ref3 = this.parentNode) != null ? _ref3.removeChild(this) : void 0;
    };
    window.Element.prototype.hasClass = function(name) {
      var classes, _ref3;
      classes = (_ref3 = this.getAttribute('class')) != null ? _ref3.split(/\s+/) : void 0;
      return classes && __indexOf.call(classes, name) >= 0;
    };
    window.Element.prototype.addClass = function(name) {
      var classes, _ref3;
      classes = ((_ref3 = this.getAttribute('class')) != null ? _ref3.split(/\s+/) : void 0) || [];
      if (__indexOf.call(classes, name) < 0) {
        classes.push(name);
      }
      return this.setAttribute('class', classes.join(' '));
    };
    window.Element.prototype.removeClass = function(name) {
      var c, classes, _ref3;
      classes = ((_ref3 = this.getAttribute('class')) != null ? _ref3.split(/\s+/) : void 0) || [];
      classes = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = classes.length; _i < _len; _i++) {
          c = classes[_i];
          if (c !== name) {
            _results.push(c);
          }
        }
        return _results;
      })();
      if (classes.length > 0) {
        return this.setAttribute('class', classes.join(' '));
      } else {
        return this.removeAttribute('class');
      }
    };
    return window.document.nodeFromPoint = function(x, y) {
      var elt, node, range, rect, _i, _j, _len, _len1, _ref3, _ref4;
      elt = window.document.elementFromPoint(x, y);
      _ref3 = elt.childNodes;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        node = _ref3[_i];
        if (node instanceof window.Text) {
          range = window.document.createRange();
          range.selectNode(node);
          _ref4 = range.getClientRects();
          for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
            rect = _ref4[_j];
            if ((rect.left < x && x < rect.right) && (rect.top < y && y < rect.bottom)) {
              return node;
            }
          }
        }
      }
      return elt;
    };
  };

  installDOMUtilitiesIn(window);

  if (exports == null) {
    exports = (_ref3 = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref3 : window;
  }

  if (typeof require !== "undefined" && require !== null) {
    require('./utils');
  }

  getNext = function(state) {
    if (state.pos < state.rhs.length) {
      return state.rhs[state.pos];
    } else {
      return null;
    }
  };

  copyState = function(state) {
    return {
      lhs: state.lhs,
      rhs: state.rhs,
      pos: state.pos,
      ori: state.ori,
      got: state.got.slice(0)
    };
  };

  equalArrays = function(array1, array2) {
    var entry1, entry2, index, _i, _len;
    if (array1.length !== array2.length) {
      return false;
    }
    for (index = _i = 0, _len = array1.length; _i < _len; index = ++_i) {
      entry1 = array1[index];
      entry2 = array2[index];
      if (entry1 instanceof RegExp) {
        if (!(entry2 instanceof RegExp) || entry1.source !== entry2.source) {
          return false;
        }
      } else {
        if (entry1 !== entry2) {
          return false;
        }
      }
    }
    return true;
  };

  exports.Grammar = Grammar = (function() {
    function Grammar(START) {
      this.START = START;
      this.parse = __bind(this.parse, this);
      this.addRule = __bind(this.addRule, this);
      this.setOption = __bind(this.setOption, this);
      this.rules = {};
      this.defaults = {
        addCategories: true,
        collapseBranches: false,
        showDebuggingOutput: false,
        expressionBuilder: null,
        tokenizer: null,
        comparator: JSON.equals
      };
    }

    Grammar.prototype.setOption = function(optionName, optionValue) {
      return this.defaults[optionName] = optionValue;
    };

    Grammar.prototype.addRule = function() {
      var categoryName, entry, index, sequence, sequences, _base, _i, _j, _len, _len1, _results;
      categoryName = arguments[0], sequences = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _results = [];
      for (_i = 0, _len = sequences.length; _i < _len; _i++) {
        sequence = sequences[_i];
        if (sequence instanceof RegExp) {
          sequence = [sequence];
        }
        if (!(sequence instanceof Array)) {
          sequence = ("" + sequence).split(' ');
        }
        for (index = _j = 0, _len1 = sequence.length; _j < _len1; index = ++_j) {
          entry = sequence[index];
          if (entry instanceof RegExp) {
            sequence[index] = new RegExp("^" + entry.source + "$");
          }
        }
        _results.push(((_base = this.rules)[categoryName] != null ? _base[categoryName] : _base[categoryName] = []).push(sequence));
      }
      return _results;
    };

    Grammar.prototype.parse = function(input, options) {
      var copy, debug, expressionBuilderFlag, found, got, i, j, k, next, previous, recur, result, results, rhs, rhss, s, skipped, state, stateGrid, stateSet, tmpi, tmpj, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _p, _q, _r, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      if (options == null) {
        options = {};
      }
      if (options.addCategories == null) {
        options.addCategories = this.defaults.addCategories;
      }
      if (options.collapseBranches == null) {
        options.collapseBranches = this.defaults.collapseBranches;
      }
      if (options.showDebuggingOutput == null) {
        options.showDebuggingOutput = this.defaults.showDebuggingOutput;
      }
      if (options.expressionBuilder == null) {
        options.expressionBuilder = this.defaults.expressionBuilder;
      }
      expressionBuilderFlag = {};
      if (options.tokenizer == null) {
        options.tokenizer = this.defaults.tokenizer;
      }
      if (options.comparator == null) {
        options.comparator = this.defaults.comparator;
      }
      debug = options.showDebuggingOutput ? console.log : function() {};
      debug('\n\n');
      if ((options.tokenizer != null) && typeof input === 'string') {
        input = options.tokenizer.tokenize(input);
      }
      stateGrid = (function() {
        var _i, _ref4, _results;
        _results = [];
        for (i = _i = 0, _ref4 = input.length; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
          _results.push([]);
        }
        return _results;
      })();
      stateGrid[0].push({
        lhs: '',
        rhs: [this.START],
        pos: 0,
        ori: 0,
        got: []
      });
      for (i = _i = 0, _len = stateGrid.length; _i < _len; i = ++_i) {
        stateSet = stateGrid[i];
        debug("processing stateSet " + i + " in this stateGrid (with input " + input + "):");
        debug('----------------------');
        for (tmpi = _j = 0, _ref4 = stateGrid.length; 0 <= _ref4 ? _j < _ref4 : _j > _ref4; tmpi = 0 <= _ref4 ? ++_j : --_j) {
          debug("|    state set " + tmpi + ":");
          skipped = 0;
          for (tmpj = _k = 0, _ref5 = stateGrid[tmpi].length; 0 <= _ref5 ? _k < _ref5 : _k > _ref5; tmpj = 0 <= _ref5 ? ++_k : --_k) {
            if (stateGrid[tmpi].length < 15 || stateGrid[tmpi][tmpj].pos > 0) {
              debug("|        entry " + tmpj + ": " + (debugState(stateGrid[tmpi][tmpj])));
            } else {
              skipped++;
            }
          }
          if (skipped > 0) {
            debug("|    (plus " + skipped + " at pos 0 not shown)");
          }
        }
        debug('----------------------');
        j = 0;
        while (j < stateSet.length) {
          state = stateSet[j];
          debug("entry " + j + ":", debugState(state));
          next = getNext(state);
          debug('next:', next);
          if (next === null) {
            debug('considering if this completion matters to state set', state.ori);
            _ref6 = stateGrid[state.ori];
            for (k = _l = 0, _len1 = _ref6.length; _l < _len1; k = ++_l) {
              s = _ref6[k];
              if (getNext(s) === state.lhs) {
                s = copyState(s);
                s.pos++;
                got = state.got.slice(0);
                if (options.addCategories) {
                  got.unshift(state.lhs);
                }
                if (options.expressionBuilder != null) {
                  got.unshift(expressionBuilderFlag);
                }
                if (options.collapseBranches && got.length === 1) {
                  got = got[0];
                }
                s.got.push(got);
                stateGrid[i].push(s);
                debug("completer added this to " + i + ":", debugState(s));
              }
            }
            j++;
            continue;
          }
          if (i >= input.length) {
            j++;
            continue;
          }
          debug('is it a terminal?', next instanceof RegExp);
          if (next instanceof RegExp) {
            if (next.test(input[i])) {
              copy = copyState(state);
              copy.pos++;
              copy.got.push(input[i]);
              stateGrid[i + 1].push(copy);
              debug("scanner added this to " + (i + 1) + ":", debugState(copy));
            }
            j++;
            continue;
          }
          if (!this.rules.hasOwnProperty(next)) {
            throw "Unknown non-terminal in grammar rule: " + next;
          }
          rhss = this.rules[next];
          debug("rhss: [" + (rhss.join('],[')) + "]");
          for (k = _m = 0, _len2 = rhss.length; _m < _len2; k = ++_m) {
            rhs = rhss[k];
            found = false;
            for (_n = 0, _len3 = stateSet.length; _n < _len3; _n++) {
              s = stateSet[_n];
              if (s.lhs === next && equalArrays(s.rhs, rhs) && s.pos === 0) {
                found = true;
                break;
              }
            }
            if (!found) {
              stateSet.push({
                lhs: next,
                rhs: rhs,
                pos: 0,
                ori: i,
                got: []
              });
              debug('adding this state:', debugState(stateSet[stateSet.length - 1]));
            }
          }
          j++;
        }
      }
      debug("finished processing this stateGrid (with input " + input + "):");
      debug('----------------------');
      for (tmpi = _o = 0, _ref7 = stateGrid.length; 0 <= _ref7 ? _o < _ref7 : _o > _ref7; tmpi = 0 <= _ref7 ? ++_o : --_o) {
        debug("|    state set " + tmpi + ":");
        skipped = 0;
        for (tmpj = _p = 0, _ref8 = stateGrid[tmpi].length; 0 <= _ref8 ? _p < _ref8 : _p > _ref8; tmpj = 0 <= _ref8 ? ++_p : --_p) {
          if (stateGrid[tmpi].length < 15 || stateGrid[tmpi][tmpj].pos > 0) {
            debug("|        entry " + tmpj + ": " + (debugState(stateGrid[tmpi][tmpj])));
          } else {
            skipped++;
          }
        }
        if (skipped > 0) {
          debug("|    (plus " + skipped + " at pos 0 not shown)");
        }
      }
      debug('----------------------');
      results = [];
      _ref9 = stateGrid[stateGrid.length - 1];
      for (_q = 0, _len4 = _ref9.length; _q < _len4; _q++) {
        stateSet = _ref9[_q];
        if (stateSet.lhs === '' && getNext(stateSet) === null) {
          result = stateSet.got[0];
          if (options.expressionBuilder != null) {
            recur = function(obj) {
              var args, o;
              if (!(obj instanceof Array) || obj[0] !== expressionBuilderFlag) {
                return obj;
              }
              args = (function() {
                var _len5, _r, _ref10, _results;
                _ref10 = obj.slice(1);
                _results = [];
                for (_r = 0, _len5 = _ref10.length; _r < _len5; _r++) {
                  o = _ref10[_r];
                  _results.push(recur(o));
                }
                return _results;
              })();
              if (args.length === 1 && options.collapseBranches) {
                args = args[0];
              }
              if (args.indexOf(void 0) > -1) {
                return void 0;
              }
              return options.expressionBuilder(args);
            };
            result = recur(result);
            if (result == null) {
              continue;
            }
          }
          found = false;
          for (_r = 0, _len5 = results.length; _r < _len5; _r++) {
            previous = results[_r];
            if (options.comparator(previous, result)) {
              found = true;
              break;
            }
          }
          if (!found) {
            results.push(result);
          }
        }
      }
      return results;
    };

    return Grammar;

  })();

  exports.Tokenizer = Tokenizer = (function() {
    function Tokenizer() {
      this.tokenize = __bind(this.tokenize, this);
      this.addType = __bind(this.addType, this);
      this.tokenTypes = [];
    }

    Tokenizer.prototype.addType = function(regexp, formatter) {
      if (formatter == null) {
        formatter = function(x) {
          return x;
        };
      }
      if (regexp.source[0] !== '^') {
        regexp = new RegExp("^(?:" + regexp.source + ")");
      }
      return this.tokenTypes.push({
        regexp: regexp,
        formatter: formatter
      });
    };

    Tokenizer.prototype.tokenize = function(input) {
      var format, match, next, original, result, token, type, _i, _len, _ref4;
      result = [];
      while (input.length > 0) {
        original = input.length;
        _ref4 = this.tokenTypes;
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          type = _ref4[_i];
          if (!(match = type.regexp.exec(input))) {
            continue;
          }
          input = input.slice(match[0].length);
          if (type.formatter instanceof Function) {
            next = type.formatter(match[0], match);
            if (next != null) {
              result.push(next);
            }
          } else {
            format = "" + type.formatter;
            token = '';
            while (next = /\%([0-9]+)/.exec(format)) {
              token += format.slice(0, next.index) + match[next[1]];
              format = format.slice(next.index + next[0].length);
            }
            result.push(token + format);
          }
          break;
        }
        if (input.length === original) {
          return null;
        }
      }
      return result;
    };

    return Tokenizer;

  })();

  debugNestedArrays = function(ary) {
    if (ary instanceof Array) {
      return '[' + ary.map(debugNestedArrays).join(',') + ']';
    } else {
      return ary;
    }
  };

  debugState = function(state) {
    return "(" + state.lhs + " -> " + state.pos + "in[" + state.rhs + "], " + state.ori + ") got " + (debugNestedArrays(state.got));
  };

}).call(this);

//# sourceMappingURL=weblurch.js.map
