// Generated by CoffeeScript 1.7.1
(function() {
  var LurchEditor,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Node.prototype.address = function(ancestor) {
    var recur;
    if (ancestor == null) {
      ancestor = null;
    }
    if (this === ancestor) {
      return [];
    }
    if (!this.parentNode) {
      if (ancestor) {
        return null;
      } else {
        return [];
      }
    }
    recur = this.parentNode.address(ancestor);
    if (recur === null) {
      return null;
    }
    return recur.concat([Array.prototype.slice.apply(this.parentNode.childNodes).indexOf(this)]);
  };

  Node.prototype.index = function(address) {
    var _ref;
    if (!(address instanceof Array)) {
      throw Error('Node address function requires an array');
    }
    if (address.length === 0) {
      return this;
    }
    if (typeof address[0] !== 'number') {
      return void 0;
    }
    return (_ref = this.childNodes[address[0]]) != null ? _ref.index(address.slice(1)) : void 0;
  };

  Node.prototype.toJSON = function(verbose) {
    var attribute, chi, result, _i, _len, _ref;
    if (verbose == null) {
      verbose = true;
    }
    if (this instanceof Text) {
      return this.textContent;
    }
    if (this instanceof Comment) {
      if (verbose) {
        return {
          comment: true,
          content: this.textContent
        };
      } else {
        return {
          m: true,
          n: this.textContent
        };
      }
    }
    if (!(this instanceof Element)) {
      throw Error("Cannot serialize this node: " + this);
    }
    result = {
      tagName: this.tagName
    };
    if (this.attributes.length) {
      result.attributes = {};
      _ref = this.attributes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attribute = _ref[_i];
        result.attributes[attribute.name] = attribute.value;
      }
    }
    if (this.childNodes.length) {
      result.children = (function() {
        var _j, _len1, _ref1, _results;
        _ref1 = this.childNodes;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          chi = _ref1[_j];
          _results.push(chi.toJSON(verbose));
        }
        return _results;
      }).call(this);
    }
    if (!verbose) {
      result.t = result.tagName;
      delete result.tagName;
      result.a = result.attributes;
      delete result.attributes;
      result.c = result.children;
      delete result.children;
    }
    return result;
  };

  Node.fromJSON = function(json) {
    var attributes, child, children, key, result, value, _i, _len;
    if (typeof json === 'string') {
      return document.createTextNode(json);
    }
    if ('comment' in json && json.comment) {
      return document.createComment(json.content);
    }
    if ('m' in json && json.m) {
      return document.createComment(json.n);
    }
    if (!'tagName' in json && !'t' in json) {
      throw Error("Object has no t[agName]: " + this);
    }
    result = document.createElement(json.tagName || json.t);
    if (attributes = json.attributes || json.a) {
      for (key in attributes) {
        if (!__hasProp.call(attributes, key)) continue;
        value = attributes[key];
        result.setAttribute(key, value);
      }
    }
    if (children = json.children || json.c) {
      for (_i = 0, _len = children.length; _i < _len; _i++) {
        child = children[_i];
        result.appendChild(Node.fromJSON(child));
      }
    }
    return result;
  };

  window.LurchEditor = LurchEditor = (function() {
    LurchEditor.prototype.nextFreeId = function() {
      if (this.freeIds.length > 1) {
        return this.freeIds.shift();
      } else {
        return this.freeIds[0]++;
      }
    };

    LurchEditor.prototype.addFreeId = function(id) {
      if (id < this.freeIds[this.freeIds.length - 1]) {
        this.freeIds.push(id);
        return this.freeIds.sort(function(a, b) {
          return a - b;
        });
      }
    };

    function LurchEditor(div) {
      var i, usedIds;
      this.element = null;
      if (div && (div != null ? div.tagName : void 0) !== 'DIV') {
        throw new Error('LurchEditor can only be\nconstructed in a DIV node');
      }
      usedIds = this.cleanIds(div);
      this.freeIds = usedIds.length === 0 ? [0] : (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = (Math.max.apply(Math, usedIds)) + 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (__indexOf.call(usedIds, i) < 0) {
            _results.push(i);
          }
        }
        return _results;
      })();
      this.assignIds(div);
      this.element = div;
    }

    LurchEditor.prototype.cleanIds = function(node) {
      var child, id, result, _i, _len, _ref;
      result = [];
      if (!(node instanceof Node)) {
        return result;
      }
      if (node.id) {
        if (/^\d+$/.test(node.id)) {
          result.push(parseInt(node.id));
        } else {
          node.removeAttribute('id');
        }
      }
      _ref = node.childNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        result = result.concat((function() {
          var _j, _len1, _ref1, _results;
          _ref1 = this.cleanIds(child);
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            id = _ref1[_j];
            if (__indexOf.call(result, id) < 0) {
              _results.push(id);
            }
          }
          return _results;
        }).call(this));
      }
      return result;
    };

    LurchEditor.prototype.assignIds = function(node) {
      var child, _i, _len, _ref, _results;
      if (!(node instanceof Node)) {
        return;
      }
      if (node instanceof HTMLElement && !node.id) {
        node.id = this.nextFreeId();
      }
      _ref = node.childNodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        _results.push(this.assignIds(child));
      }
      return _results;
    };

    LurchEditor.prototype.getElement = function() {
      return this.element;
    };

    LurchEditor.prototype.address = function(node) {
      if (this.element) {
        return node != null ? node.address(this.element) : void 0;
      } else {
        return null;
      }
    };

    LurchEditor.prototype.index = function(address) {
      if (this.element) {
        return this.element.index(address);
      } else {
        return null;
      }
    };

    return LurchEditor;

  })();

}).call(this);

//# sourceMappingURL=weblurch.map
