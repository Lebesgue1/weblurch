// Generated by CoffeeScript 1.8.0
(function() {
  var Match, OM, OMNode, clearMetavariable, exports, isMetavariable, matchDebuggingEnabled, matches, mdebug, metavariableSymbol, setMetavariable, trueValue, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  if (typeof exports === "undefined" || exports === null) {
    exports = (_ref = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref : window;
  }

  if (typeof require !== "undefined" && require !== null) {
    _ref1 = require('./openmath.duo'), OM = _ref1.OM, OMNode = _ref1.OMNode;
  }

  metavariableSymbol = OM.symbol('metavariable', 'lurch');

  trueValue = OM.string('true');

  exports.setMetavariable = setMetavariable = function(variable) {
    var _ref2;
    if (!(variable instanceof OMNode) || ((_ref2 = variable.type) !== 'v' && _ref2 !== 'sy')) {
      return;
    }
    return variable.setAttribute(metavariableSymbol, trueValue.copy());
  };

  exports.clearMetavariable = clearMetavariable = function(metavariable) {
    return metavariable.removeAttribute(metavariableSymbol);
  };

  exports.isMetavariable = isMetavariable = function(variable) {
    var _ref2, _ref3;
    return variable instanceof OMNode && ((_ref2 = variable.type) === 'v' || _ref2 === 'sy') && ((_ref3 = variable.getAttribute(metavariableSymbol)) != null ? _ref3.equals(trueValue) : void 0);
  };

  exports.Match = Match = (function() {
    function _Class() {
      this.toString = __bind(this.toString, this);
      this.copy = __bind(this.copy, this);
      this.complete = __bind(this.complete, this);
      this.storeTopmostPair = __bind(this.storeTopmostPair, this);
      this.getSubstitutionNode = __bind(this.getSubstitutionNode, this);
      this.getSubstitutionRight = __bind(this.getSubstitutionRight, this);
      this.getSubstitutionLeft = __bind(this.getSubstitutionLeft, this);
      this.getSubstitutionRoot = __bind(this.getSubstitutionRoot, this);
      this.getSubstitutionRequired = __bind(this.getSubstitutionRequired, this);
      this.hasSubstitution = __bind(this.hasSubstitution, this);
      this.clearSubstitution = __bind(this.clearSubstitution, this);
      this.setSubstitution = __bind(this.setSubstitution, this);
      this.applyTo = __bind(this.applyTo, this);
      this.keys = __bind(this.keys, this);
      this.has = __bind(this.has, this);
      this.clear = __bind(this.clear, this);
      this.get = __bind(this.get, this);
      this.set = __bind(this.set, this);
      this.map = {};
    }

    _Class.prototype.set = function(varOrSym, expr) {
      var vname;
      if (varOrSym.simpleEncode != null) {
        varOrSym = varOrSym.simpleEncode();
      }
      this.map[varOrSym] = expr.copy();
      if (this.substitution != null) {
        return this.substitution.unavailable = (function() {
          var _i, _len, _ref2, _results;
          _ref2 = this.substitution.unavailable;
          _results = [];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            vname = _ref2[_i];
            if (vname !== varOrSym) {
              _results.push(vname);
            }
          }
          return _results;
        }).call(this);
      }
    };

    _Class.prototype.get = function(varOrSym) {
      var _ref2;
      return this.map[(_ref2 = typeof varOrSym.simpleEncode === "function" ? varOrSym.simpleEncode() : void 0) != null ? _ref2 : varOrSym];
    };

    _Class.prototype.clear = function(varOrSym) {
      var _ref2, _ref3, _ref4;
      varOrSym = (_ref2 = typeof varOrSym.simpleEncode === "function" ? varOrSym.simpleEncode() : void 0) != null ? _ref2 : varOrSym;
      delete this.map[varOrSym];
      if (__indexOf.call((_ref3 = (_ref4 = this.substitution) != null ? _ref4.metavariables : void 0) != null ? _ref3 : [], varOrSym) >= 0) {
        if (__indexOf.call(this.substitution.unavailable, varOrSym) < 0) {
          return this.substitution.unavailable.push(varOrSym);
        }
      }
    };

    _Class.prototype.has = function(varOrSym) {
      var _ref2;
      return this.map.hasOwnProperty((_ref2 = typeof varOrSym.simpleEncode === "function" ? varOrSym.simpleEncode() : void 0) != null ? _ref2 : varOrSym);
    };

    _Class.prototype.keys = function() {
      return Object.keys(this.map);
    };

    _Class.prototype.applyTo = function(pattern) {
      var metavariable, result, _i, _len, _ref2;
      result = pattern.copy();
      _ref2 = result.descendantsSatisfying(isMetavariable);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        metavariable = _ref2[_i];
        if (this.has(metavariable)) {
          metavariable.replaceWith(this.get(metavariable).copy());
        }
      }
      return result;
    };

    _Class.requiredSubstitution = OM.symbol('replaceAll', 'lurch');

    _Class.optionalSubstitution = OM.symbol('replaceSome', 'lurch');

    _Class.prototype.setSubstitution = function(substitution) {
      var leftMetavariables, rightMetavariables, v, vname, _i, _j, _len, _len1, _ref2, _ref3;
      this.substitution = {
        original: substitution,
        required: substitution.children[0].equals(Match.requiredSubstitution),
        root: substitution.children[1],
        leftHandSide: substitution.children[2],
        rightHandSide: substitution.children[3],
        metavariables: []
      };
      leftMetavariables = this.substitution.leftHandSide.descendantsSatisfying(isMetavariable);
      for (_i = 0, _len = leftMetavariables.length; _i < _len; _i++) {
        v = leftMetavariables[_i];
        if (_ref2 = v.name, __indexOf.call(this.substitution.metavariables, _ref2) < 0) {
          this.substitution.metavariables.push(v.name);
        }
      }
      rightMetavariables = this.substitution.rightHandSide.descendantsSatisfying(isMetavariable);
      for (_j = 0, _len1 = rightMetavariables.length; _j < _len1; _j++) {
        v = rightMetavariables[_j];
        if (_ref3 = v.name, __indexOf.call(this.substitution.metavariables, _ref3) < 0) {
          this.substitution.metavariables.push(v.name);
        }
      }
      return this.substitution.unavailable = (function() {
        var _k, _len2, _ref4, _results;
        _ref4 = this.substitution.metavariables;
        _results = [];
        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
          vname = _ref4[_k];
          if (!this.map.hasOwnProperty(vname)) {
            _results.push(vname);
          }
        }
        return _results;
      }).call(this);
    };

    _Class.prototype.clearSubstitution = function() {
      return delete this.substitution;
    };

    _Class.prototype.hasSubstitution = function() {
      return this.substitution != null;
    };

    _Class.prototype.getSubstitutionRequired = function() {
      var _ref2;
      return (_ref2 = this.substitution) != null ? _ref2.required : void 0;
    };

    _Class.prototype.getSubstitutionRoot = function() {
      var _ref2;
      return (_ref2 = this.substitution) != null ? _ref2.root : void 0;
    };

    _Class.prototype.getSubstitutionLeft = function() {
      var _ref2;
      return (_ref2 = this.substitution) != null ? _ref2.leftHandSide : void 0;
    };

    _Class.prototype.getSubstitutionRight = function() {
      var _ref2;
      return (_ref2 = this.substitution) != null ? _ref2.rightHandSide : void 0;
    };

    _Class.prototype.getSubstitutionNode = function() {
      var _ref2;
      return (_ref2 = this.substitution) != null ? _ref2.original : void 0;
    };

    _Class.prototype.storeTopmostPair = function(pattern, expression) {
      this.pattern = pattern;
      return this.expression = expression;
    };

    _Class.prototype.complete = function() {
      var integers, key, last, match, metavariable, metavariables, unused, unusedCheck, unusedRE, value, variable, _i, _j, _len, _len1, _ref2, _results;
      if (!((this.pattern != null) && (this.expression != null))) {
        return;
      }
      unusedRE = /^unused_([0-9]+)$/;
      unusedCheck = function(node) {
        return node.type === 'v' && unusedRE.test(node.name);
      };
      unused = this.pattern.descendantsSatisfying(unusedCheck).concat(this.expression.descendantsSatisfying(unusedCheck));
      _ref2 = this.map;
      for (key in _ref2) {
        if (!__hasProp.call(_ref2, key)) continue;
        value = _ref2[key];
        unused = unused.concat(value.descendantsSatisfying(unusedCheck));
      }
      integers = [0];
      for (_i = 0, _len = unused.length; _i < _len; _i++) {
        variable = unused[_i];
        match = unusedRE.exec(variable.name);
        integers.push(parseInt(match[1]));
      }
      integers = integers.sort(function(a, b) {
        return a - b;
      });
      last = integers[integers.length - 1];
      metavariables = this.pattern.descendantsSatisfying(isMetavariable);
      _results = [];
      for (_j = 0, _len1 = metavariables.length; _j < _len1; _j++) {
        metavariable = metavariables[_j];
        if (!this.has(metavariable)) {
          _results.push(this.set(metavariable, OM.variable("unused_" + (++last))));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    _Class.prototype.copy = function() {
      var key, result, value, _ref2;
      result = new Match;
      _ref2 = this.map;
      for (key in _ref2) {
        if (!__hasProp.call(_ref2, key)) continue;
        value = _ref2[key];
        result.map[key] = value.copy();
      }
      if (this.substitution != null) {
        result.substitution = {
          original: this.substitution.original,
          root: this.substitution.root,
          leftHandSide: this.substitution.leftHandSide,
          rightHandSide: this.substitution.rightHandSide,
          required: this.substitution.required,
          metavariables: this.substitution.metavariables.slice(0),
          unavailable: this.substitution.unavailable.slice(0)
        };
      }
      if (this.pattern != null) {
        result.pattern = this.pattern;
      }
      if (this.expression != null) {
        result.expression = this.expression;
      }
      return result;
    };

    _Class.prototype.toString = function() {
      var key, result, value, _ref2, _ref3;
      result = '{';
      _ref3 = (_ref2 = this.map) != null ? _ref2 : {};
      for (key in _ref3) {
        if (!__hasProp.call(_ref3, key)) continue;
        value = _ref3[key];
        if (result.length > 1) {
          result += ',';
        }
        result += "" + key + ":" + (value.simpleEncode());
      }
      result += '}';
      if (this.hasSubstitution()) {
        result += '[' + this.getSubstitutionLeft().simpleEncode() + (this.getSubstitutionRequired() ? '=' : '~') + this.getSubstitutionRight().simpleEncode() + ' in ' + this.getSubstitutionRoot().simpleEncode() + ']';
      }
      return result;
    };

    return _Class;

  })();

  matchDebuggingEnabled = false;

  mdebug = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (matchDebuggingEnabled) {
      return console.log.apply(console, args);
    }
  };

  exports.matches = matches = function(pattern, expression, soFar) {
    var d, descs, e, echild, echildren, einstantiated, existUnusedMetavars, expr, exprs, freeToReplace, fullRHS, index, isASubstitution, last, left, lhs, many, newRHS, newResults, outermost, p, pchild, pchildren, r, recur, recurResult, result, results, rhs, right, rinstantiated, root, sf, substIndex, substitution, substitutions, test, trySubs, tuple, _i, _j, _k, _l, _len, _len1, _len10, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _s;
    outermost = soFar == null;
    if (soFar == null) {
      soFar = new Match;
    }
    mdebug("" + (outermost ? '\n' : '') + "MATCHES:", (_ref2 = pattern != null ? typeof pattern.simpleEncode === "function" ? pattern.simpleEncode() : void 0 : void 0) != null ? _ref2 : pattern, (_ref3 = expression != null ? typeof expression.simpleEncode === "function" ? expression.simpleEncode() : void 0 : void 0) != null ? _ref3 : expression, "" + soFar);
    if (outermost) {
      soFar.storeTopmostPair(pattern, expression);
      substitutions = expression.descendantsSatisfying(function(x) {
        return x.type === 'a' && x.children.length === 4 && x.children[0].equals(Match.requiredSubstitution);
      });
      for (_i = 0, _len = substitutions.length; _i < _len; _i++) {
        substitution = substitutions[_i];
        left = substitution.children[2];
        right = substitution.children[3];
        substitution.replaceWith(substitution.children[1]);
        substitution.replaceFree(left, right);
      }
    }
    mdebug('  --pattern inside topmost pattern?', soFar.pattern.hasDescendantSatisfying(function(d) {
      return d.sameObjectAs(pattern);
    }));
    mdebug('  --expression inside topmost expression?', soFar.expression.hasDescendantSatisfying(function(d) {
      return d.sameObjectAs(expression);
    }));
    mdebug('  --pattern inside substitution root?', (_ref4 = soFar.getSubstitutionRoot()) != null ? _ref4.hasDescendantSatisfying(function(d) {
      return d.sameObjectAs(pattern);
    }) : void 0);
    trySubs = function() {
      var fullRHS, instantiated, lhsInThere, lhsLocation, match, pair, result, results, rhs, root, save, sub, walk1, walk2, _j, _k, _len1, _len2, _ref5, _ref6, _ref7;
      if (!soFar.hasSubstitution()) {
        return [];
      }
      mdebug('    match of', pattern.simpleEncode(), 'to', expression.simpleEncode(), 'failed; trying subs...', soFar.toString());
      save = soFar.getSubstitutionNode();
      root = soFar.getSubstitutionRoot();
      rhs = soFar.getSubstitutionRight();
      pair = OM.application;
      sub = pair(soFar.getSubstitutionLeft(), rhs);
      soFar.clearSubstitution();
      _ref5 = [pattern, expression, []], walk1 = _ref5[0], walk2 = _ref5[1], results = _ref5[2];
      while ((walk1 != null) && (walk2 != null)) {
        mdebug('    attempting subs at this level:', sub.simpleEncode(), pair(walk1, walk2).simpleEncode(), "" + soFar + "...");
        _ref6 = matches(sub, pair(walk1, walk2), soFar, false);
        for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
          match = _ref6[_j];
          mdebug('        checking this:', "" + match);
          lhsLocation = walk1.address(root);
          instantiated = match.applyTo(root);
          lhsInThere = instantiated.index(lhsLocation);
          fullRHS = match.applyTo(rhs);
          mdebug("        is " + (fullRHS != null ? typeof fullRHS.simpleEncode === "function" ? fullRHS.simpleEncode() : void 0 : void 0) + " free to replace " + (lhsInThere != null ? typeof lhsInThere.simpleEncode === "function" ? lhsInThere.simpleEncode() : void 0 : void 0) + " in " + (instantiated != null ? typeof instantiated.simpleEncode === "function" ? instantiated.simpleEncode() : void 0 : void 0) + "? " + (fullRHS.isFreeToReplace(lhsInThere, instantiated)));
          if (fullRHS.isFreeToReplace(lhsInThere, instantiated)) {
            results.push(match);
          }
        }
        if (walk1.sameObjectAs(root)) {
          break;
        }
        _ref7 = [walk1.parent, walk2.parent], walk1 = _ref7[0], walk2 = _ref7[1];
      }
      for (_k = 0, _len2 = results.length; _k < _len2; _k++) {
        result = results[_k];
        result.setSubstitution(save);
      }
      mdebug('    done attempting all subs; results:', (function() {
        var _l, _len3, _results;
        _results = [];
        for (_l = 0, _len3 = results.length; _l < _len3; _l++) {
          result = results[_l];
          _results.push("" + result);
        }
        return _results;
      })());
      return results;
    };
    if (pattern.type === 'a' && pattern.children.length === 4 && (pattern.children[0].equals(Match.requiredSubstitution) || pattern.children[0].equals(Match.optionalSubstitution))) {
      mdebug('    pattern is a substitution...');
      if (soFar.hasSubstitution()) {
        throw 'Only one substitution permitted in a pattern';
      }
      soFar.setSubstitution(pattern);
      rhs = soFar.getSubstitutionRight();
      results = matches(pattern.children[1], expression, soFar);
      newResults = [];
      for (_j = 0, _len1 = results.length; _j < _len1; _j++) {
        result = results[_j];
        mdebug('    checking substitution match', "" + result);
        if (pattern.children[0].equals(Match.optionalSubstitution)) {
          mdebug('        optional, so we approve it');
          result.clearSubstitution();
          newResults.push(result);
          continue;
        }
        lhs = result.getSubstitutionLeft();
        existUnusedMetavars = lhs.hasDescendantSatisfying(function(d) {
          return isMetavariable(d) && !result.has(d);
        });
        if (existUnusedMetavars) {
          mdebug('        approved because of unused metavars');
          result.clearSubstitution();
          newResults.push(result);
          continue;
        }
        root = result.getSubstitutionRoot();
        rinstantiated = result.applyTo(root);
        lhs = result.applyTo(lhs);
        descs = rinstantiated.descendantsSatisfying(function(d) {
          return d.equals(lhs) && !d.hasDescendantSatisfying(isMetavariable) && d.isFree(rinstantiated);
        });
        mdebug('        instantiated root:', rinstantiated.simpleEncode());
        mdebug('        instances of lhs:', (function() {
          var _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = descs.length; _k < _len2; _k++) {
            d = descs[_k];
            _results.push(d.address(pattern));
          }
          return _results;
        })());
        einstantiated = result.applyTo(expression);
        mdebug('        instantiated expression:', einstantiated.simpleEncode());
        exprs = (function() {
          var _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = descs.length; _k < _len2; _k++) {
            d = descs[_k];
            _results.push(einstantiated.index(d.address(rinstantiated)));
          }
          return _results;
        })();
        mdebug('        corresponding expression subtrees:', (function() {
          var _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = exprs.length; _k < _len2; _k++) {
            e = exprs[_k];
            _results.push(e.simpleEncode());
          }
          return _results;
        })());
        tuple = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return OM.application.apply(OM, [OM.string("tuple")].concat(__slice.call(args)));
        };
        fullRHS = result.applyTo(rhs);
        many = (function() {
          var _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = exprs.length; _k < _len2; _k++) {
            e = exprs[_k];
            _results.push(fullRHS);
          }
          return _results;
        })();
        mdebug('        will now recur on these tuples:');
        mdebug("        " + (tuple.apply(null, many).simpleEncode()));
        mdebug("        " + (tuple.apply(null, exprs).simpleEncode()));
        result.clearSubstitution();
        recur = matches(tuple.apply(null, many), tuple.apply(null, exprs), result);
        mdebug('        recursion on tuples complete; testing...');
        for (_k = 0, _len2 = recur.length; _k < _len2; _k++) {
          recurResult = recur[_k];
          mdebug('        testing:', "" + recurResult);
          newRHS = recurResult.applyTo(rhs);
          freeToReplace = true;
          for (_l = 0, _len3 = exprs.length; _l < _len3; _l++) {
            expr = exprs[_l];
            if (!newRHS.isFreeToReplace(expr, expression)) {
              freeToReplace = false;
              break;
            }
          }
          if (freeToReplace) {
            mdebug('        approved after extending:', "" + recurResult);
            newResults.push(recurResult);
          } else {
            mdebug('        rejected after extending:', "" + recurResult);
          }
        }
      }
      results = newResults;
      if (outermost) {
        for (_m = 0, _len4 = results.length; _m < _len4; _m++) {
          result = results[_m];
          result.complete();
        }
      }
      mdebug('    results have been completed:', (function() {
        var _len5, _n, _results;
        _results = [];
        for (_n = 0, _len5 = results.length; _n < _len5; _n++) {
          r = results[_n];
          _results.push("" + r);
        }
        return _results;
      })());
      mdebug('<--', (function() {
        var _len5, _n, _results;
        _results = [];
        for (_n = 0, _len5 = newResults.length; _n < _len5; _n++) {
          r = newResults[_n];
          _results.push("" + r);
        }
        return _results;
      })());
      return newResults;
    }
    if (isMetavariable(pattern)) {
      mdebug('    pattern is a metavariable');
      if (test = soFar.get(pattern)) {
        mdebug('    we use its already-determined value:');
        result = matches(test, expression, soFar);
        mdebug('<--', (function() {
          var _len5, _n, _results;
          _results = [];
          for (_n = 0, _len5 = result.length; _n < _len5; _n++) {
            r = result[_n];
            _results.push("" + r);
          }
          return _results;
        })());
        return result;
      }
      soFar.set(pattern, expression);
      mdebug('    stored new assignment', pattern.simpleEncode(), '=', expression.simpleEncode(), 'yielding', "" + soFar);
      results = [soFar];
      if (outermost) {
        for (_n = 0, _len5 = results.length; _n < _len5; _n++) {
          result = results[_n];
          result.complete();
        }
      }
      mdebug('    results have been completed:', (function() {
        var _len6, _o, _results;
        _results = [];
        for (_o = 0, _len6 = results.length; _o < _len6; _o++) {
          r = results[_o];
          _results.push("" + r);
        }
        return _results;
      })());
      mdebug('<--', (function() {
        var _len6, _o, _results;
        _results = [];
        for (_o = 0, _len6 = results.length; _o < _len6; _o++) {
          r = results[_o];
          _results.push("" + r);
        }
        return _results;
      })());
      return results;
    }
    mdebug('    comparing types...', pattern.type, expression.type);
    if (pattern.type !== expression.type) {
      result = trySubs();
      mdebug('<--', (function() {
        var _len6, _o, _results;
        _results = [];
        for (_o = 0, _len6 = result.length; _o < _len6; _o++) {
          r = result[_o];
          _results.push("" + r);
        }
        return _results;
      })());
      return result;
    }
    if ((_ref5 = pattern.type) === 'i' || _ref5 === 'f' || _ref5 === 'st' || _ref5 === 'ba' || _ref5 === 'sy' || _ref5 === 'v') {
      if (pattern.equals(expression, false)) {
        results = [soFar];
        if (outermost) {
          for (_o = 0, _len6 = results.length; _o < _len6; _o++) {
            result = results[_o];
            result.complete();
          }
        }
        mdebug('    results have been completed:', (function() {
          var _len7, _p, _results;
          _results = [];
          for (_p = 0, _len7 = results.length; _p < _len7; _p++) {
            r = results[_p];
            _results.push("" + r);
          }
          return _results;
        })());
      } else {
        results = trySubs();
      }
      mdebug('<--', (function() {
        var _len7, _p, _results;
        _results = [];
        for (_p = 0, _len7 = results.length; _p < _len7; _p++) {
          r = results[_p];
          _results.push("" + r);
        }
        return _results;
      })());
      return results;
    }
    pchildren = pattern.childrenSatisfying();
    mdebug('    pattern children:', (function() {
      var _len7, _p, _results;
      _results = [];
      for (_p = 0, _len7 = pchildren.length; _p < _len7; _p++) {
        p = pchildren[_p];
        _results.push(p.simpleEncode());
      }
      return _results;
    })());
    echildren = expression.childrenSatisfying();
    mdebug('    expression children:', (function() {
      var _len7, _p, _results;
      _results = [];
      for (_p = 0, _len7 = echildren.length; _p < _len7; _p++) {
        e = echildren[_p];
        _results.push(e.simpleEncode());
      }
      return _results;
    })());
    if (pchildren.length !== echildren.length) {
      result = trySubs();
      mdebug('<--', (function() {
        var _len7, _p, _results;
        _results = [];
        for (_p = 0, _len7 = result.length; _p < _len7; _p++) {
          r = result[_p];
          _results.push("" + r);
        }
        return _results;
      })());
      return result;
    }
    substIndex = -1;
    isASubstitution = function(node) {
      return node.type === 'a' && ((node.children[0].equals(Match.requiredSubstitution)) || (node.children[0].equals(Match.optionalSubstitution)));
    };
    for (index = _p = 0, _len7 = pchildren.length; _p < _len7; index = ++_p) {
      pchild = pchildren[index];
      if (pchild.descendantsSatisfying(isASubstitution).length > 0) {
        if (substIndex > -1) {
          throw 'Only one substitution permitted in a pattern';
        }
        substIndex = index;
      }
    }
    if (substIndex > -1) {
      last = pchildren.length - 1;
      _ref6 = [pchildren[last], pchildren[substIndex]], pchildren[substIndex] = _ref6[0], pchildren[last] = _ref6[1];
      _ref7 = [echildren[last], echildren[substIndex]], echildren[substIndex] = _ref7[0], echildren[last] = _ref7[1];
      mdebug('    reordered children to put substitution at end...');
      mdebug('    pattern children:', (function() {
        var _len8, _q, _results;
        _results = [];
        for (_q = 0, _len8 = pchildren.length; _q < _len8; _q++) {
          p = pchildren[_q];
          _results.push(p.simpleEncode());
        }
        return _results;
      })());
      mdebug('    expression children:', (function() {
        var _len8, _q, _results;
        _results = [];
        for (_q = 0, _len8 = echildren.length; _q < _len8; _q++) {
          e = echildren[_q];
          _results.push(e.simpleEncode());
        }
        return _results;
      })());
    }
    results = [soFar];
    for (index = _q = 0, _len8 = pchildren.length; _q < _len8; index = ++_q) {
      pchild = pchildren[index];
      echild = echildren[index];
      mdebug('    recurring at', index, 'on', pchild.simpleEncode(), 'and', echild.simpleEncode(), 'with results', (function() {
        var _len9, _r, _results;
        _results = [];
        for (_r = 0, _len9 = results.length; _r < _len9; _r++) {
          r = results[_r];
          _results.push("" + r);
        }
        return _results;
      })());
      newResults = [];
      for (_r = 0, _len9 = results.length; _r < _len9; _r++) {
        sf = results[_r];
        newResults = newResults.concat(matches(pchild, echild, sf.copy()));
      }
      if ((results = newResults).length === 0) {
        break;
      }
    }
    mdebug('    recursion complete; new result set:', (function() {
      var _len10, _results, _s;
      _results = [];
      for (_s = 0, _len10 = results.length; _s < _len10; _s++) {
        r = results[_s];
        _results.push("" + r);
      }
      return _results;
    })());
    if (outermost) {
      for (_s = 0, _len10 = results.length; _s < _len10; _s++) {
        result = results[_s];
        result.complete();
      }
    }
    mdebug('    results have been completed:', (function() {
      var _len11, _results, _t;
      _results = [];
      for (_t = 0, _len11 = results.length; _t < _len11; _t++) {
        r = results[_t];
        _results.push("" + r);
      }
      return _results;
    })());
    mdebug('<--', (function() {
      var _len11, _results, _t;
      _results = [];
      for (_t = 0, _len11 = results.length; _t < _len11; _t++) {
        r = results[_t];
        _results.push("" + r);
      }
      return _results;
    })());
    return results;
  };

}).call(this);

//# sourceMappingURL=matching.duo.js.map
