// Generated by CoffeeScript 1.8.0
(function() {
  var Dialogs, Group, Groups, LoadSave, Overlay, createFontStyleString, createStyleString, editor, exportPage, formatContentForWiki, getAPIPage, getIndexPage, getPageContent, grouperHTML, grouperInfo, importPage, login, maybeSetupTestRecorder, moreMenuItems, plugin, setAPIPage, setIndexPage,
    __hasProp = {}.hasOwnProperty,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  Dialogs = {};

  Dialogs.alert = function(options) {
    var _ref, _ref1, _ref2;
    return tinymce.activeEditor.windowManager.open({
      title: (_ref = options.title) != null ? _ref : ' ',
      url: window.objectURLForBlob(window.makeBlob(options.message, 'text/html;charset=utf-8')),
      width: (_ref1 = options.width) != null ? _ref1 : 400,
      height: (_ref2 = options.height) != null ? _ref2 : 300,
      buttons: [
        {
          type: 'button',
          text: 'OK',
          subtype: 'primary',
          onclick: function(event) {
            tinymce.activeEditor.windowManager.close();
            return typeof options.callback === "function" ? options.callback(event) : void 0;
          }
        }
      ]
    });
  };

  Dialogs.confirm = function(options) {
    var _ref, _ref1, _ref2, _ref3, _ref4;
    return tinymce.activeEditor.windowManager.open({
      title: (_ref = options.title) != null ? _ref : ' ',
      url: window.objectURLForBlob(window.makeBlob(options.message, 'text/html;charset=utf-8')),
      width: (_ref1 = options.width) != null ? _ref1 : 400,
      height: (_ref2 = options.height) != null ? _ref2 : 300,
      buttons: [
        {
          type: 'button',
          text: (_ref3 = options.Cancel) != null ? _ref3 : 'Cancel',
          subtype: 'primary',
          onclick: function(event) {
            tinymce.activeEditor.windowManager.close();
            return typeof options.cancelCallback === "function" ? options.cancelCallback(event) : void 0;
          }
        }, {
          type: 'button',
          text: (_ref4 = options.OK) != null ? _ref4 : 'OK',
          subtype: 'primary',
          onclick: function(event) {
            tinymce.activeEditor.windowManager.close();
            return typeof options.okCallback === "function" ? options.okCallback(event) : void 0;
          }
        }
      ]
    });
  };

  tinymce.PluginManager.add('dialogs', function(editor, url) {
    return editor.Dialogs = Dialogs;
  });

  grouperHTML = function(typeName, openClose, id, hide, image) {
    if (hide == null) {
      hide = true;
    }
    hide = hide ? ' hide' : '';
    if (image == null) {
      image = "images/red-bracket-" + openClose + ".png";
    }
    return "<img src='" + image + "' class='grouper " + typeName + hide + "' id='" + openClose + id + "'>";
  };

  window.grouperHTML = grouperHTML;

  grouperInfo = function(grouper) {
    var info, more, result;
    info = /^(open|close)([0-9]+)$/.exec(grouper != null ? typeof grouper.getAttribute === "function" ? grouper.getAttribute('id') : void 0 : void 0);
    if (!info) {
      return null;
    }
    result = {
      openOrClose: info[1],
      id: parseInt(info[2])
    };
    more = /^grouper ([^ ]+)/.exec(grouper != null ? typeof grouper.getAttribute === "function" ? grouper.getAttribute('class') : void 0 : void 0);
    if (more) {
      result.type = more[1];
    }
    return result;
  };

  window.grouperInfo = grouperInfo;

  createStyleString = function(styleObject) {
    var key, letter, newkey, result, value, _i, _len;
    if (styleObject == null) {
      styleObject = window.defaultEditorStyles;
    }
    result = [];
    for (key in styleObject) {
      if (!__hasProp.call(styleObject, key)) continue;
      value = styleObject[key];
      newkey = '';
      for (_i = 0, _len = key.length; _i < _len; _i++) {
        letter = key[_i];
        if (letter.toUpperCase() === letter) {
          newkey += '-';
        }
        newkey += letter.toLowerCase();
      }
      result.push("" + newkey + ":" + value + ";");
    }
    return result.join(' ');
  };

  createFontStyleString = function(element) {
    var style;
    style = element.ownerDocument.defaultView.getComputedStyle(element);
    return "font-size:" + style.fontSize + "; font-family:" + style.fontFamily + ";";
  };

  Group = (function() {
    function Group(open, close, plugin) {
      var editor, _i, _len, _ref;
      this.open = open;
      this.close = close;
      this.plugin = plugin;
      this.toJSON = __bind(this.toJSON, this);
      this.contentsChanged = __bind(this.contentsChanged, this);
      this.nextSibling = __bind(this.nextSibling, this);
      this.previousSibling = __bind(this.previousSibling, this);
      this.indexInParent = __bind(this.indexInParent, this);
      this.rangeAfter = __bind(this.rangeAfter, this);
      this.rangeBefore = __bind(this.rangeBefore, this);
      this.outerRange = __bind(this.outerRange, this);
      this.innerRange = __bind(this.innerRange, this);
      this.setContentAsText = __bind(this.setContentAsText, this);
      this.contentNodes = __bind(this.contentNodes, this);
      this.contentAsHTML = __bind(this.contentAsHTML, this);
      this.contentAsFragment = __bind(this.contentAsFragment, this);
      this.contentAsText = __bind(this.contentAsText, this);
      this.updateGrouper = __bind(this.updateGrouper, this);
      this.clear = __bind(this.clear, this);
      this.get = __bind(this.get, this);
      this.set = __bind(this.set, this);
      this.type = __bind(this.type, this);
      this.typeName = __bind(this.typeName, this);
      this.id = __bind(this.id, this);
      if (this.plugin == null) {
        _ref = tinymce.editors;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          editor = _ref[_i];
          if (editor.getDoc() === this.open.ownerDocument) {
            this.plugin = editor.Groups;
            break;
          }
        }
      }
      this.contentsChanged(true, true);
    }

    Group.prototype.id = function() {
      var _ref, _ref1;
      return (_ref = (_ref1 = grouperInfo(this.open)) != null ? _ref1.id : void 0) != null ? _ref : null;
    };

    Group.prototype.typeName = function() {
      var _ref;
      return (_ref = grouperInfo(this.open)) != null ? _ref.type : void 0;
    };

    Group.prototype.type = function() {
      var _ref, _ref1;
      return (_ref = this.plugin) != null ? (_ref1 = _ref.groupTypes) != null ? _ref1[this.typeName()] : void 0 : void 0;
    };

    Group.prototype.set = function(key, value) {
      var attr, grouper, toStore, _i, _len, _ref, _results;
      if (!/^[a-zA-Z0-9-]+$/.test(key)) {
        return;
      }
      toStore = JSON.stringify([value]);
      if (this.open.getAttribute("data-" + key) !== toStore) {
        this.open.setAttribute("data-" + key, toStore);
        if (this.plugin != null) {
          this.plugin.editor.fire('change');
          this.plugin.editor.isNotDirty = false;
          this.contentsChanged();
        }
        if (key === 'openDecoration' || key === 'closeDecoration') {
          this.updateGrouper(key.slice(0, -10));
        }
        if (key === 'openHoverText' || key === 'closeHoverText') {
          grouper = this[key.slice(0, -9)];
          _ref = ['title', 'alt'];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            attr = _ref[_i];
            _results.push(grouper.setAttribute(attr, "" + value));
          }
          return _results;
        }
      }
    };

    Group.prototype.get = function(key) {
      var e;
      try {
        return JSON.parse(this.open.getAttribute("data-" + key))[0];
      } catch (_error) {
        e = _error;
        return void 0;
      }
    };

    Group.prototype.clear = function(key) {
      var attr, grouper, _i, _len, _ref, _results;
      if (!/^[a-zA-Z0-9-]+$/.test(key)) {
        return;
      }
      if (this.open.getAttribute("data-" + key) != null) {
        this.open.removeAttribute("data-" + key);
        if (this.plugin != null) {
          this.plugin.editor.fire('change');
          this.plugin.editor.isNotDirty = false;
          this.contentsChanged();
        }
        if (key === 'openDecoration' || key === 'closeDecoration') {
          this.updateGrouper(key.slice(0, -10));
        }
        if (key === 'openHoverText' || key === 'closeHoverText') {
          grouper = this[key.slice(0, -9)];
          _ref = ['title', 'alt'];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            attr = _ref[_i];
            _results.push(grouper.removeAttribute(attr));
          }
          return _results;
        }
      }
    };

    Group.prototype.updateGrouper = function(openOrClose) {
      var decoration, grouper, html, jquery, _ref;
      if (openOrClose === this.open) {
        openOrClose = 'open';
      }
      if (openOrClose === this.close) {
        openOrClose = 'close';
      }
      if (openOrClose !== 'open' && openOrClose !== 'close') {
        return;
      }
      jquery = $(grouper = this[openOrClose]);
      if ((decoration = this.get("" + openOrClose + "Decoration")) != null) {
        jquery.addClass('decorate');
      } else {
        jquery.removeClass('decorate');
        decoration = '';
      }
      html = jquery.hasClass('hide') ? '' : (_ref = this.type()) != null ? _ref["" + openOrClose + "ImageHTML"] : void 0;
      if (openOrClose === 'open') {
        html = decoration + html;
      } else {
        html += decoration;
      }
      return window.base64URLForBlob(window.svgBlobForHTML(html, createFontStyleString(grouper)), (function(_this) {
        return function(base64) {
          var _ref1, _ref2;
          if (grouper.getAttribute('src') !== base64) {
            grouper.setAttribute('src', base64);
            return (_ref1 = _this.plugin) != null ? (_ref2 = _ref1.editor.Overlay) != null ? _ref2.redrawContents() : void 0 : void 0;
          }
        };
      })(this));
    };

    Group.prototype.contentAsText = function() {
      var _ref;
      return (_ref = this.innerRange()) != null ? _ref.toString() : void 0;
    };

    Group.prototype.contentAsFragment = function() {
      var _ref;
      return (_ref = this.innerRange()) != null ? _ref.cloneContents() : void 0;
    };

    Group.prototype.contentAsHTML = function() {
      var fragment, tmp;
      if (!(fragment = this.contentAsFragment())) {
        return null;
      }
      tmp = this.open.ownerDocument.createElement('div');
      tmp.appendChild(fragment);
      return tmp.innerHTML;
    };

    Group.prototype.contentNodes = function() {
      var result, strictOrder, walk;
      result = [];
      strictOrder = function(a, b) {
        var cmp;
        cmp = a.compareDocumentPosition(b);
        return (Node.DOCUMENT_POSITION_FOLLOWING & cmp) && !(Node.DOCUMENT_POSITION_CONTAINED_BY & cmp);
      };
      walk = this.open;
      while (walk != null) {
        if (strictOrder(walk, this.close)) {
          if (strictOrder(this.open, walk)) {
            result.push(walk);
          }
          if (walk.nextSibling != null) {
            walk = walk.nextSibling;
          } else {
            walk = walk.parentNode;
          }
          continue;
        }
        if (strictOrder(this.close, walk)) {
          console.log('Warning!! walked past @close...something is wrong with this loop');
          break;
        }
        if (walk === this.close) {
          break;
        } else {
          walk = walk.childNodes[0];
        }
      }
      return result;
    };

    Group.prototype.setContentAsText = function(text) {
      var inside, _ref, _ref1;
      if (!(inside = this.innerRange())) {
        return;
      }
      if ((_ref = this.plugin) != null) {
        _ref.editor.selection.setRng(inside);
      }
      return (_ref1 = this.plugin) != null ? _ref1.editor.selection.setContent(text) : void 0;
    };

    Group.prototype.innerRange = function() {
      var e, range;
      range = this.open.ownerDocument.createRange();
      try {
        range.setStartAfter(this.open);
        range.setEndBefore(this.close);
        return range;
      } catch (_error) {
        e = _error;
        return null;
      }
    };

    Group.prototype.outerRange = function() {
      var e, range;
      range = this.open.ownerDocument.createRange();
      try {
        range.setStartBefore(this.open);
        range.setEndAfter(this.close);
        return range;
      } catch (_error) {
        e = _error;
        return null;
      }
    };

    Group.prototype.rangeBefore = function() {
      var doc, e, prev, range;
      range = (doc = this.open.ownerDocument).createRange();
      try {
        range.setEndBefore(this.open);
        if (prev = this.previousSibling()) {
          range.setStartAfter(prev.close);
        } else if (this.parent) {
          range.setStartAfter(this.parent.open);
        } else {
          range.setStartBefore(doc.body.childNodes[0]);
        }
        return range;
      } catch (_error) {
        e = _error;
        return null;
      }
    };

    Group.prototype.rangeAfter = function() {
      var doc, e, next, range;
      range = (doc = this.open.ownerDocument).createRange();
      try {
        range.setStartAfter(this.close);
        if (next = this.nextSibling()) {
          range.setEndBefore(next.open);
        } else if (this.parent) {
          range.setEndBefore(this.parent.close);
        } else {
          range.setEndAfter(doc.body.childNodes[doc.body.childNodes.length - 1]);
        }
        return range;
      } catch (_error) {
        e = _error;
        return null;
      }
    };

    Group.prototype.indexInParent = function() {
      var _ref, _ref1, _ref2, _ref3;
      return (_ref = (_ref1 = (_ref2 = this.parent) != null ? _ref2.children : void 0) != null ? _ref1 : (_ref3 = this.plugin) != null ? _ref3.topLevel : void 0) != null ? _ref.indexOf(this) : void 0;
    };

    Group.prototype.previousSibling = function() {
      var _ref, _ref1, _ref2, _ref3;
      return (_ref = (_ref1 = (_ref2 = this.parent) != null ? _ref2.children : void 0) != null ? _ref1 : (_ref3 = this.plugin) != null ? _ref3.topLevel : void 0) != null ? _ref[this.indexInParent() - 1] : void 0;
    };

    Group.prototype.nextSibling = function() {
      var _ref, _ref1, _ref2, _ref3;
      return (_ref = (_ref1 = (_ref2 = this.parent) != null ? _ref2.children : void 0) != null ? _ref1 : (_ref3 = this.plugin) != null ? _ref3.topLevel : void 0) != null ? _ref[this.indexInParent() + 1] : void 0;
    };

    Group.prototype.contentsChanged = function(propagate, firstTime) {
      var _ref, _ref1;
      if (propagate == null) {
        propagate = true;
      }
      if (firstTime == null) {
        firstTime = false;
      }
      if ((_ref = this.type()) != null) {
        if (typeof _ref.contentsChanged === "function") {
          _ref.contentsChanged(this, firstTime);
        }
      }
      if (propagate) {
        return (_ref1 = this.parent) != null ? _ref1.contentsChanged(true) : void 0;
      }
    };

    Group.prototype.toJSON = function() {
      var attr, child, data, _i, _len, _ref, _ref1, _ref2;
      data = {};
      _ref = this.open.attributes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attr = _ref[_i];
        if (attr.nodeName.slice(0, 6) === 'data-' && attr.nodeName.slice(0, 10) !== 'data-mce-') {
          try {
            data[attr.nodeName] = JSON.parse(attr.nodeValue)[0];
          } catch (_error) {}
        }
      }
      return {
        id: this.id(),
        typeName: this.typeName(),
        deleted: this.deleted,
        text: this.contentAsText(),
        html: this.contentAsHTML(),
        parent: (_ref1 = (_ref2 = this.parent) != null ? _ref2.id() : void 0) != null ? _ref1 : null,
        children: (function() {
          var _j, _len1, _ref3, _ref4, _ref5, _results;
          _ref4 = (_ref3 = this.children) != null ? _ref3 : [];
          _results = [];
          for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
            child = _ref4[_j];
            _results.push((_ref5 = child != null ? child.id() : void 0) != null ? _ref5 : null);
          }
          return _results;
        }).call(this),
        data: data
      };
    };

    return Group;

  })();

  window.Group = Group;

  Groups = (function() {
    var isScanning;

    function Groups(editor) {
      this.editor = editor;
      this.drawGroups = __bind(this.drawGroups, this);
      this.grouperIndexOfRangeEndpoint = __bind(this.grouperIndexOfRangeEndpoint, this);
      this.groupsTouchingRange = __bind(this.groupsTouchingRange, this);
      this.rangeChanged = __bind(this.rangeChanged, this);
      this.groupAboveSelection = __bind(this.groupAboveSelection, this);
      this.groupAboveCursor = __bind(this.groupAboveCursor, this);
      this.groupAboveNode = __bind(this.groupAboveNode, this);
      this.grouperToGroup = __bind(this.grouperToGroup, this);
      this.ids = __bind(this.ids, this);
      this.registerGroup = __bind(this.registerGroup, this);
      this.scanDocument = __bind(this.scanDocument, this);
      this.enableScanning = __bind(this.enableScanning, this);
      this.disableScanning = __bind(this.disableScanning, this);
      this.hideOrShowGroupers = __bind(this.hideOrShowGroupers, this);
      this.allGroupers = __bind(this.allGroupers, this);
      this.groupCurrentSelection = __bind(this.groupCurrentSelection, this);
      this.updateButtonsAndMenuItems = __bind(this.updateButtonsAndMenuItems, this);
      this.addGroupType = __bind(this.addGroupType, this);
      this.setUsedID = __bind(this.setUsedID, this);
      this.addFreeId = __bind(this.addFreeId, this);
      this.nextFreeId = __bind(this.nextFreeId, this);
      this.groupTypes = {};
      this.topLevel = [];
      this.freeIds = [0];
      this.editor.Overlay.addDrawHandler(this.drawGroups);
    }

    Groups.prototype.nextFreeId = function() {
      if (this.freeIds.length > 1) {
        return this.freeIds.shift();
      } else {
        return this.freeIds[0]++;
      }
    };

    Groups.prototype.addFreeId = function(id) {
      if (id < this.freeIds[this.freeIds.length - 1]) {
        this.freeIds.push(id);
        return this.freeIds.sort(function(a, b) {
          return a - b;
        });
      }
    };

    Groups.prototype.setUsedID = function(id) {
      var i, last;
      last = this.freeIds[this.freeIds.length - 1];
      while (last < id) {
        this.freeIds.push(++last);
      }
      i = this.freeIds.indexOf(id);
      this.freeIds.splice(i, 1);
      if (i === this.freeIds.length) {
        return this.freeIds.push(id + 1);
      }
    };

    Groups.prototype.addGroupType = function(name, data) {
      var blob, buttonData, key, menuData, n, plugin, _ref;
      if (data == null) {
        data = {};
      }
      name = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = name.length; _i < _len; _i++) {
          n = name[_i];
          if (/[a-zA-Z_-]/.test(n)) {
            _results.push(n);
          }
        }
        return _results;
      })()).join('');
      this.groupTypes[name] = data;
      if (data.hasOwnProperty('text')) {
        plugin = this;
        if (data.imageHTML != null) {
          data.image = objectURLForBlob(svgBlobForHTML(data.imageHTML, createStyleString()));
        }
        if (data.openImageHTML != null) {
          blob = svgBlobForHTML(data.openImageHTML, createStyleString());
          data.openImage = objectURLForBlob(blob);
          base64URLForBlob(blob, function(result) {
            return data.openImage = result;
          });
        }
        if (data.closeImageHTML != null) {
          blob = svgBlobForHTML(data.closeImageHTML, createStyleString());
          data.closeImage = objectURLForBlob(blob);
          base64URLForBlob(blob, function(result) {
            return data.closeImage = result;
          });
        }
        menuData = {
          text: data.text,
          context: (_ref = data.context) != null ? _ref : 'Insert',
          onclick: (function(_this) {
            return function() {
              return _this.groupCurrentSelection(name);
            };
          })(this),
          onPostRender: function() {
            plugin.groupTypes[name].menuItem = this;
            return plugin.updateButtonsAndMenuItems();
          }
        };
        if (data.shortcut != null) {
          menuData.shortcut = data.shortcut;
        }
        if (data.icon != null) {
          menuData.icon = data.icon;
        }
        this.editor.addMenuItem(name, menuData);
        buttonData = {
          tooltip: data.tooltip,
          onclick: (function(_this) {
            return function() {
              return _this.groupCurrentSelection(name);
            };
          })(this),
          onPostRender: function() {
            plugin.groupTypes[name].button = this;
            return plugin.updateButtonsAndMenuItems();
          }
        };
        key = data.image != null ? 'image' : data.icon != null ? 'icon' : 'text';
        buttonData[key] = data[key];
        return this.editor.addButton(name, buttonData);
      }
    };

    Groups.prototype.updateButtonsAndMenuItems = function() {
      var inSameGroup, left, name, right, type, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;
      left = (_ref = this.editor) != null ? (_ref1 = _ref.selection) != null ? (_ref2 = _ref1.getRng()) != null ? _ref2.cloneRange() : void 0 : void 0 : void 0;
      if (!left) {
        return;
      }
      right = left.cloneRange();
      left.collapse(true);
      right.collapse(false);
      inSameGroup = this.groupAboveCursor(left) === this.groupAboveCursor(right);
      _ref3 = this.groupTypes;
      _results = [];
      for (name in _ref3) {
        if (!__hasProp.call(_ref3, name)) continue;
        type = _ref3[name];
        if (type != null) {
          if ((_ref4 = type.button) != null) {
            _ref4.disabled(!inSameGroup);
          }
        }
        _results.push(type != null ? (_ref5 = type.menuItem) != null ? _ref5.disabled(!inSameGroup) : void 0 : void 0);
      }
      return _results;
    };

    Groups.prototype.groupCurrentSelection = function(type) {
      var close, content, cursor, hide, id, leftNode, leftPos, newGroup, open, range, rightNode, rightPos, sel, _ref, _ref1, _ref2, _ref3, _ref4;
      if (!this.groupTypes.hasOwnProperty(type)) {
        return;
      }
      hide = ($((_ref = this.allGroupers()) != null ? _ref[0] : void 0)).hasClass('hide');
      id = this.nextFreeId();
      open = grouperHTML(type, 'open', id, hide, this.groupTypes[type].openImage);
      close = grouperHTML(type, 'close', id, hide, this.groupTypes[type].closeImage);
      sel = this.editor.selection;
      if (sel.getStart() === sel.getEnd()) {
        content = this.editor.selection.getContent();
        this.editor.insertContent(open + content + '{$caret}' + close);
        cursor = this.editor.selection.getRng();
        close = (_ref1 = cursor.endContainer.childNodes[cursor.endOffset]) != null ? _ref1 : cursor.endContainer.nextSibling;
        newGroup = this.grouperToGroup(close);
        return (_ref2 = newGroup.parent) != null ? _ref2.contentsChanged() : void 0;
      } else {
        range = sel.getRng();
        leftNode = range.startContainer;
        leftPos = range.startOffset;
        rightNode = range.endContainer;
        rightPos = range.endOffset;
        range.collapse(false);
        sel.setRng(range);
        this.disableScanning();
        this.editor.insertContent('{$caret}' + close);
        range = sel.getRng();
        close = (_ref3 = range.endContainer.childNodes[range.endOffset]) != null ? _ref3 : range.endContainer.nextSibling;
        range.setStart(leftNode, leftPos);
        range.setEnd(leftNode, leftPos);
        sel.setRng(range);
        this.editor.insertContent(open);
        this.enableScanning();
        this.editor.selection.select(close);
        this.editor.selection.collapse(true);
        newGroup = this.grouperToGroup(close);
        return (_ref4 = newGroup.parent) != null ? _ref4.contentsChanged() : void 0;
      }
    };

    Groups.prototype.allGroupers = function() {
      return this.editor.getDoc().getElementsByClassName('grouper');
    };

    Groups.prototype.hideOrShowGroupers = function() {
      var groupers, _ref;
      groupers = $(this.allGroupers());
      if (($(groupers != null ? groupers[0] : void 0)).hasClass('hide')) {
        groupers.removeClass('hide');
      } else {
        groupers.addClass('hide');
      }
      groupers.filter('.decorate').each((function(_this) {
        return function(index, grouper) {
          return _this.grouperToGroup(grouper).updateGrouper(grouper);
        };
      })(this));
      if ((_ref = this.editor.Overlay) != null) {
        _ref.redrawContents();
      }
      return this.editor.focus();
    };

    Groups.prototype.disableScanning = function() {
      return this.scanLocks = (this.scanLocks != null ? this.scanLocks : this.scanLocks = 0) + 1;
    };

    Groups.prototype.enableScanning = function() {
      var _ref;
      this.scanLocks = Math.max(((_ref = this.scanLocks) != null ? _ref : 0) - 1, 0);
      if (this.scanLocks === 0) {
        return this.scanDocument();
      }
    };

    isScanning = false;

    Groups.prototype.scanDocument = function() {
      var a, after, becameFree, before, child, count, deleted, gpStack, group, groupData, grouper, groupers, id, index, info, newGroup, usedIds, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;
      if (this.scanLocks > 0) {
        return;
      }
      if (isScanning) {
        return setTimeout(((function(_this) {
          return function() {
            return _this.scanDocument;
          };
        })(this)), 0);
      }
      isScanning = true;
      groupers = Array.prototype.slice.apply(this.allGroupers());
      gpStack = [];
      usedIds = [];
      this.topLevel = [];
      before = this.freeIds.slice(0);
      index = function(id) {
        var gp, i, _i, _len;
        for (i = _i = 0, _len = gpStack.length; _i < _len; i = ++_i) {
          gp = gpStack[i];
          if (gp.id === id) {
            return i;
          }
        }
        return -1;
      };
      for (_i = 0, _len = groupers.length; _i < _len; _i++) {
        grouper = groupers[_i];
        if ((info = grouperInfo(grouper)) == null) {
          ($(grouper)).remove();
        } else if (info.openOrClose === 'open') {
          gpStack.unshift({
            id: info.id,
            grouper: grouper,
            children: []
          });
        } else {
          if (index(info.id) === -1) {
            ($(grouper)).remove();
          } else {
            while (gpStack[0].id !== info.id) {
              ($(gpStack.shift().grouper)).remove();
            }
            groupData = gpStack.shift();
            usedIds.push(info.id);
            this.registerGroup(groupData.grouper, grouper);
            newGroup = this[info.id];
            newGroup.children = groupData.children;
            _ref = newGroup.children;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              child = _ref[_j];
              child.parent = newGroup;
            }
            if (gpStack.length > 0) {
              gpStack[0].children.push(newGroup);
            } else {
              this.topLevel.push(newGroup);
              newGroup.parent = null;
            }
          }
        }
      }
      while (gpStack.length > 0) {
        ($(gpStack.shift().grouper)).remove();
      }
      usedIds.sort(function(a, b) {
        return a - b;
      });
      count = 0;
      this.freeIds = [];
      while (usedIds.length > 0) {
        if (count === usedIds[0]) {
          usedIds.shift();
        } else {
          this.freeIds.push(count);
        }
        count++;
        if (count > 20) {
          break;
        }
      }
      this.freeIds.push(count);
      after = this.freeIds.slice(0);
      while (before[before.length - 1] < after[after.length - 1]) {
        before.push(before[before.length - 1] + 1);
      }
      while (after[after.length - 1] < before[before.length - 1]) {
        after.push(after[after.length - 1] + 1);
      }
      becameFree = (function() {
        var _k, _len2, _results;
        _results = [];
        for (_k = 0, _len2 = after.length; _k < _len2; _k++) {
          a = after[_k];
          if (__indexOf.call(before, a) < 0) {
            _results.push(a);
          }
        }
        return _results;
      })();
      deleted = [];
      for (_k = 0, _len2 = becameFree.length; _k < _len2; _k++) {
        id = becameFree[_k];
        deleted.push(this[id]);
        if ((_ref1 = this[id]) != null) {
          _ref1.deleted = true;
        }
        delete this[id];
      }
      for (_l = 0, _len3 = deleted.length; _l < _len3; _l++) {
        group = deleted[_l];
        if (group != null) {
          if ((_ref2 = group.type()) != null) {
            if (typeof _ref2.deleted === "function") {
              _ref2.deleted(group);
            }
          }
        }
      }
      delete this.idsCache;
      setTimeout((function(_this) {
        return function() {
          var _ref3;
          if ((_ref3 = _this.editor.Overlay) != null) {
            _ref3.redrawContents();
          }
          return _this.updateButtonsAndMenuItems();
        };
      })(this), 0);
      return isScanning = false;
    };

    Groups.prototype.registerGroup = function(open, close) {
      var cached, id;
      cached = this[id = grouperInfo(open).id];
      if ((cached != null ? cached.open : void 0) !== open || (cached != null ? cached.close : void 0) !== close) {
        this[id] = new Group(open, close, this);
      }
      return id;
    };

    Groups.prototype.ids = function() {
      var group, recur, _i, _len, _ref;
      if (this.idsCache == null) {
        this.idsCache = [];
        recur = (function(_this) {
          return function(g) {
            var child, _i, _len, _ref, _results;
            _this.idsCache.push(g.id());
            _ref = g.children;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              child = _ref[_i];
              _results.push(recur(child));
            }
            return _results;
          };
        })(this);
        _ref = this.topLevel;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          recur(group);
        }
      }
      return this.idsCache;
    };

    Groups.prototype.grouperToGroup = function(grouper) {
      var id, _ref;
      if ((id = (_ref = grouperInfo(grouper)) != null ? _ref.id : void 0) != null) {
        return this[id];
      } else {
        return null;
      }
    };

    Groups.prototype.groupAboveNode = function(node) {
      var all, group, left, less, middle, right;
      if ((all = this.allGroupers()).length === 0) {
        return null;
      }
      less = function(a, b) {
        return Node.DOCUMENT_POSITION_FOLLOWING & a.compareDocumentPosition(b);
      };
      left = {
        index: 0,
        grouper: all[0],
        leftOfNode: true
      };
      if (left.grouper === node) {
        return this.grouperToGroup(left.grouper);
      }
      if (!less(left.grouper, node)) {
        return null;
      }
      right = {
        index: all.length - 1,
        grouper: all[all.length - 1]
      };
      if (right.grouper === node) {
        return this.grouperToGroup(right.grouper);
      }
      if (less(right.grouper, node)) {
        return null;
      }
      while (true) {
        if (left.grouper === node) {
          return this.grouperToGroup(left.grouper);
        }
        if (right.grouper === node) {
          return this.grouperToGroup(right.grouper);
        }
        if (left.index + 1 === right.index) {
          if (!(group = this.grouperToGroup(left.grouper))) {
            return null;
          }
          if (left.grouper === group.open) {
            return group;
          } else {
            return group.parent;
          }
        }
        middle = Math.floor((left.index + right.index) / 2);
        if (less(all[middle], node)) {
          left = {
            index: middle,
            grouper: all[middle],
            leftOfNode: true
          };
        } else {
          right = {
            index: middle,
            grouper: all[middle],
            leftOfNode: false
          };
        }
      }
    };

    Groups.prototype.groupAboveCursor = function(cursor) {
      var elementAfter, elementBefore, itsGroup;
      if (cursor.startContainer instanceof this.editor.getWin().Text) {
        return this.groupAboveNode(cursor.startContainer);
      }
      if (cursor.startContainer.childNodes.length > cursor.startOffset) {
        elementAfter = cursor.startContainer.childNodes[cursor.startOffset];
        itsGroup = this.groupAboveNode(elementAfter);
        if ((itsGroup != null ? itsGroup.open : void 0) === elementAfter) {
          return itsGroup.parent;
        } else {
          return itsGroup;
        }
      }
      if (cursor.startContainer.childNodes.length > 0) {
        elementBefore = cursor.startContainer.childNodes[cursor.startOffset - 1];
        itsGroup = this.groupAboveNode(elementBefore);
        if ((itsGroup != null ? itsGroup.close : void 0) === elementBefore) {
          return itsGroup.parent;
        } else {
          return itsGroup;
        }
      }
      return this.groupAboveNode(cursor.startContainer);
    };

    Groups.prototype.groupAboveSelection = function(range) {
      var left, leftChain, result, right, rightChain;
      left = range.cloneRange();
      left.collapse(true);
      left = this.groupAboveCursor(left);
      leftChain = [];
      while (left != null) {
        leftChain.unshift(left);
        left = left.parent;
      }
      right = range.cloneRange();
      right.collapse(false);
      right = this.groupAboveCursor(right);
      rightChain = [];
      while (right != null) {
        rightChain.unshift(right);
        right = right.parent;
      }
      result = null;
      while (leftChain.length > 0 && rightChain.length > 0 && leftChain[0] === rightChain[0]) {
        result = leftChain.shift();
        rightChain.shift();
      }
      return result;
    };

    Groups.prototype.rangeChanged = function(range) {
      var group, _i, _len, _ref, _results;
      _ref = this.groupsTouchingRange(range);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        group = _ref[_i];
        _results.push(group.contentsChanged(false));
      }
      return _results;
    };

    Groups.prototype.groupsTouchingRange = function(range) {
      var all, firstInRange, group, index, lastInRange, maybeOneMore, node, result, stack, _i, _ref;
      if ((all = this.allGroupers()).length === 0) {
        return [];
      }
      firstInRange = 1 + this.grouperIndexOfRangeEndpoint(range, true, all);
      lastInRange = this.grouperIndexOfRangeEndpoint(range, false, all);
      if (firstInRange > lastInRange) {
        node = range.startContainer;
        if (node instanceof this.editor.getWin().Element && range.startOffset < node.childNodes.length) {
          node = node.childNodes[range.startOffset];
        }
        group = this.groupAboveNode(node);
        result = group ? group.open === node ? group.parent ? [group.parent] : [] : [group] : [];
        while (maybeOneMore = (_ref = result[result.length - 1]) != null ? _ref.parent : void 0) {
          result.push(maybeOneMore);
        }
        return result;
      }
      stack = [];
      result = [];
      for (index = _i = firstInRange; firstInRange <= lastInRange ? _i <= lastInRange : _i >= lastInRange; index = firstInRange <= lastInRange ? ++_i : --_i) {
        group = this.grouperToGroup(all[index]);
        if (all[index] === group.open) {
          stack.push(group);
        } else {
          result.push(group);
          stack.pop();
        }
      }
      while (stack.length > 0) {
        result.push(stack.pop());
      }
      while (maybeOneMore = result[result.length - 1].parent) {
        result.push(maybeOneMore);
      }
      return result;
    };

    Groups.prototype.grouperIndexOfRangeEndpoint = function(range, left, all) {
      var endpoint, isLeftOfEndpoint, middle, right;
      if ((all != null ? all : all = this.allGroupers()).length === 0) {
        return -1;
      }
      endpoint = left ? Range.END_TO_START : Range.END_TO_END;
      isLeftOfEndpoint = (function(_this) {
        return function(grouper) {
          var grouperRange;
          grouperRange = _this.editor.getDoc().createRange();
          grouperRange.selectNode(grouper);
          return range.compareBoundaryPoints(endpoint, grouperRange) > -1;
        };
      })(this);
      left = 0;
      if (!isLeftOfEndpoint(all[left])) {
        return -1;
      }
      right = all.length - 1;
      if (isLeftOfEndpoint(all[right])) {
        return right;
      }
      while (true) {
        if (left + 1 === right) {
          return left;
        }
        middle = Math.floor((left + right) / 2);
        if (isLeftOfEndpoint(all[middle])) {
          left = middle;
        } else {
          right = middle;
        }
      }
    };

    Groups.prototype.drawGroups = function(canvas, context) {
      var bodyStyle, close, color, group, i, index, leftMar, moveBy, old, onSameLine, open, pad, padStep, radius, rect, rects, rightMar, size, tag, tagString, tags, tagsToDraw, type, x1, x2, y1, y2, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
      this.bubbleTags = [];
      if (this.scanLocks > 0) {
        return;
      }
      group = this.groupAboveSelection(this.editor.selection.getRng());
      bodyStyle = null;
      pad = 3;
      padStep = 2;
      radius = 4;
      tags = [];
      while (group) {
        type = group.type();
        color = (_ref = type != null ? type.color : void 0) != null ? _ref : '#444444';
        rects = (_ref1 = group.outerRange()) != null ? _ref1.getClientRects() : void 0;
        if (rects == null) {
          setTimeout(((function(_this) {
            return function() {
              var _ref2;
              return (_ref2 = _this.editor.Overlay) != null ? _ref2.redrawContents() : void 0;
            };
          })(this)), 100);
          return;
        }
        rects = (function() {
          var _i, _ref2, _results;
          _results = [];
          for (i = _i = 0, _ref2 = rects.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
            _results.push(rects[i]);
          }
          return _results;
        })();
        open = rects[0];
        open = {
          top: open.top,
          left: open.left,
          right: open.right,
          bottom: open.bottom
        };
        close = rects[rects.length - 1];
        close = {
          top: close.top,
          left: close.left,
          right: close.right,
          bottom: close.bottom
        };
        onSameLine = true;
        for (index = _i = 0, _len = rects.length; _i < _len; index = ++_i) {
          rect = rects[index];
          open.top = Math.min(open.top, rect.top);
          close.bottom = Math.max(close.bottom, rect.bottom);
          if (rect.left < open.left) {
            onSameLine = false;
          }
        }
        if (onSameLine) {
          close.top = open.top;
          open.bottom = close.bottom;
        }
        if ((open.top === open.bottom || close.top === close.bottom || open.left === open.right || close.left === close.right) && !($(group.open)).hasClass('hide')) {
          setTimeout(((function(_this) {
            return function() {
              var _ref2;
              return (_ref2 = _this.editor.Overlay) != null ? _ref2.redrawContents() : void 0;
            };
          })(this)), 100);
          return;
        }
        x1 = open.left - pad / 3;
        y1 = open.top - pad;
        x2 = close.right + pad / 3;
        y2 = close.bottom + pad;
        if (tagString = type != null ? typeof type.tagContents === "function" ? type.tagContents(group) : void 0 : void 0) {
          tags.push({
            content: tagString,
            corner: {
              x: x1,
              y: y1
            },
            color: color,
            style: createFontStyleString(group.open),
            group: group
          });
        }
        context.fillStyle = context.strokeStyle = color;
        if (open.top === close.top && open.bottom === close.bottom) {
          context.roundedRect(x1, y1, x2, y2, radius);
        } else {
          if (bodyStyle == null) {
            bodyStyle = getComputedStyle(this.editor.getBody());
            leftMar = parseInt(bodyStyle['margin-left']);
            rightMar = parseInt(bodyStyle['margin-right']);
          }
          context.roundedZone(x1, y1, x2, y2, open.bottom, close.top, leftMar, rightMar, radius);
        }
        context.globalAlpha = 1.0;
        context.lineWidth = 1.5;
        context.stroke();
        context.globalAlpha = 0.3;
        context.fill();
        group = group.parent;
        pad += padStep;
      }
      tagsToDraw = [];
      while (tags.length > 0) {
        tag = tags.shift();
        context.font = tag.font;
        if (!(size = context.measureHTML(tag.content, tag.style))) {
          setTimeout(((function(_this) {
            return function() {
              var _ref2;
              return (_ref2 = _this.editor.Overlay) != null ? _ref2.redrawContents() : void 0;
            };
          })(this)), 10);
          return;
        }
        x1 = tag.corner.x - padStep;
        y1 = tag.corner.y - size.height - 2 * padStep;
        x2 = x1 + 2 * padStep + size.width;
        y2 = tag.corner.y;
        for (_j = 0, _len1 = tagsToDraw.length; _j < _len1; _j++) {
          old = tagsToDraw[_j];
          if (rectanglesCollide(x1, y1, x2, y2, old.x1, old.y1, old.x2, old.y2)) {
            moveBy = old.y1 - y2;
            y1 += moveBy;
            y2 += moveBy;
          }
        }
        y2 = tag.corner.y;
        _ref2 = [x1, y1, x2, y2], tag.x1 = _ref2[0], tag.y1 = _ref2[1], tag.x2 = _ref2[2], tag.y2 = _ref2[3];
        tagsToDraw.unshift(tag);
      }
      _results = [];
      for (_k = 0, _len2 = tagsToDraw.length; _k < _len2; _k++) {
        tag = tagsToDraw[_k];
        context.roundedRect(tag.x1, tag.y1, tag.x2, tag.y2, radius);
        context.globalAlpha = 1.0;
        context.fillStyle = '#ffffff';
        context.fill();
        context.lineWidth = 1.5;
        context.strokeStyle = tag.color;
        context.stroke();
        context.globalAlpha = 0.7;
        context.fillStyle = tag.color;
        context.fill();
        context.fillStyle = '#000000';
        context.globalAlpha = 1.0;
        context.drawHTML(tag.content, tag.x1 + padStep, tag.y1, tag.style);
        _results.push(this.bubbleTags.unshift(tag));
      }
      return _results;
    };

    return Groups;

  })();

  tinymce.PluginManager.add('groups', function(editor, url) {
    var type, _i, _len, _ref;
    editor.Groups = new Groups(editor);
    editor.on('init', function(event) {
      return editor.dom.loadCSS('groupsplugin.css');
    });
    _ref = editor.settings.groupTypes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      type = _ref[_i];
      editor.Groups.addGroupType(type.name, type);
    }
    editor.addMenuItem('hideshowgroups', {
      text: 'Hide/show groups',
      context: 'View',
      onclick: function() {
        return editor.Groups.hideOrShowGroupers();
      }
    });
    editor.on('change SetContent', function(event) {
      var orig, range, _ref1;
      editor.Groups.scanDocument();
      if (event != null ? (_ref1 = event.level) != null ? _ref1.bookmark : void 0 : void 0) {
        orig = editor.selection.getBookmark();
        editor.selection.moveToBookmark(event.level.bookmark);
        range = editor.selection.getRng();
        editor.selection.moveToBookmark(orig);
        return editor.Groups.rangeChanged(range);
      }
    });
    editor.on('KeyUp', function(event) {
      var modifiers, movements, _ref1, _ref2;
      movements = [33, 34, 35, 36, 37, 38, 39, 40];
      modifiers = [16, 17, 18, 91];
      if ((_ref1 = event.keyCode, __indexOf.call(movements, _ref1) >= 0) || (_ref2 = event.keyCode, __indexOf.call(modifiers, _ref2) >= 0)) {
        return;
      }
      editor.Groups.scanDocument();
      return editor.Groups.rangeChanged(editor.selection.getRng());
    });
    editor.on('NodeChange', function(event) {
      return editor.Groups.updateButtonsAndMenuItems();
    });
    editor.on('contextMenu', function(event) {
      var contextmenu, group, item, items, menu, name, newItems, node, pos, x, y, _j, _len1, _ref1, _ref2;
      event.preventDefault();
      x = event.clientX;
      y = event.clientY;
      if (node = editor.getDoc().nodeFromPoint(x, y)) {
        group = editor.Groups.groupAboveNode(node);
      }
      contextmenu = editor.settings.contextmenu || 'link image inserttable | cell row column deletetable';
      items = [];
      _ref1 = contextmenu.split(/[ ,]/);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        name = _ref1[_j];
        item = editor.menuItems[name];
        if (name === '|') {
          item = {
            text: name
          };
        }
        if (item) {
          item.shortcut = '';
          items.push(item);
        }
      }
      if (newItems = group != null ? (_ref2 = group.type()) != null ? _ref2.contextMenuItems(group) : void 0 : void 0) {
        items.push({
          text: '|'
        });
        items = items.concat(newItems);
      }
      menu = new tinymce.ui.Menu({
        items: items,
        context: 'contextmenu'
      }).addClass('contextmenu').renderTo();
      editor.on('remove', function() {
        menu.remove();
        return menu = null;
      });
      pos = ($(editor.getContentAreaContainer())).position();
      return menu.moveTo(x + pos.left, y + pos.top);
    });
    return editor.on('mousedown', function(event) {
      var menu, menuItems, pos, tag, x, y, _j, _len1, _ref1, _ref2, _ref3, _results;
      x = event.clientX;
      y = event.clientY;
      _ref1 = editor.Groups.bubbleTags;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        tag = _ref1[_j];
        if ((tag.x1 < x && x < tag.x2) && (tag.y1 < y && y < tag.y2)) {
          menuItems = (_ref2 = tag.group) != null ? (_ref3 = _ref2.type()) != null ? _ref3.tagMenuItems(tag.group) : void 0 : void 0;
          if (menuItems == null) {
            menuItems = [
              {
                text: 'no actions available',
                disabled: true
              }
            ];
          }
          menu = new tinymce.ui.Menu({
            items: menuItems,
            context: 'contextmenu'
          }).addClass('contextmenu').renderTo();
          editor.on('remove', function() {
            menu.remove();
            return menu = null;
          });
          pos = ($(editor.getContentAreaContainer())).position();
          menu.moveTo(x + pos.left, y + pos.top);
          event.preventDefault();
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  });

  LoadSave = (function() {
    LoadSave.prototype.appName = null;

    LoadSave.setAppName = function(newname) {
      var instance, _i, _len, _ref, _results;
      if (newname == null) {
        newname = null;
      }
      LoadSave.prototype.appName = newname;
      _ref = LoadSave.prototype.instances;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        instance = _ref[_i];
        _results.push(instance.setAppName(newname));
      }
      return _results;
    };

    LoadSave.prototype.instances = [];

    function LoadSave(editor) {
      var control;
      this.editor = editor;
      this.manageFiles = __bind(this.manageFiles, this);
      this.handleOpen = __bind(this.handleOpen, this);
      this.tryToOpen = __bind(this.tryToOpen, this);
      this.load = __bind(this.load, this);
      this.tryToSave = __bind(this.tryToSave, this);
      this.save = __bind(this.save, this);
      this.tryToClear = __bind(this.tryToClear, this);
      this.clear = __bind(this.clear, this);
      this.setFileSystem = __bind(this.setFileSystem, this);
      this.setAppName = __bind(this.setAppName, this);
      this.setFilepath = __bind(this.setFilepath, this);
      this.setFilename = __bind(this.setFilename, this);
      this.setDocumentDirty = __bind(this.setDocumentDirty, this);
      this.recomputePageTitle = __bind(this.recomputePageTitle, this);
      this.setAppName(LoadSave.prototype.appName);
      this.setFileSystem(this.appName);
      this.setFilepath(FileSystem.prototype.pathSeparator);
      setTimeout(((function(_this) {
        return function() {
          return _this.clear();
        };
      })(this)), 0);
      this.saveMetaData = this.loadMetaData = null;
      this.editor.on('change', (function(_this) {
        return function(event) {
          return _this.setDocumentDirty(true);
        };
      })(this));
      control = (function(_this) {
        return function(name, data) {
          var buttonData, key;
          buttonData = {
            icon: data.icon,
            shortcut: data.shortcut,
            onclick: data.onclick,
            tooltip: data.tooltip
          };
          key = data.icon != null ? 'icon' : 'text';
          buttonData[key] = data[key];
          _this.editor.addButton(name, buttonData);
          return _this.editor.addMenuItem(name, data);
        };
      })(this);
      control('newfile', {
        text: 'New',
        icon: 'newdocument',
        context: 'file',
        shortcut: 'ctrl+N',
        tooltip: 'New file',
        onclick: (function(_this) {
          return function() {
            return _this.tryToClear();
          };
        })(this)
      });
      control('savefile', {
        text: 'Save',
        icon: 'save',
        context: 'file',
        shortcut: 'ctrl+S',
        tooltip: 'Save file',
        onclick: (function(_this) {
          return function() {
            return _this.tryToSave();
          };
        })(this)
      });
      this.editor.addMenuItem('saveas', {
        text: 'Save as...',
        context: 'file',
        shortcut: 'ctrl+shift+S',
        onclick: (function(_this) {
          return function() {
            return _this.tryToSave(null, '');
          };
        })(this)
      });
      control('openfile', {
        text: 'Open...',
        icon: 'browse',
        context: 'file',
        shortcut: 'ctrl+O',
        tooltip: 'Open file...',
        onclick: (function(_this) {
          return function() {
            return _this.handleOpen();
          };
        })(this)
      });
      this.editor.addMenuItem('managefiles', {
        text: 'Manage files...',
        context: 'file',
        onclick: (function(_this) {
          return function() {
            return _this.manageFiles();
          };
        })(this)
      });
      LoadSave.prototype.instances.push(this);
    }

    LoadSave.prototype.recomputePageTitle = function() {
      return document.title = "" + (this.appName ? this.appName + ': ' : '') + " " + (this.filename || '(untitled)') + " " + (this.documentDirty ? '*' : '');
    };

    LoadSave.prototype.setDocumentDirty = function(setting) {
      if (setting == null) {
        setting = true;
      }
      this.documentDirty = setting;
      return this.recomputePageTitle();
    };

    LoadSave.prototype.setFilename = function(newname) {
      if (newname == null) {
        newname = null;
      }
      this.filename = newname;
      return this.recomputePageTitle();
    };

    LoadSave.prototype.setFilepath = function(newpath) {
      if (newpath == null) {
        newpath = null;
      }
      return this.filepath = newpath;
    };

    LoadSave.prototype.setAppName = function(newname) {
      var mustAlsoUpdateFileSystem;
      if (newname == null) {
        newname = null;
      }
      mustAlsoUpdateFileSystem = this.appName === this.fileSystem;
      this.appName = newname;
      if (mustAlsoUpdateFileSystem) {
        this.fileSystem = this.appName;
      }
      return this.recomputePageTitle();
    };

    LoadSave.prototype.setFileSystem = function(newname) {
      if (newname == null) {
        newname = this.appName;
      }
      return this.fileSystem = newname;
    };

    LoadSave.prototype.clear = function() {
      this.editor.setContent('');
      this.setDocumentDirty(false);
      return this.setFilename(null);
    };

    LoadSave.prototype.tryToClear = function() {
      if (!this.documentDirty) {
        this.clear();
        this.editor.focus();
        return;
      }
      return this.editor.windowManager.open({
        title: 'Save first?',
        buttons: [
          {
            text: 'Save',
            onclick: (function(_this) {
              return function() {
                _this.tryToSave(function(success) {
                  if (success) {
                    return _this.clear();
                  }
                });
                return _this.editor.windowManager.close();
              };
            })(this)
          }, {
            text: 'Discard',
            onclick: (function(_this) {
              return function() {
                _this.clear();
                return _this.editor.windowManager.close();
              };
            })(this)
          }, {
            text: 'Cancel',
            onclick: (function(_this) {
              return function() {
                return _this.editor.windowManager.close();
              };
            })(this)
          }
        ]
      });
    };

    LoadSave.prototype.save = function() {
      var objectToSave, tmp;
      if (this.filename === null) {
        return;
      }
      tmp = new FileSystem(this.fileSystem);
      tmp.cd(this.filepath);
      objectToSave = [this.editor.getContent(), typeof this.saveMetaData === "function" ? this.saveMetaData() : void 0];
      if (tmp.write(this.filename, objectToSave, true)) {
        return this.setDocumentDirty(false);
      }
    };

    LoadSave.prototype.tryToSave = function(callback, filename) {
      var filepath, refreshDialog, result, saveWouldOverwrite;
      if (filename == null) {
        filename = this.filename;
      }
      if (filename) {
        this.setFilename(filename);
        result = this.save();
        this.editor.focus();
        return typeof callback === "function" ? callback(result) : void 0;
      }
      refreshDialog = function() {
        var button, dialog, _i, _len, _ref, _results;
        dialog = document.getElementsByClassName('mce-window')[0];
        if (!dialog) {
          return;
        }
        _ref = dialog.getElementsByTagName('button');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          button = _ref[_i];
          if (button.textContent === 'Save') {
            if (filename) {
              button.removeAttribute('disabled');
              button.parentNode.style.backgroundImage = null;
              button.parentNode.style.backgroundColor = null;
            } else {
              button.setAttribute('disabled', true);
              button.parentNode.style.backgroundImage = 'none';
              button.parentNode.style.backgroundColor = '#ccc';
            }
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      filename = null;
      this.saveFileNameChangedHandler = function(newname) {
        filename = newname;
        return refreshDialog();
      };
      filepath = null;
      this.changedFolderHandler = function(newfolder) {
        return filepath = newfolder;
      };
      saveWouldOverwrite = (function(_this) {
        return function(filepath, filename) {
          var tmp;
          tmp = new FileSystem(_this.fileSystem);
          tmp.cd(filepath);
          return null !== tmp.type(filename);
        };
      })(this);
      this.buttonClickedHandler = (function(_this) {
        return function() {
          var args, name;
          name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (name === 'Save') {
            if (saveWouldOverwrite(filepath, filename)) {
              if (!confirm("Are you sure you want to overwrite the file " + filename + "?")) {
                _this.tellDialog('setFileBrowserMode', 'save file');
                return;
              }
            }
            _this.setFilepath(filepath);
            _this.setFilename(filename);
            _this.editor.windowManager.close();
            result = _this.save();
            return typeof callback === "function" ? callback(result) : void 0;
          } else if (name === 'Cancel') {
            _this.editor.windowManager.close();
            return typeof callback === "function" ? callback(false) : void 0;
          }
        };
      })(this);
      return this.editor.windowManager.open({
        title: 'Save file...',
        url: 'filedialog/filedialog.html',
        width: 600,
        height: 400,
        buttons: [
          {
            text: 'Save',
            subtype: 'primary',
            onclick: (function(_this) {
              return function() {
                return _this.buttonClickedHandler('Save');
              };
            })(this)
          }, {
            text: 'Cancel',
            onclick: (function(_this) {
              return function() {
                return _this.buttonClickedHandler('Cancel');
              };
            })(this)
          }
        ]
      }, {
        fsName: this.fileSystem,
        mode: 'save file'
      });
    };

    LoadSave.prototype.load = function(filepath, filename) {
      var content, metadata, tmp, _ref;
      if (filename === null) {
        return;
      }
      if (filepath === null) {
        filepath = '.';
      }
      tmp = new FileSystem(this.fileSystem);
      tmp.cd(filepath);
      _ref = tmp.read(filename), content = _ref[0], metadata = _ref[1];
      this.editor.setContent(content);
      this.editor.focus();
      this.setFilepath(filepath);
      this.setFilename(filename);
      this.setDocumentDirty(false);
      if (metadata) {
        return typeof this.loadMetaData === "function" ? this.loadMetaData(metadata) : void 0;
      }
    };

    LoadSave.prototype.tryToOpen = function(callback) {
      var filename, filepath, refreshDialog;
      if (callback == null) {
        callback = (function(_this) {
          return function(p, f) {
            return _this.load(p, f);
          };
        })(this);
      }
      refreshDialog = (function(_this) {
        return function() {
          var button, dialog, _i, _len, _ref, _results;
          dialog = document.getElementsByClassName('mce-window')[0];
          if (!dialog) {
            return;
          }
          _ref = dialog.getElementsByTagName('button');
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            button = _ref[_i];
            if (button.textContent === 'Open') {
              if (filename) {
                button.removeAttribute('disabled');
                button.parentNode.style.backgroundImage = null;
                button.parentNode.style.backgroundColor = null;
              } else {
                button.setAttribute('disabled', true);
                button.parentNode.style.backgroundImage = 'none';
                button.parentNode.style.backgroundColor = '#ccc';
              }
              break;
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
      })(this);
      filename = null;
      this.selectedFileHandler = function(newname) {
        filename = newname;
        return refreshDialog();
      };
      filepath = null;
      this.changedFolderHandler = function(newfolder) {
        return filepath = newfolder;
      };
      this.buttonClickedHandler = (function(_this) {
        return function() {
          var args, name;
          name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (name === 'Open') {
            _this.editor.windowManager.close();
            return typeof callback === "function" ? callback(filepath, filename) : void 0;
          } else if (name === 'Cancel') {
            _this.editor.windowManager.close();
            return typeof callback === "function" ? callback(null, null) : void 0;
          }
        };
      })(this);
      this.editor.windowManager.open({
        title: 'Open file...',
        url: 'filedialog/filedialog.html',
        width: 600,
        height: 400,
        buttons: [
          {
            text: 'Open',
            subtype: 'primary',
            onclick: (function(_this) {
              return function() {
                return _this.buttonClickedHandler('Open');
              };
            })(this)
          }, {
            text: 'Cancel',
            onclick: (function(_this) {
              return function() {
                return _this.buttonClickedHandler('Cancel');
              };
            })(this)
          }
        ]
      }, {
        fsName: this.fileSystem,
        mode: 'open file'
      });
      return refreshDialog();
    };

    LoadSave.prototype.handleOpen = function() {
      if (!this.documentDirty) {
        return this.tryToOpen();
      }
      return this.editor.windowManager.open({
        title: 'Save first?',
        buttons: [
          {
            text: 'Save',
            onclick: (function(_this) {
              return function() {
                _this.editor.windowManager.close();
                return _this.tryToSave(function(success) {
                  if (success) {
                    return _this.tryToOpen();
                  }
                });
              };
            })(this)
          }, {
            text: 'Discard',
            onclick: (function(_this) {
              return function() {
                _this.editor.windowManager.close();
                return _this.tryToOpen();
              };
            })(this)
          }, {
            text: 'Cancel',
            onclick: (function(_this) {
              return function() {
                return _this.editor.windowManager.close();
              };
            })(this)
          }
        ]
      });
    };

    LoadSave.prototype.tellDialog = function() {
      var args, frame, frames, _i, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      frames = document.getElementsByTagName('iframe');
      for (_i = 0, _len = frames.length; _i < _len; _i++) {
        frame = frames[_i];
        if ('filedialog/filedialog.html' === frame.getAttribute('src')) {
          return frame.contentWindow.postMessage(args, '*');
        }
      }
    };

    LoadSave.prototype.manageFiles = function() {
      return this.editor.windowManager.open({
        title: 'Manage files',
        url: 'filedialog/filedialog.html',
        width: 700,
        height: 500,
        buttons: [
          {
            text: 'New folder',
            onclick: (function(_this) {
              return function() {
                return _this.tellDialog('buttonClicked', 'New folder');
              };
            })(this)
          }, {
            text: 'Done',
            onclick: (function(_this) {
              return function() {
                return _this.editor.windowManager.close();
              };
            })(this)
          }
        ]
      }, {
        fsName: this.fileSystem,
        mode: 'manage files'
      });
    };

    return LoadSave;

  })();

  tinymce.PluginManager.add('loadsave', function(editor, url) {
    return editor.LoadSave = new LoadSave(editor);
  });

  window.onmessage = function(event) {
    var handlerName, instance, _i, _len, _ref;
    handlerName = "" + event.data[0] + "Handler";
    _ref = LoadSave.prototype.instances;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      instance = _ref[_i];
      if (instance.hasOwnProperty(handlerName)) {
        return instance[handlerName].apply(null, event.data.slice(1));
      }
    }
  };

  window.setAppName = function(newname) {
    if (newname == null) {
      newname = null;
    }
    return LoadSave.prototype.appName = newname;
  };

  editor = null;

  setIndexPage = function(URL) {
    return editor.indexURL = URL;
  };

  getIndexPage = function() {
    return editor.indexURL;
  };

  setAPIPage = function(URL) {
    return editor.APIURL = URL;
  };

  getAPIPage = function() {
    return editor.APIURL;
  };

  getPageContent = function(pageName, callback) {
    var xhr;
    xhr = new XMLHttpRequest();
    xhr.addEventListener('load', function() {
      var content, e, json, object;
      json = this.responseText;
      try {
        object = JSON.parse(json);
      } catch (_error) {
        e = _error;
        callback(null, 'Invalid response format.\nShould be JSON:\n' + json);
        return;
      }
      try {
        content = object.query.pages[0].revisions[0].content;
      } catch (_error) {
        e = _error;
        callback(null, 'No such page on wiki.\nRaw reply:\n' + json);
        return;
      }
      return callback(content, null);
    });
    xhr.open('GET', editor.MediaWiki.getAPIPage() + '?action=query&titles=' + encodeURIComponent(pageName) + '&prop=revisions' + '&rvprop=content&rvparse' + '&format=json&formatversion=2');
    xhr.setRequestHeader('Api-User-Agent', 'webLurch application');
    return xhr.send();
  };

  importPage = function(pageName, callback) {
    return editor.MediaWiki.getPageContent(pageName, function(content, error) {
      if (content) {
        editor.setContent(content);
        if (typeof callback === "function") {
          callback(true);
        }
      }
      if (error) {
        alert('Error loading content from wiki:' + error.split('\n')[0]);
        console.log(error);
        return typeof callback === "function" ? callback(false) : void 0;
      }
    });
  };

  login = function(username, password, callback, token) {
    var URL, xhr;
    xhr = new XMLHttpRequest();
    xhr.addEventListener('load', function() {
      var e, json, object, _ref, _ref1, _ref2;
      json = this.responseText;
      try {
        object = JSON.parse(json);
      } catch (_error) {
        e = _error;
        callback(null, 'Invalid JSON response: ' + json);
        return;
      }
      if ((object != null ? (_ref = object.login) != null ? _ref.result : void 0 : void 0) === 'Success') {
        return callback(true, null);
      } else if ((object != null ? (_ref1 = object.login) != null ? _ref1.result : void 0 : void 0) === 'NeedToken') {
        return editor.MediaWiki.login(username, password, callback, object.login.token);
      } else {
        return callback(null, 'Login error of type ' + (object != null ? (_ref2 = object.login) != null ? _ref2.result : void 0 : void 0));
      }
    });
    URL = editor.MediaWiki.getAPIPage() + '?action=login' + '&lgname=' + encodeURIComponent(username) + '&lgpassword=' + encodeURIComponent(password) + '&format=json&formatversion=2';
    if (token) {
      URL += '&lgtoken=' + token;
    }
    xhr.open('POST', URL);
    xhr.setRequestHeader('Api-User-Agent', 'webLurch application');
    return xhr.send();
  };

  exportPage = function(pageName, content, callback) {
    var xhr;
    xhr = new XMLHttpRequest();
    xhr.addEventListener('load', function() {
      var e, json, object, token, xhr2, _ref, _ref1;
      json = this.responseText;
      try {
        object = JSON.parse(json);
      } catch (_error) {
        e = _error;
        callback(null, 'Invalid JSON response: ' + json);
        return;
      }
      if (!(object != null ? (_ref = object.query) != null ? (_ref1 = _ref.tokens) != null ? _ref1.csrftoken : void 0 : void 0 : void 0)) {
        callback(null, 'No token provided: ' + json);
        return;
      }
      xhr2 = new XMLHttpRequest();
      xhr2.addEventListener('load', function() {
        var _ref2;
        json = this.responseText;
        try {
          object = JSON.parse(json);
        } catch (_error) {
          e = _error;
          callback(null, 'Invalid JSON response: ' + json);
          return;
        }
        if ((object != null ? (_ref2 = object.edit) != null ? _ref2.result : void 0 : void 0) !== 'Success') {
          callback(null, 'Edit failed: ' + json);
          return;
        }
        return callback('Success', null);
      });
      content = formatContentForWiki(content);
      xhr2.open('POST', editor.MediaWiki.getAPIPage() + '?action=edit' + '&title=' + encodeURIComponent(pageName) + '&text=' + encodeURIComponent(content) + '&summary=' + encodeURIComponent('posted from Lurch') + '&contentformat=' + encodeURIComponent('text/x-wiki') + '&contentmodel=' + encodeURIComponent('wikitext') + '&format=json&formatversion=2', true);
      token = 'token=' + encodeURIComponent(object.query.tokens.csrftoken);
      xhr2.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
      xhr2.setRequestHeader('Api-User-Agent', 'webLurch application');
      return xhr2.send(token);
    });
    xhr.open('GET', editor.MediaWiki.getAPIPage() + '?action=query&meta=tokens' + '&format=json&formatversion=2');
    xhr.setRequestHeader('Api-User-Agent', 'webLurch application');
    return xhr.send();
  };

  formatContentForWiki = function(editorHTML) {
    var charRE, closeRE, decoder, depth, match, openRE, result, tagName, toReplace;
    result = '';
    depth = 0;
    openRE = /^<([^ >]+)\s*([^>]+)?>/i;
    closeRE = /^<\/([^ >]+)\s*>/i;
    charRE = /^&([a-z0-9]+|#[0-9]+);/i;
    toReplace = ['img', 'span', 'var', 'sup'];
    decoder = document.createElement('div');
    while (editorHTML.length > 0) {
      if (match = closeRE.exec(editorHTML)) {
        tagName = match[1].toLowerCase();
        if (__indexOf.call(toReplace, tagName) >= 0) {
          depth--;
          result += "</htmltag" + depth + ">";
        } else {
          result += match[0];
        }
        editorHTML = editorHTML.slice(match[0].length);
      } else if (match = openRE.exec(editorHTML)) {
        tagName = match[1].toLowerCase();
        if (__indexOf.call(toReplace, tagName) >= 0) {
          result += "<htmltag" + depth + " tagname='" + tagName + "' " + match[2] + ">";
          if (!/\/\s*$/.test(match[2])) {
            depth++;
          }
        } else {
          result += match[0];
        }
        editorHTML = editorHTML.slice(match[0].length);
      } else if (match = charRE.exec(editorHTML)) {
        decoder.innerHTML = match[0];
        result += decoder.textContent;
        editorHTML = editorHTML.slice(match[0].length);
      } else {
        result += editorHTML[0];
        editorHTML = editorHTML.slice(1);
      }
    }
    return result;
  };

  tinymce.PluginManager.add('mediawiki', function(ed, url) {
    return (editor = ed).MediaWiki = {
      setIndexPage: setIndexPage,
      getIndexPage: getIndexPage,
      setAPIPage: setAPIPage,
      getAPIPage: getAPIPage,
      login: login,
      getPageContent: getPageContent,
      importPage: importPage,
      exportPage: exportPage
    };
  });

  Overlay = (function() {
    function Overlay(editor) {
      this.editor = editor;
      this.redrawContents = __bind(this.redrawContents, this);
      this.editor.on('init', (function(_this) {
        return function() {
          _this.container = _this.editor.getContentAreaContainer();
          _this.canvas = document.createElement('canvas');
          ($(_this.container)).after(_this.canvas);
          _this.canvas.style.position = 'absolute';
          _this.canvas.style['background-color'] = 'rgba(0,0,0,0)';
          _this.canvas.style['pointer-events'] = 'none';
          return _this.canvas.style['z-index'] = '10';
        };
      })(this));
      this.drawHandlers = [];
      this.editor.on('NodeChange', this.redrawContents);
      ($(window)).resize(this.redrawContents);
    }

    Overlay.prototype.redrawContents = function(event) {
      var context, doDrawing, e, _i, _len, _ref, _ref1, _results;
      this.positionCanvas();
      if (!(context = (_ref = this.canvas) != null ? _ref.getContext('2d') : void 0)) {
        return;
      }
      this.clearCanvas(context);
      context.translate(0, ($(this.container)).position().top);
      _ref1 = this.drawHandlers;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        doDrawing = _ref1[_i];
        try {
          _results.push(doDrawing(this.canvas, context));
        } catch (_error) {
          e = _error;
          _results.push(console.log("Error in overlay draw function: " + e.stack));
        }
      }
      return _results;
    };

    Overlay.prototype.addDrawHandler = function(drawFunction) {
      return this.drawHandlers.push(drawFunction);
    };

    Overlay.prototype.getEditorFrame = function() {
      var frame, _i, _len, _ref;
      _ref = window.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        if (frame.document === this.editor.getDoc()) {
          return frame;
        }
      }
      return null;
    };

    Overlay.prototype.positionCanvas = function() {
      var can, con;
      con = $(this.container);
      can = $(this.canvas);
      if (con.position() == null) {
        return;
      }
      can.css('top', 0);
      can.css('left', con.position().left);
      can.width(con.width());
      can.height(con.position().top + con.height());
      this.canvas.width = can.width();
      return this.canvas.height = can.height();
    };

    Overlay.prototype.clearCanvas = function(context) {
      return context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };

    return Overlay;

  })();

  tinymce.PluginManager.add('overlay', function(editor, url) {
    editor.Overlay = new Overlay(editor);
    return editor.on('init', function(event) {
      return ($(editor.getWin())).scroll(function() {
        return editor.Overlay.redrawContents();
      });
    });
  });

  plugin = {};

  plugin.addCategory = function(name) {
    return plugin[name] = {
      get: function(key) {
        return window.localStorage.getItem(key);
      },
      set: function(key, value) {
        return window.localStorage.setItem(key, value);
      },
      setup: function(div) {
        return null;
      },
      teardown: function(div) {
        return null;
      },
      showUI: function() {
        return plugin.showUI(name);
      }
    };
  };

  plugin.showUI = function(category) {
    var buttons, categoryTitle, div, wins;
    div = null;
    buttons = [
      {
        type: 'button',
        text: 'Cancel',
        onclick: function(event) {
          return tinymce.activeEditor.windowManager.close();
        }
      }, {
        type: 'button',
        text: 'Save',
        subtype: 'primary',
        onclick: function(event) {
          plugin[category].teardown(div);
          return tinymce.activeEditor.windowManager.close();
        }
      }
    ];
    categoryTitle = category[0].toUpperCase() + category.slice(1).toLowerCase() + ' Settings';
    tinymce.activeEditor.windowManager.open({
      title: categoryTitle,
      url: 'about:blank',
      width: 500,
      height: 400,
      buttons: buttons
    });
    wins = tinymce.activeEditor.windowManager.windows;
    div = wins[wins.length - 1].getEl().getElementsByClassName('mce-container-body')[0];
    div.innerHTML = '';
    return plugin[category].setup(div);
  };

  plugin.UI = {};

  plugin.UI.info = function(name) {
    return plugin.UI.tr("<td style='width: 100%; text-align: center; white-space: normal;' >" + name + "</td>");
  };

  plugin.UI.heading = function(name) {
    return plugin.UI.info("<span style='font-size: 20px;'>" + name + "</span>");
  };

  plugin.UI.readOnly = function(label, data) {
    return plugin.UI.tpair(label, data);
  };

  plugin.UI.text = function(label, id, initial) {
    return plugin.UI.tpair(label, "<input type='text' id='" + id + "' value='" + initial + "' style='border-width: 2px; border-style: inset;'/>");
  };

  plugin.UI.password = function(label, id, initial) {
    return plugin.UI.tpair(label, "<input type='password' id='" + id + "' value='" + initial + "' style='border-width: 2px; border-style: inset;'/>");
  };

  plugin.UI.tr = function(content) {
    return '<table border=0 cellpadding=0 cellspacing=10 style="width: 100%;"><tr style="width: 100%;">' + content + '</tr></table>';
  };

  plugin.UI.tpair = function(left, right) {
    return plugin.UI.tr("<td style='width: 50%; text-align: right;'> <b>" + left + ":</b></td> <td style='width: 50%; text-align: left;'> " + right + "</td>");
  };

  tinymce.PluginManager.add('settings', function(editor, url) {
    return editor.Settings = plugin;
  });

  setAppName('Untitled');

  if (window.groupTypes == null) {
    window.groupTypes = [
      {
        name: 'example',
        text: 'Example group',
        imageHTML: '[',
        openImageHTML: ']',
        closeImageHTML: '[]',
        tooltip: 'Wrap text in a group',
        color: '#666666'
      }
    ];
  }

  if (window.groupToolbarButtons == null) {
    window.groupToolbarButtons = {};
  }

  if (window.groupMenuItems == null) {
    window.groupMenuItems = {};
  }

  if (window.pluginsToLoad == null) {
    window.pluginsToLoad = [];
  }

  if (window.menuBarIcon == null) {
    window.menuBarIcon = {};
  }

  if (window.defaultEditorStyles == null) {
    window.defaultEditorStyles = {
      fontSize: '16px',
      fontFamily: 'Verdana, Arial, Helvetica, sans-serif'
    };
  }

  if (window.helpAboutText == null) {
    window.helpAboutText = 'webLurch\n\nalpha\n\nnot yet intended for non-developer use';
  }

  $(function() {
    var groupTypeNames, p, type;
    editor = document.createElement('textarea');
    editor.setAttribute('id', 'editor');
    document.body.appendChild(editor);
    maybeSetupTestRecorder();
    groupTypeNames = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = groupTypes.length; _i < _len; _i++) {
        type = groupTypes[_i];
        _results.push(type.name);
      }
      return _results;
    })();
    return tinymce.init({
      selector: '#editor',
      auto_focus: 'editor',
      browser_spellcheck: true,
      gecko_spellcheck: true,
      statusbar: false,
      paste_data_images: true,
      plugins: 'advlist table charmap colorpicker image link importcss paste print save searchreplace textcolor fullscreen -loadsave -overlay -groups -equationeditor ' + ((function() {
        var _i, _len, _ref, _results;
        _ref = window.pluginsToLoad;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push("-" + p);
        }
        return _results;
      })()).join(' '),
      object_resizing: ':not(img.grouper)',
      toolbar: ['newfile openfile savefile managefiles | print | undo redo | cut copy paste | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent blockquote | table', 'fontselect styleselect | bold italic underline textcolor subscript superscript removeformat | link unlink | charmap image | spellchecker searchreplace | equationeditor | ' + groupTypeNames.join(' ') + ' | ' + Object.keys(window.groupToolbarButtons).join(' ')],
      menu: {
        file: {
          title: 'File',
          items: 'newfile openfile | savefile saveas | managefiles | print' + moreMenuItems('file')
        },
        edit: {
          title: 'Edit',
          items: 'undo redo | cut copy paste pastetext | selectall' + moreMenuItems('edit')
        },
        insert: {
          title: 'Insert',
          items: 'link media | template hr | me' + moreMenuItems('insert')
        },
        view: {
          title: 'View',
          items: 'visualaid hideshowgroups' + moreMenuItems('view')
        },
        format: {
          title: 'Format',
          items: 'bold italic underline strikethrough superscript subscript | formats | removeformat' + moreMenuItems('format')
        },
        table: {
          title: 'Table',
          items: 'inserttable tableprops deletetable | cell row column' + moreMenuItems('table')
        },
        help: {
          title: 'Help',
          items: 'about website' + moreMenuItems('help')
        }
      },
      contextmenu: 'link image inserttable | cell row column deletetable' + moreMenuItems('contextmenu'),
      groupTypes: groupTypes,
      setup: function(editor) {
        var data, name, _ref, _ref1;
        editor.addMenuItem('about', {
          text: 'About...',
          context: 'help',
          onclick: function() {
            return alert(window.helpAboutText);
          }
        });
        editor.addMenuItem('website', {
          text: 'Lurch website',
          context: 'help',
          onclick: function() {
            return window.open('http://www.lurchmath.org', '_blank');
          }
        });
        _ref = window.groupMenuItems;
        for (name in _ref) {
          if (!__hasProp.call(_ref, name)) continue;
          data = _ref[name];
          editor.addMenuItem(name, data);
        }
        _ref1 = window.groupToolbarButtons;
        for (name in _ref1) {
          if (!__hasProp.call(_ref1, name)) continue;
          data = _ref1[name];
          editor.addButton(name, data);
        }
        return editor.on('init', function() {
          var filemenu, icon, key, value, _ref2, _ref3;
          installDOMUtilitiesIn(editor.getWin());
          _ref2 = window.defaultEditorStyles;
          for (key in _ref2) {
            if (!__hasProp.call(_ref2, key)) continue;
            value = _ref2[key];
            editor.getBody().style[key] = value;
          }
          setTimeout(function() {
            var h, walk, _i, _len, _ref3, _results;
            editor.execCommand('mceFullScreen');
            walk = editor.iframeElement;
            while (walk && walk !== editor.container) {
              if (walk === editor.iframeElement.parentNode) {
                walk.style.height = 'auto';
              } else {
                walk.style.height = '100%';
              }
              walk = walk.parentNode;
            }
            _ref3 = editor.getDoc().getElementsByTagName('html');
            _results = [];
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              h = _ref3[_i];
              _results.push(h.style.height = 'auto');
            }
            return _results;
          }, 0);
          editor.dom.loadCSS('./eqed/mathquill.css');
          if (((_ref3 = window.menuBarIcon) != null ? _ref3.src : void 0) != null) {
            filemenu = (editor.getContainer().getElementsByClassName('mce-menubtn'))[0];
            icon = document.createElement('img');
            icon.setAttribute('src', window.menuBarIcon.src);
            icon.style.width = window.menuBarIcon.width;
            icon.style.height = window.menuBarIcon.height;
            icon.style.padding = window.menuBarIcon.padding;
            filemenu.insertBefore(icon, filemenu.childNodes[0]);
          }
          editor.getBody().addEventListener('focus', function() {
            if (editor.windowManager.getWindows().length !== 0) {
              return editor.windowManager.close();
            }
          });
          return typeof window.afterEditorReady === "function" ? window.afterEditorReady(editor) : void 0;
        });
      }
    });
  });

  moreMenuItems = function(menuName) {
    var k, names;
    names = window.groupMenuItems.hasOwnProperty("" + menuName + "_order") ? window.groupMenuItems["" + menuName + "_order"] : ((function() {
      var _i, _len, _ref, _results;
      _ref = Object.keys(window.groupMenuItems);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        k = _ref[_i];
        if (window.groupMenuItems[k].context === menuName) {
          _results.push(k);
        }
      }
      return _results;
    })()).join(' ');
    if (names.length && names.slice(0, 2) !== '| ') {
      return "| " + names;
    } else {
      return '';
    }
  };

  window.mathQuillToMeaning = function(node) {
    var child, marker, name, result, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
    if (node instanceof Text) {
      return node.textContent;
    }
    result = [];
    _ref = node.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (($(child)).hasClass('selectable') || ($(child)).hasClass('cursor') || /width:0/.test(typeof child.getAttribute === "function" ? child.getAttribute('style') : void 0)) {
        continue;
      }
      result = result.concat(mathQuillToMeaning(child));
    }
    if ((_ref1 = node.tagName) === 'SUP' || _ref1 === 'SUB') {
      name = node.tagName.toLowerCase();
      if (($(node)).hasClass('nthroot')) {
        name = 'nthroot';
      }
      if (result.length > 1) {
        result.unshift('(');
        result.push(')');
      }
      result.unshift(name);
    }
    _ref2 = ['fraction', 'overline', 'overarc'];
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      marker = _ref2[_j];
      if (($(node)).hasClass(marker)) {
        if (result.length > 1) {
          result.unshift('(');
          result.push(')');
        }
        result.unshift(marker);
      }
    }
    _ref3 = ['numerator', 'denominator'];
    for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
      marker = _ref3[_k];
      if (($(node)).hasClass(marker)) {
        if (result.length > 1) {
          result.unshift('(');
          result.push(')');
        }
      }
    }
    if (result.length === 1) {
      return result[0];
    } else {
      return result;
    }
  };

  maybeSetupTestRecorder = function() {
    var installListeners, installed, testwin;
    if (location.search === '?test') {
      testwin = open('./testrecorder.html', 'recording', "status=no, location=no, toolbar=no, menubar=no, left=" + (window.screenX + ($(window)).width()) + ", top=" + window.screenY + ", width=400, height=600");
      if (!testwin) {
        alert('You have asked to run webLurch in test-recording mode, which requires a popup window.  Your browser has blocked the popup window.  Change its settings or allow this popup to use test-recording mode.');
      }
      installed = [];
      return (installListeners = function() {
        var button, e, findAll, notSupported, object, _fn, _i, _j, _len, _len1, _ref, _ref1;
        notSupported = function(whatYouDid) {
          return alert("You " + whatYouDid + ", which the test recorder does not yet support.  The current test has therefore become corrupted, and you should reload this page and start your test again.  You will need to limit yourself to using only supported keys, menu items, and mouse operations.");
        };
        try {
          if (__indexOf.call(installed, 'keypress') < 0) {
            tinymce.activeEditor.on('keypress', function(event) {
              var letter;
              letter = String.fromCharCode(event.keyCode);
              if (/[A-Za-z0-9 ]/.test(letter)) {
                return testwin.editorKeyPress(event.keyCode, event.shiftKey, event.ctrlKey, event.altKey);
              } else {
                return notSupported("pressed the key with code " + event.keyCode);
              }
            });
            installed.push('keypress');
          }
          if (__indexOf.call(installed, 'keyup') < 0) {
            tinymce.activeEditor.on('keyup', function(event) {
              var conversion, ignore, letter, _ref;
              letter = String.fromCharCode(event.keyCode);
              if (/[A-Za-z0-9 ]/.test(letter)) {
                return;
              }
              ignore = [16, 17, 18, 91];
              if (_ref = event.keyCode, __indexOf.call(ignore, _ref) >= 0) {
                return;
              }
              conversion = {
                8: 'backspace',
                13: 'enter',
                35: 'end',
                36: 'home',
                37: 'left',
                38: 'up',
                39: 'right',
                40: 'down',
                46: 'delete'
              };
              if (conversion.hasOwnProperty(event.keyCode)) {
                return testwin.editorKeyPress(conversion[event.keyCode], event.shiftKey, event.ctrlKey, event.altKey);
              } else {
                return notSupported("pressed the key with code " + event.keyCode);
              }
            });
            installed.push('keyup');
          }
          if (__indexOf.call(installed, 'click') < 0) {
            tinymce.activeEditor.on('click', function(event) {
              if (event.shiftKey) {
                return notSupported("shift-clicked");
              } else if (event.ctrlKey) {
                return notSupported("ctrl-clicked");
              } else if (event.altKey) {
                return notSupported("alt-clicked");
              } else {
                return testwin.editorMouseClick(event.clientX, event.clientY);
              }
            });
            installed.push('click');
          }
          findAll = function(type) {
            return Array.prototype.slice.apply(tinymce.activeEditor.theme.panel.find(type));
          };
          if (__indexOf.call(installed, 'buttons') < 0) {
            _ref = findAll('button');
            _fn = function(button) {
              return button.on('click', function() {
                return testwin.buttonClicked(button.settings.icon);
              });
            };
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              button = _ref[_i];
              _fn(button);
            }
            installed.push('buttons');
          }
          _ref1 = __slice.call(findAll('splitbutton')).concat(__slice.call(findAll('listbox')), __slice.call(findAll('menubutton')));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            object = _ref1[_j];
            object.disabled(true);
          }
          return testwin.enterReadyState();
        } catch (_error) {
          e = _error;
          return setTimeout(installListeners, 100);
        }
      })();
    }
  };

}).call(this);

//# sourceMappingURL=app.js.map
