// Generated by CoffeeScript 1.8.0
(function() {
  var Group, Groups, LoadSave, Overlay, grouperHTML, grouperInfo, maybeSetupTestRecorder,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  grouperHTML = function(typeName, openClose, id, hide, image) {
    if (hide == null) {
      hide = true;
    }
    hide = hide ? ' hide' : '';
    if (image == null) {
      image = "images/red-bracket-" + openClose + ".png";
    }
    return "<img src='" + image + "' class='grouper " + typeName + hide + "' id='" + openClose + id + "'>";
  };

  window.grouperHTML = grouperHTML;

  grouperInfo = function(grouper) {
    var info, more, result;
    info = /^(open|close)([0-9]+)$/.exec(grouper != null ? typeof grouper.getAttribute === "function" ? grouper.getAttribute('id') : void 0 : void 0);
    if (!info) {
      return null;
    }
    result = {
      openOrClose: info[1],
      id: parseInt(info[2])
    };
    more = /^grouper ([^ ]+)/.exec(grouper != null ? typeof grouper.getAttribute === "function" ? grouper.getAttribute('class') : void 0 : void 0);
    if (more) {
      result.type = more[1];
    }
    return result;
  };

  window.grouperInfo = grouperInfo;

  Group = (function() {
    function Group(open, close, plugin) {
      this.open = open;
      this.close = close;
      this.plugin = plugin;
      this.outerRange = __bind(this.outerRange, this);
      this.innerRange = __bind(this.innerRange, this);
      this.contentAsHTML = __bind(this.contentAsHTML, this);
      this.contentAsFragment = __bind(this.contentAsFragment, this);
      this.contentAsText = __bind(this.contentAsText, this);
      this.get = __bind(this.get, this);
      this.set = __bind(this.set, this);
      this.typeName = __bind(this.typeName, this);
      this.id = __bind(this.id, this);
    }

    Group.prototype.id = function() {
      var _ref, _ref1;
      return (_ref = (_ref1 = grouperInfo(this.open)) != null ? _ref1.id : void 0) != null ? _ref : null;
    };

    Group.prototype.typeName = function() {
      var _ref;
      return (_ref = grouperInfo(this.open)) != null ? _ref.type : void 0;
    };

    Group.prototype.set = function(key, value) {
      var _ref, _ref1;
      if (!/^[a-zA-Z0-9-]+$/.test(key)) {
        return;
      }
      this.open.setAttribute("data-" + key, JSON.stringify([value]));
      if ((_ref = this.plugin) != null) {
        _ref.editor.fire('change', {
          group: this,
          key: key
        });
      }
      return (_ref1 = this.plugin) != null ? _ref1.editor.isNotDirty = false : void 0;
    };

    Group.prototype.get = function(key) {
      var e;
      try {
        return JSON.parse(this.open.getAttribute("data-" + key))[0];
      } catch (_error) {
        e = _error;
        return void 0;
      }
    };

    Group.prototype.contentAsText = function() {
      return this.innerRange().toString();
    };

    Group.prototype.contentAsFragment = function() {
      return this.innerRange.cloneContents();
    };

    Group.prototype.contentAsHTML = function() {
      var tmp;
      tmp = this.open.ownerDocument.createElement('div');
      tmp.appendChild(this.contentAsFragment());
      return tmp.innerHTML;
    };

    Group.prototype.innerRange = function() {
      var range;
      range = this.open.ownerDocument.createRange();
      range.setStartAfter(this.open);
      range.setEndBefore(this.close);
      return range;
    };

    Group.prototype.outerRange = function() {
      var range;
      range = this.open.ownerDocument.createRange();
      range.setStartBefore(this.open);
      range.setEndAfter(this.close);
      return range;
    };

    return Group;

  })();

  window.Group = Group;

  Groups = (function() {
    function Groups(editor) {
      this.editor = editor;
      this.drawGroups = __bind(this.drawGroups, this);
      this.groupAboveSelection = __bind(this.groupAboveSelection, this);
      this.groupAboveCursor = __bind(this.groupAboveCursor, this);
      this.groupAboveNode = __bind(this.groupAboveNode, this);
      this.grouperToGroup = __bind(this.grouperToGroup, this);
      this.ids = __bind(this.ids, this);
      this.registerGroup = __bind(this.registerGroup, this);
      this.scanDocument = __bind(this.scanDocument, this);
      this.enableScanning = __bind(this.enableScanning, this);
      this.disableScanning = __bind(this.disableScanning, this);
      this.hideOrShowGroupers = __bind(this.hideOrShowGroupers, this);
      this.allGroupers = __bind(this.allGroupers, this);
      this.groupCurrentSelection = __bind(this.groupCurrentSelection, this);
      this.updateButtonsAndMenuItems = __bind(this.updateButtonsAndMenuItems, this);
      this.addGroupType = __bind(this.addGroupType, this);
      this.setUsedID = __bind(this.setUsedID, this);
      this.addFreeId = __bind(this.addFreeId, this);
      this.nextFreeId = __bind(this.nextFreeId, this);
      this.groupTypes = {};
      this.topLevel = [];
      this.freeIds = [0];
      this.editor.Overlay.addDrawHandler(this.drawGroups);
    }

    Groups.prototype.nextFreeId = function() {
      if (this.freeIds.length > 1) {
        return this.freeIds.shift();
      } else {
        return this.freeIds[0]++;
      }
    };

    Groups.prototype.addFreeId = function(id) {
      if (id < this.freeIds[this.freeIds.length - 1]) {
        this.freeIds.push(id);
        return this.freeIds.sort();
      }
    };

    Groups.prototype.setUsedID = function(id) {
      var i, last;
      last = this.freeIds[this.freeIds.length - 1];
      while (last < id) {
        this.freeIds.push(++last);
      }
      i = this.freeIds.indexOf(id);
      this.freeIds.splice(i, 1);
      if (i === this.freeIds.length) {
        return this.freeIds.push(id + 1);
      }
    };

    Groups.prototype.addGroupType = function(name, data) {
      var buttonData, key, menuData, n, plugin, _ref;
      if (data == null) {
        data = {};
      }
      name = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = name.length; _i < _len; _i++) {
          n = name[_i];
          if (/[a-zA-Z_-]/.test(n)) {
            _results.push(n);
          }
        }
        return _results;
      })()).join('');
      this.groupTypes[name] = data;
      if (data.hasOwnProperty('text')) {
        plugin = this;
        menuData = {
          text: data.text,
          context: (_ref = data.context) != null ? _ref : 'Insert',
          onclick: (function(_this) {
            return function() {
              return _this.groupCurrentSelection(name);
            };
          })(this),
          onPostRender: function() {
            plugin.groupTypes[name].menuItem = this;
            return plugin.updateButtonsAndMenuItems();
          }
        };
        if (data.shortcut != null) {
          menuData.shortcut = data.shortcut;
        }
        if (data.icon != null) {
          menuData.icon = data.icon;
        }
        this.editor.addMenuItem(name, menuData);
        buttonData = {
          tooltip: data.tooltip,
          onclick: (function(_this) {
            return function() {
              return _this.groupCurrentSelection(name);
            };
          })(this),
          onPostRender: function() {
            plugin.groupTypes[name].button = this;
            return plugin.updateButtonsAndMenuItems();
          }
        };
        key = data.image != null ? 'image' : data.icon != null ? 'icon' : 'text';
        buttonData[key] = data[key];
        return this.editor.addButton(name, buttonData);
      }
    };

    Groups.prototype.updateButtonsAndMenuItems = function() {
      var inSameGroup, left, name, right, type, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;
      left = (_ref = this.editor) != null ? (_ref1 = _ref.selection) != null ? (_ref2 = _ref1.getRng()) != null ? _ref2.cloneRange() : void 0 : void 0 : void 0;
      if (!left) {
        return;
      }
      right = left.cloneRange();
      left.collapse(true);
      right.collapse(false);
      inSameGroup = this.groupAboveCursor(left) === this.groupAboveCursor(right);
      _ref3 = this.groupTypes;
      _results = [];
      for (name in _ref3) {
        if (!__hasProp.call(_ref3, name)) continue;
        type = _ref3[name];
        if (type != null) {
          if ((_ref4 = type.button) != null) {
            _ref4.disabled(!inSameGroup);
          }
        }
        _results.push(type != null ? (_ref5 = type.menuItem) != null ? _ref5.disabled(!inSameGroup) : void 0 : void 0);
      }
      return _results;
    };

    Groups.prototype.groupCurrentSelection = function(type) {
      var close, content, cursor, hide, id, leftNode, leftPos, open, range, rightNode, rightPos, sel, _ref;
      if (!this.groupTypes.hasOwnProperty(type)) {
        return;
      }
      hide = ($((_ref = this.allGroupers()) != null ? _ref[0] : void 0)).hasClass('hide');
      id = this.nextFreeId();
      open = grouperHTML(type, 'open', id, hide, this.groupTypes[type]['open-img']);
      close = grouperHTML(type, 'close', id, hide, this.groupTypes[type]['close-img']);
      sel = this.editor.selection;
      if (sel.getStart() === sel.getEnd()) {
        cursor = '<span id="put_cursor_here">\u200b</span>';
        content = this.editor.selection.getContent();
        this.editor.insertContent(open + content + cursor + close);
        cursor = ($(this.editor.getBody())).find('#put_cursor_here');
        close = cursor.get(0).nextSibling;
        sel.select(cursor.get(0));
        cursor.remove();
        sel.select(close);
        return sel.collapse(true);
      } else {
        range = sel.getRng();
        leftNode = range.startContainer;
        leftPos = range.startOffset;
        rightNode = range.endContainer;
        rightPos = range.endOffset;
        range.collapse(false);
        sel.setRng(range);
        this.disableScanning();
        this.editor.insertContent(close);
        range.setStart(leftNode, leftPos);
        range.setEnd(leftNode, leftPos);
        sel.setRng(range);
        this.editor.insertContent(open);
        return this.enableScanning();
      }
    };

    Groups.prototype.allGroupers = function() {
      return this.editor.getDoc().getElementsByClassName('grouper');
    };

    Groups.prototype.hideOrShowGroupers = function() {
      var groupers;
      groupers = $(this.allGroupers());
      if (($(groupers != null ? groupers[0] : void 0)).hasClass('hide')) {
        return groupers.removeClass('hide');
      } else {
        return groupers.addClass('hide');
      }
    };

    Groups.prototype.disableScanning = function() {
      return this.scanLocks = (this.scanLocks != null ? this.scanLocks : this.scanLocks = 0) + 1;
    };

    Groups.prototype.enableScanning = function() {
      var _ref;
      this.scanLocks = Math.max(((_ref = this.scanLocks) != null ? _ref : 0) - 1, 0);
      if (this.scanLocks === 0) {
        return this.scanDocument();
      }
    };

    Groups.prototype.scanDocument = function() {
      var a, after, becameFree, before, child, count, gpStack, groupData, grouper, groupers, id, index, info, newGroup, usedIds, _i, _j, _k, _len, _len1, _len2, _ref;
      if (this.scanLocks > 0) {
        return;
      }
      groupers = Array.prototype.slice.apply(this.allGroupers());
      gpStack = [];
      usedIds = [];
      this.topLevel = [];
      before = this.freeIds.slice(0);
      index = function(id) {
        var gp, i, _i, _len;
        for (i = _i = 0, _len = gpStack.length; _i < _len; i = ++_i) {
          gp = gpStack[i];
          if (gp.id === id) {
            return i;
          }
        }
        return -1;
      };
      for (_i = 0, _len = groupers.length; _i < _len; _i++) {
        grouper = groupers[_i];
        if ((info = grouperInfo(grouper)) == null) {
          ($(grouper)).remove();
        } else if (info.openOrClose === 'open') {
          gpStack.unshift({
            id: info.id,
            grouper: grouper,
            children: []
          });
        } else {
          if (index(info.id) === -1) {
            ($(grouper)).remove();
          } else {
            while (gpStack[0].id !== info.id) {
              ($(gpStack.shift().grouper)).remove();
            }
            groupData = gpStack.shift();
            usedIds.push(info.id);
            this.registerGroup(groupData.grouper, grouper);
            newGroup = this[info.id];
            newGroup.children = groupData.children;
            _ref = newGroup.children;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              child = _ref[_j];
              child.parent = newGroup;
            }
            if (gpStack.length > 0) {
              gpStack[0].children.push(newGroup);
            } else {
              this.topLevel.push(newGroup);
              newGroup.parent = null;
            }
          }
        }
      }
      while (gpStack.length > 0) {
        ($(gpStack.shift().grouper)).remove();
      }
      usedIds.sort();
      count = 0;
      this.freeIds = [];
      while (usedIds.length > 0) {
        if (count === usedIds[0]) {
          usedIds.shift();
        } else {
          this.freeIds.push(count);
        }
        count++;
        if (count > 20) {
          break;
        }
      }
      this.freeIds.push(count);
      after = this.freeIds.slice(0);
      while (before[before.length - 1] < after[after.length - 1]) {
        before.push(before[before.length - 1] + 1);
      }
      while (after[after.length - 1] < before[before.length - 1]) {
        after.push(after[after.length - 1] + 1);
      }
      becameFree = (function() {
        var _k, _len2, _results;
        _results = [];
        for (_k = 0, _len2 = after.length; _k < _len2; _k++) {
          a = after[_k];
          if (__indexOf.call(before, a) < 0) {
            _results.push(a);
          }
        }
        return _results;
      })();
      for (_k = 0, _len2 = becameFree.length; _k < _len2; _k++) {
        id = becameFree[_k];
        delete this[id];
      }
      delete this.idsCache;
      return setTimeout((function(_this) {
        return function() {
          var _ref1;
          if ((_ref1 = _this.editor.Overlay) != null) {
            _ref1.redrawContents();
          }
          return _this.updateButtonsAndMenuItems();
        };
      })(this), 0);
    };

    Groups.prototype.registerGroup = function(open, close) {
      var cached, id;
      cached = this[id = grouperInfo(open).id];
      if ((cached != null ? cached.open : void 0) !== open || (cached != null ? cached.close : void 0) !== close) {
        this[id] = new Group(open, close, this);
      }
      return id;
    };

    Groups.prototype.ids = function() {
      var group, recur, _i, _len, _ref;
      if (this.idsCache == null) {
        this.idsCache = [];
        recur = (function(_this) {
          return function(g) {
            var child, _i, _len, _ref, _results;
            _this.idsCache.push(g.id());
            _ref = g.children;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              child = _ref[_i];
              _results.push(recur(child));
            }
            return _results;
          };
        })(this);
        _ref = this.topLevel;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          recur(group);
        }
      }
      return this.idsCache;
    };

    Groups.prototype.grouperToGroup = function(grouper) {
      var id, _ref;
      if ((id = (_ref = grouperInfo(grouper)) != null ? _ref.id : void 0) != null) {
        return this[id];
      } else {
        return null;
      }
    };

    Groups.prototype.groupAboveNode = function(node) {
      var all, group, left, less, middle, right;
      if ((all = this.allGroupers()).length === 0) {
        return null;
      }
      less = function(a, b) {
        return Node.DOCUMENT_POSITION_FOLLOWING & a.compareDocumentPosition(b);
      };
      left = {
        index: 0,
        grouper: all[0],
        leftOfNode: true
      };
      if (left.grouper === node) {
        return this.grouperToGroup(left.grouper);
      }
      if (!less(left.grouper, node)) {
        return null;
      }
      right = {
        index: all.length - 1,
        grouper: all[all.length - 1]
      };
      if (right.grouper === node) {
        return this.grouperToGroup(right.grouper);
      }
      if (less(right.grouper, node)) {
        return null;
      }
      while (true) {
        if (left.grouper === node) {
          return this.grouperToGroup(left.grouper);
        }
        if (right.grouper === node) {
          return this.grouperToGroup(right.grouper);
        }
        if (left.index + 1 === right.index) {
          if (!(group = this.grouperToGroup(left.grouper))) {
            return null;
          }
          if (left.grouper === group.open) {
            return group;
          } else {
            return group.parent;
          }
        }
        middle = Math.floor((left.index + right.index) / 2);
        if (less(all[middle], node)) {
          left = {
            index: middle,
            grouper: all[middle],
            leftOfNode: true
          };
        } else {
          right = {
            index: middle,
            grouper: all[middle],
            leftOfNode: false
          };
        }
      }
    };

    Groups.prototype.groupAboveCursor = function(cursor) {
      var elementAfter, elementBefore, itsGroup;
      if (cursor.startContainer instanceof this.editor.getWin().Text) {
        return this.groupAboveNode(cursor.startContainer);
      }
      if (cursor.startContainer.childNodes.length > cursor.startOffset) {
        elementAfter = cursor.startContainer.childNodes[cursor.startOffset];
        itsGroup = this.groupAboveNode(elementAfter);
        if ((itsGroup != null ? itsGroup.open : void 0) === elementAfter) {
          return itsGroup.parent;
        } else {
          return itsGroup;
        }
      }
      if (cursor.startContainer.childNodes.length > 0) {
        elementBefore = cursor.startContainer.childNodes[cursor.startOffset - 1];
        itsGroup = this.groupAboveNode(elementBefore);
        if ((itsGroup != null ? itsGroup.close : void 0) === elementBefore) {
          return itsGroup.parent;
        } else {
          return itsGroup;
        }
      }
      return this.groupAboveNode(cursor.startContainer);
    };

    Groups.prototype.groupAboveSelection = function(range) {
      var left, leftChain, result, right, rightChain;
      left = range.cloneRange();
      left.collapse(true);
      left = this.groupAboveCursor(left);
      leftChain = [];
      while (left !== null) {
        leftChain.unshift(left);
        left = left.parent;
      }
      right = range.cloneRange();
      right.collapse(false);
      right = this.groupAboveCursor(right);
      rightChain = [];
      while (right !== null) {
        rightChain.unshift(right);
        right = right.parent;
      }
      result = null;
      while (leftChain.length > 0 && rightChain.length > 0 && leftChain[0] === rightChain[0]) {
        result = leftChain.shift();
        rightChain.shift();
      }
      return result;
    };

    Groups.prototype.drawGroups = function(canvas, context) {
      var bodyStyle, close, color, group, leftMar, moveBy, old, open, p, p4, pad, padStep, radius, rightMar, size, style, tag, tagString, tags, tagsToDraw, type, x1, x2, y1, y2, _i, _j, _len, _len1, _ref, _ref1, _ref2, _results;
      group = this.groupAboveSelection(this.editor.selection.getRng());
      bodyStyle = null;
      pad = padStep = 1;
      radius = 4;
      p4 = Math.pi / 4;
      tags = [];
      while (group) {
        type = (_ref = this.groupTypes) != null ? _ref[group != null ? group.typeName() : void 0] : void 0;
        color = (_ref1 = type != null ? type.color : void 0) != null ? _ref1 : '#444444';
        open = $(group.open);
        close = $(group.close);
        p = open.position();
        open = {
          top: p.top,
          left: p.left,
          bottom: p.top + open.height(),
          right: p.left + open.width()
        };
        p = close.position();
        close = {
          top: p.top,
          left: p.left,
          bottom: p.top + close.height(),
          right: p.left + close.width()
        };
        if (open.top === open.bottom || close.top === close.bottom || open.left === open.right || close.left === close.right) {
          setTimeout(((function(_this) {
            return function() {
              var _ref2;
              return (_ref2 = _this.editor.Overlay) != null ? _ref2.redrawContents() : void 0;
            };
          })(this)), 100);
          return;
        }
        x1 = open.left - pad / 3;
        y1 = open.top - pad;
        x2 = close.right + pad / 3;
        y2 = close.bottom + pad;
        if (tagString = type != null ? typeof type.tagContents === "function" ? type.tagContents(group) : void 0 : void 0) {
          style = this.editor.getWin().getComputedStyle(group.open);
          tags.push({
            content: tagString,
            corner: {
              x: x1,
              y: y1
            },
            color: color,
            style: "font-size:" + style.fontSize + "; font-family:" + style.fontFamily + ";"
          });
        }
        context.fillStyle = context.strokeStyle = color;
        if (open.top === close.top) {
          context.roundedRect(x1, y1, x2, y2, radius);
        } else {
          if (bodyStyle == null) {
            bodyStyle = getComputedStyle(this.editor.getBody());
            leftMar = parseInt(bodyStyle['margin-left']);
            rightMar = parseInt(bodyStyle['margin-right']);
          }
          context.roundedZone(x1, y1, x2, y2, open.bottom, close.top, leftMar, rightMar, radius);
        }
        context.globalAlpha = 1.0;
        context.lineWidth = 1.5;
        context.stroke();
        context.globalAlpha = 0.3;
        context.fill();
        group = group.parent;
        pad += padStep;
      }
      tagsToDraw = [];
      while (tags.length > 0) {
        tag = tags.shift();
        context.font = tag.font;
        if (!(size = context.measureHTML(tag.content, tag.style))) {
          setTimeout(((function(_this) {
            return function() {
              var _ref2;
              return (_ref2 = _this.editor.Overlay) != null ? _ref2.redrawContents() : void 0;
            };
          })(this)), 10);
          return;
        }
        x1 = tag.corner.x - padStep;
        y1 = tag.corner.y - size.height - 2 * padStep;
        x2 = x1 + 2 * padStep + size.width;
        y2 = tag.corner.y;
        for (_i = 0, _len = tagsToDraw.length; _i < _len; _i++) {
          old = tagsToDraw[_i];
          if (rectanglesCollide(x1, y1, x2, y2, old.x1, old.y1, old.x2, old.y2)) {
            moveBy = old.y1 - y2;
            y1 += moveBy;
            y2 += moveBy;
          }
        }
        y2 = tag.corner.y;
        _ref2 = [x1, y1, x2, y2], tag.x1 = _ref2[0], tag.y1 = _ref2[1], tag.x2 = _ref2[2], tag.y2 = _ref2[3];
        tagsToDraw.unshift(tag);
      }
      _results = [];
      for (_j = 0, _len1 = tagsToDraw.length; _j < _len1; _j++) {
        tag = tagsToDraw[_j];
        context.roundedRect(tag.x1, tag.y1, tag.x2, tag.y2, radius);
        context.globalAlpha = 1.0;
        context.fillStyle = '#ffffff';
        context.fill();
        context.lineWidth = 1.5;
        context.strokeStyle = tag.color;
        context.stroke();
        context.globalAlpha = 0.7;
        context.fillStyle = tag.color;
        context.fill();
        context.fillStyle = '#000000';
        context.globalAlpha = 1.0;
        _results.push(context.drawHTML(tag.content, tag.x1 + padStep, tag.y1, tag.style));
      }
      return _results;
    };

    return Groups;

  })();

  tinymce.PluginManager.add('groups', function(editor, url) {
    var type, _i, _len, _ref;
    editor.Groups = new Groups(editor);
    editor.on('init', function(event) {
      return editor.dom.loadCSS('groupsplugin.css');
    });
    _ref = editor.settings.groupTypes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      type = _ref[_i];
      editor.Groups.addGroupType(type.name, type);
    }
    editor.addMenuItem('hideshowgroups', {
      text: 'Hide/show groups',
      context: 'View',
      onclick: function() {
        return editor.Groups.hideOrShowGroupers();
      }
    });
    editor.on('change SetContent', function(event) {
      return editor.Groups.scanDocument();
    });
    editor.on('KeyUp', function(event) {
      var _ref1;
      if ((33 <= (_ref1 = event.keyCode) && _ref1 <= 40)) {
        return;
      }
      return editor.Groups.scanDocument();
    });
    return editor.on('NodeChange', function(event) {
      return editor.Groups.updateButtonsAndMenuItems();
    });
  });

  LoadSave = (function() {
    LoadSave.prototype.appName = null;

    LoadSave.setAppName = function(newname) {
      var instance, _i, _len, _ref, _results;
      if (newname == null) {
        newname = null;
      }
      LoadSave.prototype.appName = newname;
      _ref = LoadSave.prototype.instances;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        instance = _ref[_i];
        _results.push(instance.setAppName(newname));
      }
      return _results;
    };

    LoadSave.prototype.instances = [];

    function LoadSave(editor) {
      var control;
      this.editor = editor;
      this.manageFiles = __bind(this.manageFiles, this);
      this.handleOpen = __bind(this.handleOpen, this);
      this.tryToOpen = __bind(this.tryToOpen, this);
      this.load = __bind(this.load, this);
      this.tryToSave = __bind(this.tryToSave, this);
      this.save = __bind(this.save, this);
      this.tryToClear = __bind(this.tryToClear, this);
      this.clear = __bind(this.clear, this);
      this.setFileSystem = __bind(this.setFileSystem, this);
      this.setAppName = __bind(this.setAppName, this);
      this.setFilepath = __bind(this.setFilepath, this);
      this.setFilename = __bind(this.setFilename, this);
      this.setDocumentDirty = __bind(this.setDocumentDirty, this);
      this.recomputePageTitle = __bind(this.recomputePageTitle, this);
      this.setAppName(LoadSave.prototype.appName);
      this.setFileSystem(this.appName);
      this.setFilepath(FileSystem.prototype.pathSeparator);
      setTimeout(((function(_this) {
        return function() {
          return _this.clear();
        };
      })(this)), 0);
      this.saveMetaData = this.loadMetaData = null;
      this.editor.on('change', (function(_this) {
        return function(event) {
          return _this.setDocumentDirty(true);
        };
      })(this));
      control = (function(_this) {
        return function(name, data) {
          var buttonData, key;
          buttonData = {
            icon: data.icon,
            shortcut: data.shortcut,
            onclick: data.onclick,
            tooltip: data.tooltip
          };
          key = data.icon != null ? 'icon' : 'text';
          buttonData[key] = data[key];
          _this.editor.addButton(name, buttonData);
          return _this.editor.addMenuItem(name, data);
        };
      })(this);
      control('newfile', {
        text: 'New',
        icon: 'newdocument',
        context: 'file',
        shortcut: 'ctrl+N',
        tooltip: 'New file',
        onclick: (function(_this) {
          return function() {
            return _this.tryToClear();
          };
        })(this)
      });
      control('savefile', {
        text: 'Save',
        icon: 'save',
        context: 'file',
        shortcut: 'ctrl+S',
        tooltip: 'Save file',
        onclick: (function(_this) {
          return function() {
            return _this.tryToSave();
          };
        })(this)
      });
      this.editor.addMenuItem('saveas', {
        text: 'Save as...',
        context: 'file',
        shortcut: 'ctrl+shift+S',
        onclick: (function(_this) {
          return function() {
            return _this.tryToSave(null, '');
          };
        })(this)
      });
      control('openfile', {
        text: 'Open...',
        icon: 'browse',
        context: 'file',
        shortcut: 'ctrl+O',
        tooltip: 'Open file...',
        onclick: (function(_this) {
          return function() {
            return _this.handleOpen();
          };
        })(this)
      });
      this.editor.addMenuItem('managefiles', {
        text: 'Manage files...',
        context: 'file',
        onclick: (function(_this) {
          return function() {
            return _this.manageFiles();
          };
        })(this)
      });
      LoadSave.prototype.instances.push(this);
    }

    LoadSave.prototype.recomputePageTitle = function() {
      return document.title = "" + (this.appName ? this.appName + ': ' : '') + " " + (this.filename || '(untitled)') + " " + (this.documentDirty ? '*' : '');
    };

    LoadSave.prototype.setDocumentDirty = function(setting) {
      if (setting == null) {
        setting = true;
      }
      this.documentDirty = setting;
      return this.recomputePageTitle();
    };

    LoadSave.prototype.setFilename = function(newname) {
      if (newname == null) {
        newname = null;
      }
      this.filename = newname;
      return this.recomputePageTitle();
    };

    LoadSave.prototype.setFilepath = function(newpath) {
      if (newpath == null) {
        newpath = null;
      }
      return this.filepath = newpath;
    };

    LoadSave.prototype.setAppName = function(newname) {
      var mustAlsoUpdateFileSystem;
      if (newname == null) {
        newname = null;
      }
      mustAlsoUpdateFileSystem = this.appName === this.fileSystem;
      this.appName = newname;
      if (mustAlsoUpdateFileSystem) {
        this.fileSystem = this.appName;
      }
      return this.recomputePageTitle();
    };

    LoadSave.prototype.setFileSystem = function(newname) {
      if (newname == null) {
        newname = this.appName;
      }
      return this.fileSystem = newname;
    };

    LoadSave.prototype.clear = function() {
      this.editor.setContent('');
      this.setDocumentDirty(false);
      return this.setFilename(null);
    };

    LoadSave.prototype.tryToClear = function() {
      if (!this.documentDirty) {
        this.clear();
        this.editor.focus();
        return;
      }
      return this.editor.windowManager.open({
        title: 'Save first?',
        buttons: [
          {
            text: 'Save',
            onclick: (function(_this) {
              return function() {
                _this.tryToSave(function(success) {
                  if (success) {
                    return _this.clear();
                  }
                });
                return _this.editor.windowManager.close();
              };
            })(this)
          }, {
            text: 'Discard',
            onclick: (function(_this) {
              return function() {
                _this.clear();
                return _this.editor.windowManager.close();
              };
            })(this)
          }, {
            text: 'Cancel',
            onclick: (function(_this) {
              return function() {
                return _this.editor.windowManager.close();
              };
            })(this)
          }
        ]
      });
    };

    LoadSave.prototype.save = function() {
      var objectToSave, tmp;
      if (this.filename === null) {
        return;
      }
      tmp = new FileSystem(this.fileSystem);
      tmp.cd(this.filepath);
      objectToSave = [this.editor.getContent(), typeof this.saveMetaData === "function" ? this.saveMetaData() : void 0];
      if (tmp.write(this.filename, objectToSave, true)) {
        return this.setDocumentDirty(false);
      }
    };

    LoadSave.prototype.tryToSave = function(callback, filename) {
      var filepath, refreshDialog, result, saveWouldOverwrite;
      if (filename == null) {
        filename = this.filename;
      }
      if (filename) {
        this.setFilename(filename);
        result = this.save();
        this.editor.focus();
        return typeof callback === "function" ? callback(result) : void 0;
      }
      refreshDialog = function() {
        var button, dialog, _i, _len, _ref, _results;
        dialog = document.getElementsByClassName('mce-window')[0];
        if (!dialog) {
          return;
        }
        _ref = dialog.getElementsByTagName('button');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          button = _ref[_i];
          if (button.textContent === 'Save') {
            if (filename) {
              button.removeAttribute('disabled');
              button.parentNode.style.backgroundImage = null;
              button.parentNode.style.backgroundColor = null;
            } else {
              button.setAttribute('disabled', true);
              button.parentNode.style.backgroundImage = 'none';
              button.parentNode.style.backgroundColor = '#ccc';
            }
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      filename = null;
      this.saveFileNameChangedHandler = function(newname) {
        filename = newname;
        return refreshDialog();
      };
      filepath = null;
      this.changedFolderHandler = function(newfolder) {
        return filepath = newfolder;
      };
      saveWouldOverwrite = (function(_this) {
        return function(filepath, filename) {
          var tmp;
          tmp = new FileSystem(_this.fileSystem);
          tmp.cd(filepath);
          return null !== tmp.type(filename);
        };
      })(this);
      this.buttonClickedHandler = (function(_this) {
        return function() {
          var args, name;
          name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (name === 'Save') {
            if (saveWouldOverwrite(filepath, filename)) {
              if (!confirm("Are you sure you want to overwrite the file " + filename + "?")) {
                _this.tellDialog('setFileBrowserMode', 'save file');
                return;
              }
            }
            _this.setFilepath(filepath);
            _this.setFilename(filename);
            _this.editor.windowManager.close();
            result = _this.save();
            return typeof callback === "function" ? callback(result) : void 0;
          } else if (name === 'Cancel') {
            _this.editor.windowManager.close();
            return typeof callback === "function" ? callback(false) : void 0;
          }
        };
      })(this);
      return this.editor.windowManager.open({
        title: 'Save file...',
        url: 'filedialog/filedialog.html',
        width: 600,
        height: 400,
        buttons: [
          {
            text: 'Save',
            subtype: 'primary',
            onclick: (function(_this) {
              return function() {
                return _this.buttonClickedHandler('Save');
              };
            })(this)
          }, {
            text: 'Cancel',
            onclick: (function(_this) {
              return function() {
                return _this.buttonClickedHandler('Cancel');
              };
            })(this)
          }
        ]
      }, {
        fsName: this.fileSystem,
        mode: 'save file'
      });
    };

    LoadSave.prototype.load = function(filepath, filename) {
      var content, metadata, tmp, _ref;
      if (filename === null) {
        return;
      }
      if (filepath === null) {
        filepath = '.';
      }
      tmp = new FileSystem(this.fileSystem);
      tmp.cd(filepath);
      _ref = tmp.read(filename), content = _ref[0], metadata = _ref[1];
      this.editor.setContent(content);
      this.editor.focus();
      this.setFilepath(filepath);
      this.setFilename(filename);
      this.setDocumentDirty(false);
      if (metadata) {
        return typeof this.loadMetaData === "function" ? this.loadMetaData(metadata) : void 0;
      }
    };

    LoadSave.prototype.tryToOpen = function(callback) {
      var filename, filepath, refreshDialog;
      if (callback == null) {
        callback = (function(_this) {
          return function(p, f) {
            return _this.load(p, f);
          };
        })(this);
      }
      refreshDialog = (function(_this) {
        return function() {
          var button, dialog, _i, _len, _ref, _results;
          dialog = document.getElementsByClassName('mce-window')[0];
          if (!dialog) {
            return;
          }
          _ref = dialog.getElementsByTagName('button');
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            button = _ref[_i];
            if (button.textContent === 'Open') {
              if (filename) {
                button.removeAttribute('disabled');
                button.parentNode.style.backgroundImage = null;
                button.parentNode.style.backgroundColor = null;
              } else {
                button.setAttribute('disabled', true);
                button.parentNode.style.backgroundImage = 'none';
                button.parentNode.style.backgroundColor = '#ccc';
              }
              break;
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
      })(this);
      filename = null;
      this.selectedFileHandler = function(newname) {
        filename = newname;
        return refreshDialog();
      };
      filepath = null;
      this.changedFolderHandler = function(newfolder) {
        return filepath = newfolder;
      };
      this.buttonClickedHandler = (function(_this) {
        return function() {
          var args, name;
          name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (name === 'Open') {
            _this.editor.windowManager.close();
            return typeof callback === "function" ? callback(filepath, filename) : void 0;
          } else if (name === 'Cancel') {
            _this.editor.windowManager.close();
            return typeof callback === "function" ? callback(null, null) : void 0;
          }
        };
      })(this);
      this.editor.windowManager.open({
        title: 'Open file...',
        url: 'filedialog/filedialog.html',
        width: 600,
        height: 400,
        buttons: [
          {
            text: 'Open',
            subtype: 'primary',
            onclick: (function(_this) {
              return function() {
                return _this.buttonClickedHandler('Open');
              };
            })(this)
          }, {
            text: 'Cancel',
            onclick: (function(_this) {
              return function() {
                return _this.buttonClickedHandler('Cancel');
              };
            })(this)
          }
        ]
      }, {
        fsName: this.fileSystem,
        mode: 'open file'
      });
      return refreshDialog();
    };

    LoadSave.prototype.handleOpen = function() {
      if (!this.documentDirty) {
        return this.tryToOpen();
      }
      return this.editor.windowManager.open({
        title: 'Save first?',
        buttons: [
          {
            text: 'Save',
            onclick: (function(_this) {
              return function() {
                _this.editor.windowManager.close();
                return _this.tryToSave(function(success) {
                  if (success) {
                    return _this.tryToOpen();
                  }
                });
              };
            })(this)
          }, {
            text: 'Discard',
            onclick: (function(_this) {
              return function() {
                _this.editor.windowManager.close();
                return _this.tryToOpen();
              };
            })(this)
          }, {
            text: 'Cancel',
            onclick: (function(_this) {
              return function() {
                return _this.editor.windowManager.close();
              };
            })(this)
          }
        ]
      });
    };

    LoadSave.prototype.tellDialog = function() {
      var args, frame, frames, _i, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      frames = document.getElementsByTagName('iframe');
      for (_i = 0, _len = frames.length; _i < _len; _i++) {
        frame = frames[_i];
        if ('filedialog/filedialog.html' === frame.getAttribute('src')) {
          return frame.contentWindow.postMessage(args, '*');
        }
      }
    };

    LoadSave.prototype.manageFiles = function() {
      return this.editor.windowManager.open({
        title: 'Manage files',
        url: 'filedialog/filedialog.html',
        width: 700,
        height: 500,
        buttons: [
          {
            text: 'New folder',
            onclick: (function(_this) {
              return function() {
                return _this.tellDialog('buttonClicked', 'New folder');
              };
            })(this)
          }, {
            text: 'Done',
            onclick: (function(_this) {
              return function() {
                return _this.editor.windowManager.close();
              };
            })(this)
          }
        ]
      }, {
        fsName: this.fileSystem,
        mode: 'manage files'
      });
    };

    return LoadSave;

  })();

  tinymce.PluginManager.add('loadsave', function(editor, url) {
    return editor.LoadSave = new LoadSave(editor);
  });

  window.onmessage = function(event) {
    var handlerName, instance, _i, _len, _ref;
    handlerName = "" + event.data[0] + "Handler";
    _ref = LoadSave.prototype.instances;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      instance = _ref[_i];
      if (instance.hasOwnProperty(handlerName)) {
        return instance[handlerName].apply(null, event.data.slice(1));
      }
    }
  };

  window.setAppName = function(newname) {
    if (newname == null) {
      newname = null;
    }
    return LoadSave.prototype.appName = newname;
  };

  Overlay = (function() {
    function Overlay(editor) {
      this.editor = editor;
      this.redrawContents = __bind(this.redrawContents, this);
      this.editor.on('init', (function(_this) {
        return function() {
          _this.container = _this.editor.getContentAreaContainer();
          _this.canvas = document.createElement('canvas');
          ($(_this.container)).after(_this.canvas);
          _this.canvas.style.position = 'absolute';
          _this.canvas.style['background-color'] = 'rgba(0,0,0,0)';
          _this.canvas.style['pointer-events'] = 'none';
          return _this.canvas.style['z-index'] = '10';
        };
      })(this));
      this.drawHandlers = [];
      this.editor.on('NodeChange', this.redrawContents);
      ($(window)).resize(this.redrawContents);
    }

    Overlay.prototype.redrawContents = function(event) {
      var context, doDrawing, e, _i, _len, _ref, _ref1, _results;
      this.positionCanvas();
      if (!(context = (_ref = this.canvas) != null ? _ref.getContext('2d') : void 0)) {
        return;
      }
      this.clearCanvas(context);
      _ref1 = this.drawHandlers;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        doDrawing = _ref1[_i];
        try {
          _results.push(doDrawing(this.canvas, context));
        } catch (_error) {
          e = _error;
          _results.push(console.log("Error in overlay draw function: " + e.stack));
        }
      }
      return _results;
    };

    Overlay.prototype.addDrawHandler = function(drawFunction) {
      return this.drawHandlers.push(drawFunction);
    };

    Overlay.prototype.getEditorFrame = function() {
      var frame, _i, _len, _ref;
      _ref = window.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        if (frame.document === this.editor.getDoc()) {
          return frame;
        }
      }
      return null;
    };

    Overlay.prototype.positionCanvas = function() {
      var can, con;
      con = $(this.container);
      can = $(this.canvas);
      if (con.position() == null) {
        return;
      }
      can.css('top', con.position().top);
      can.css('left', con.position().left);
      can.width(con.width());
      can.height(con.height());
      this.canvas.width = can.width();
      return this.canvas.height = can.height();
    };

    Overlay.prototype.clearCanvas = function(context) {
      return context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };

    return Overlay;

  })();

  tinymce.PluginManager.add('overlay', function(editor, url) {
    return editor.Overlay = new Overlay(editor);
  });

  setAppName('Lurch');

  $(function() {
    var editor;
    editor = document.createElement('textarea');
    editor.setAttribute('id', 'editor');
    document.body.appendChild(editor);
    maybeSetupTestRecorder();
    return tinymce.init({
      selector: '#editor',
      auto_focus: 'editor',
      browser_spellcheck: true,
      gecko_spellcheck: true,
      statusbar: false,
      plugins: 'advlist table charmap colorpicker contextmenu image link importcss paste print save searchreplace textcolor fullscreen -loadsave -overlay -groups',
      toolbar: ['newfile openfile savefile managefiles | print | undo redo | cut copy paste | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent blockquote | table', 'fontselect styleselect | bold italic underline textcolor subscript superscript removeformat | link unlink | charmap image | spellchecker searchreplace | me'],
      menu: {
        file: {
          title: 'File',
          items: 'newfile openfile | savefile saveas | managefiles | print'
        },
        edit: {
          title: 'Edit',
          items: 'undo redo | cut copy paste pastetext | selectall'
        },
        insert: {
          title: 'Insert',
          items: 'link media | template hr | me'
        },
        view: {
          title: 'View',
          items: 'visualaid hideshowgroups'
        },
        format: {
          title: 'Format',
          items: 'bold italic underline strikethrough superscript subscript | formats | removeformat'
        },
        table: {
          title: 'Table',
          items: 'inserttable tableprops deletetable | cell row column'
        },
        help: {
          title: 'Help',
          items: 'about website'
        }
      },
      contextmenu: 'link image inserttable | cell row column deletetable',
      setup: function(editor) {
        editor.addMenuItem('about', {
          text: 'About...',
          context: 'help',
          onclick: function() {
            return alert('webLurch\n\npre-alpha, not intended for general consumption!');
          }
        });
        editor.addMenuItem('website', {
          text: 'Lurch website',
          context: 'help',
          onclick: function() {
            return window.open('http://www.lurchmath.org', '_blank');
          }
        });
        return editor.on('init', function() {
          var filemenu, icon;
          editor.getBody().style.fontSize = '16px';
          setTimeout(function() {
            var h, walk, _i, _len, _ref, _results;
            editor.execCommand('mceFullScreen');
            walk = editor.iframeElement;
            while (walk && walk !== editor.container) {
              if (walk === editor.iframeElement.parentNode) {
                walk.style.height = 'auto';
              } else {
                walk.style.height = '100%';
              }
              walk = walk.parentNode;
            }
            _ref = editor.getDoc().getElementsByTagName('html');
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              h = _ref[_i];
              _results.push(h.style.height = 'auto');
            }
            return _results;
          }, 0);
          filemenu = (editor.getContainer().getElementsByClassName('mce-menubtn'))[0];
          icon = document.createElement('img');
          icon.setAttribute('src', 'icons/apple-touch-icon-76x76.png');
          icon.style.width = icon.style.height = '26px';
          icon.style.padding = '2px';
          filemenu.insertBefore(icon, filemenu.childNodes[0]);
          return editor.getBody().addEventListener('focus', function() {
            if (editor.windowManager.getWindows().length !== 0) {
              return editor.windowManager.close();
            }
          });
        });
      },
      groupTypes: [
        {
          name: 'me',
          text: 'Meaningful expression',
          image: './images/red-bracket-icon.png',
          tooltip: 'Make text a meaningful expression',
          color: '#996666',
          tagContents: function(group) {
            var _ref;
            return "" + ((_ref = group.contentAsText()) != null ? _ref.length : void 0) + " characters";
          }
        }
      ]
    });
  });

  maybeSetupTestRecorder = function() {
    var installListeners, installed, testwin;
    if (location.search === '?test') {
      testwin = open('./testrecorder.html', 'recording', "status=no, location=no, toolbar=no, menubar=no, left=" + (window.screenX + ($(window)).width()) + ", top=" + window.screenY + ", width=400, height=600");
      if (!testwin) {
        alert('You have asked to run webLurch in test-recording mode, which requires a popup window.  Your browser has blocked the popup window.  Change its settings or allow this popup to use test-recording mode.');
      }
      installed = [];
      return (installListeners = function() {
        var button, e, findAll, notSupported, object, _fn, _i, _j, _len, _len1, _ref, _ref1;
        notSupported = function(whatYouDid) {
          return alert("You " + whatYouDid + ", which the test recorder does not yet support.  The current test has therefore become corrupted, and you should reload this page and start your test again.  You will need to limit yourself to using only supported keys, menu items, and mouse operations.");
        };
        try {
          if (__indexOf.call(installed, 'keypress') < 0) {
            tinymce.activeEditor.on('keypress', function(event) {
              var letter;
              letter = String.fromCharCode(event.keyCode);
              if (/[A-Za-z0-9 ]/.test(letter)) {
                return testwin.editorKeyPress(event.keyCode, event.shiftKey, event.ctrlKey, event.altKey);
              } else {
                return notSupported("pressed the key with code " + event.keyCode);
              }
            });
            installed.push('keypress');
          }
          if (__indexOf.call(installed, 'keyup') < 0) {
            tinymce.activeEditor.on('keyup', function(event) {
              var conversion, ignore, letter, _ref;
              letter = String.fromCharCode(event.keyCode);
              if (/[A-Za-z0-9 ]/.test(letter)) {
                return;
              }
              ignore = [16, 17, 18, 91];
              if (_ref = event.keyCode, __indexOf.call(ignore, _ref) >= 0) {
                return;
              }
              conversion = {
                8: 'backspace',
                13: 'enter',
                35: 'end',
                36: 'home',
                37: 'left',
                38: 'up',
                39: 'right',
                40: 'down',
                46: 'delete'
              };
              if (conversion.hasOwnProperty(event.keyCode)) {
                return testwin.editorKeyPress(conversion[event.keyCode], event.shiftKey, event.ctrlKey, event.altKey);
              } else {
                return notSupported("pressed the key with code " + event.keyCode);
              }
            });
            installed.push('keyup');
          }
          if (__indexOf.call(installed, 'click') < 0) {
            tinymce.activeEditor.on('click', function(event) {
              if (event.shiftKey) {
                return notSupported("shift-clicked");
              } else if (event.ctrlKey) {
                return notSupported("ctrl-clicked");
              } else if (event.altKey) {
                return notSupported("alt-clicked");
              } else {
                return testwin.editorMouseClick(event.clientX, event.clientY);
              }
            });
            installed.push('click');
          }
          findAll = function(type) {
            return Array.prototype.slice.apply(tinymce.activeEditor.theme.panel.find(type));
          };
          if (__indexOf.call(installed, 'buttons') < 0) {
            _ref = findAll('button');
            _fn = function(button) {
              return button.on('click', function() {
                return testwin.buttonClicked(button.settings.icon);
              });
            };
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              button = _ref[_i];
              _fn(button);
            }
            installed.push('buttons');
          }
          _ref1 = __slice.call(findAll('splitbutton')).concat(__slice.call(findAll('listbox')), __slice.call(findAll('menubutton')));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            object = _ref1[_j];
            object.disabled(true);
          }
          return testwin.enterReadyState();
        } catch (_error) {
          e = _error;
          return setTimeout(installListeners, 100);
        }
      })();
    }
  };

}).call(this);

//# sourceMappingURL=app.js.map
