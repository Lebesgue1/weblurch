<html>
    <head>
        <link rel="stylesheet" href="./main.css"/>
        <link rel="stylesheet" href="./obsidian.css"/>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config( {
              tex2jax: { inlineMath: [ [ '$', '$' ], [ '\\(', '\\)' ] ] }
            } );
        </script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
    </head>
    <body>
        <div id="left">
            weblurch source code docs
        </div>
        <div id="middle">
            <h1><a name='some-specifications-for-the-finished-system'></a>Some specifications for the finished system &nbsp;  <font size=-1><a href='#some-specifications-for-the-finished-system'><img src="link.png" class="anchor"></a></font></h1><p>The plan for implementing this specification is documented in
<a href="to-do.md.html">the to-do list for this project</a>.</p>
<h2><a name='a-vision-for-testing'></a>A vision for testing &nbsp;  <font size=-1><a href='#a-vision-for-testing'><img src="link.png" class="anchor"></a></font></h2><ul>
<li>Two-tab view<ul>
<li>rendered HTML of model</li>
<li>HTML src of model</li>
</ul>
</li>
<li>In either of the two, you can use the keyboard to navigate the
document, and watch the changes.</li>
<li>In the first, you can use the mouse to navigate the document,
and watch the changes.</li>
<li>All actions taken by the user are recorded by the controller
so that they can be played back later, virtually.  (They are
recorded as the names and parameters of functions called in the
<code>LurchEditor</code> model by the controller, easy to replay later.)<ul>
<li>It may seem tempting to utilize the built-in <code>undo()</code> and
<code>redo()</code> methods of <code>LurchEditor</code> for this, but resist that
temptation for two reasons:</li>
<li>First, this makes the test suite depend for its correctness
on the correctness of the thing being tested, which is bad.</li>
<li>Second, it forces us to implement <code>undo()</code> and <code>redo()</code> in
the <code>LurchEditor</code> class as early as possible, which may not
otherwise be optimal.</li>
</ul>
</li>
<li>There can be two new shortcut keys, one for &quot;mark this state as
approved correct&quot; and one for &quot;mark this state as an error&quot;
that can be used, with the above feature, to record assertions
among the actions, which constitute a test when replayed.</li>
<li>Document states are just HTML, so that test suites can be run
by a node script from the command line.  If need be, this HTML
can be converted to JSON using <code>xml2js</code> or the even simpler
technique in <a href="http://stackoverflow.com/a/7824214/670492">this StackOverflow answer</a>.</li>
</ul>
<h2><a name='document-structure-and-the-code-lurcheditor-code-class'></a>Document structure and the <code>LurchEditor</code> class &nbsp;  <font size=-1><a href='#document-structure-and-the-code-lurcheditor-code-class'><img src="link.png" class="anchor"></a></font></h2><p>This specification is for those parts of the <code>LurchEditor</code> class
which have not yet been implemented.  (Some already have.)</p>
<p>Implement the parts described here that are not yet implemented,
and then test these as well.</p>
<ul>
<li>Later one can query which element in the document is the
editable one managed by that <code>LurchEditor</code>, but it cannot be
swapped out for another.  If you wish to edit another, just
create a new <code>LurchEditor</code> instance.</li>
<li><code>LurchEditor</code> will provide an API that one would normally
place inside DOM elements, but that in this case we wonâ€™t,
to avoid creating an unnecessary new node class<ul>
<li><code>insert(node,location)</code></li>
<li><code>remove(node)</code></li>
<li><code>move(node,newlocation)</code></li>
<li><code>replace(node,withthisnode)</code></li>
<li><code>change(node,attrkey,attrval)</code></li>
</ul>
</li>
<li>It should also provide an <code>undo()</code> function (together with
<code>redo()</code> and <code>canUndo()</code> and <code>canRedo()</code>) that invert/replay
the above events</li>
<li>Each of the above will emit events that can be listened to
by anyone who needs to know about them, including later
bubbling and validation features.</li>
</ul>
<h2><a name='document-events'></a>Document events &nbsp;  <font size=-1><a href='#document-events'><img src="link.png" class="anchor"></a></font></h2><ul>
<li>All changes to the document will happen using one of four
functions in the public API provided by the <code>LurchEditor</code> class,
listed above</li>
<li>They generate corresponding events upon completion, which may be
listened to by the controller for the purposes of updating a
secondary view, or verifying correctness in testing, etc.</li>
<li>If the document wants to merge adjacent pieces of content with
identical attributes, concatenating their string contents, this
should result in the firing of one delete and one change event.</li>
</ul>

        </div>
        <div id="right">
            <h3 align=center>Navigation</h3><br><h3><a href='index.md.html'>Main Page</a></h3><p>./</p><ul><li><a href='cake.litcoffee.html'>cake.litcoffee</a></li></ul><p>./app</p><ul><li><a href='../app/index.html'>index.html</a></li></ul><p>./doc</p><ul><li><a href='spec.md.html'>spec.md</a></li><li><a href='test-results.md.html'>test-results.md</a></li><li><a href='to-do.md.html'>to-do.md</a></li></ul><p>./src</p><ul><li><a href='lurcheditor.litcoffee.html'>lurcheditor.litcoffee</a></li></ul><p>./test</p><ul><li><a href='basic-spec.litcoffee.html'>basic-spec.litcoffee</a></li><li><a href='lurcheditor-spec.litcoffee.html'>lurcheditor-spec.litcoffee</a></li><li><a href='phantom-utils.litcoffee.html'>phantom-utils.litcoffee</a></li></ul><p>./testapp</p><ul><li><a href='utils.litcoffee.html'>utils.litcoffee</a></li><li><a href='../testapp/index.html'>index.html</a></li></ul>
        </div>
    </body>
</html>
