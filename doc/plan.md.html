<html>
    <head>
        <link rel="stylesheet" href="./main.css"/>
        <link rel="stylesheet" href="./obsidian.css"/>
        <link rel="shortcut icon" href="favicon.png"/>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config( {
              tex2jax: { inlineMath: [ [ '$', '$' ], [ '\\(', '\\)' ] ] }
            } );
        </script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <title>webLurch docs: plan</title>
    </head>
    <body>
        <div id="left">
            <p align=center>Page contents</p>
<p><a href='#project-plan'>Project Plan</a></p><ul>
<li><a href='#documentation'>Documentation</a></li><li><a href='#word-processing-foundation'>Word Processing Foundation</a></li><ul>
<li><a href='#-code-lurcheditor-code-'><code>LurchEditor</code></a></li></ul>
<li><a href='#test-environment'>Test environment</a></li><ul>
<li><a href='#test-app'>Test app</a></li><li><a href='#easy-test-generation'>Easy test generation</a></li><li><a href='#better-access-to-automated-testing-results'>Better access to automated testing results</a></li><li><a href='#later-when-you-put-the-repository-on-a-server'>Later, when you put the repository on a server</a></li></ul>
<li><a href='#more-word-processing-foundation'>More Word Processing Foundation</a></li><ul>
<li><a href='#events'>Events</a></li><li><a href='#cursor'>Cursor</a></li><li><a href='#keyboard'>Keyboard</a></li><li><a href='#mouse'>Mouse</a></li><li><a href='#load-and-save'>Load and save</a></li></ul>
<li><a href='#logical-foundation'>Logical Foundation</a></li><ul>
<li><a href='#dependencies'>Dependencies</a></li><li><a href='#math'>Math</a></li><li><a href='#groupers'>Groupers</a></li><li><a href='#background-processing'>Background processing</a></li><li><a href='#background-computation-of-the-property-graph'>Background computation of the property graph</a></li><li><a href='#background-computation-of-bubble-meanings'>Background computation of bubble meanings</a></li><li><a href='#background-validation-probably-in-stages'>Background validation, probably in stages</a></li></ul>
<li><a href='#for-later'>For later</a></li>
        </div>
        <div id="middle">
            <h1><a name='project-plan'></a>Project Plan &nbsp;  <font size=-1><a href='#project-plan'><img src="link.png" class="anchor"></a></font></h1><p>Readers unfamiliar with this project may wish to first read what&#39;s
already been accomplished, on the <a href="progress.md.html">Project Progress</a> page.  This page is a complement to that one,
stating what remains to be done.</p>
<p>This document aims to be a complete plan for what needs to be done
on this project, readable by developers.  It can therefore be
viewed as a to-do list in chronological order, the first items
being those that should be done next, and the later items those
that must come after.  Necessarily, the later items are more vague
than the earlier ones.</p>
<h2><a name='documentation'></a>Documentation &nbsp;  <font size=-1><a href='#documentation'><img src="link.png" class="anchor"></a></font></h2><ul>
<li>Create a new document called &quot;Project Progress&quot;
(<code>doc/progress.md</code>) to go along with
this one, as a complement to it.</li>
<li>Link to both from the main page, and from each to the other.</li>
<li>Make the Progress document describe, in plain English,
everything that <em>has</em> been built already, and why, with links
to the source code for the classes that implement the
functionality described.</li>
<li>It can end with a quick description of the next steps, as a
very quick overview of what&#39;s in this document, then link to it.</li>
</ul>
<h2><a name='word-processing-foundation'></a>Word Processing Foundation &nbsp;  <font size=-1><a href='#word-processing-foundation'><img src="link.png" class="anchor"></a></font></h2><h3><a name='-code-lurcheditor-code-'></a><code>LurchEditor</code> &nbsp;  <font size=-1><a href='#-code-lurcheditor-code-'><img src="link.png" class="anchor"></a></font></h3><p>For each of the following features, add tests for them to <a href="lurcheditor-spec.litcoffee.html">the
<code>LurchEditor</code> spec</a>.</p>
<ul>
<li>Add to the <code>LurchEditor</code> class a pointer that indexes into the
<code>DOMEditAction</code> stack, pointing to the last-undone action.  If
no actions have been undone, then it will equal the stack size.
Override <code>nodeEditHappened</code> so that before the original version
is called, if the pointer is not the stack size, then the stack
is truncated to make it so.</li>
<li>Add canUndo() and canRedo() methods to the <code>LurchEditor</code> class
that just report whether the index pointer isn&#39;t at the top or
bottom of the stack.</li>
<li>Add methods to <code>LurchEditor</code> that can describe the actions that
would take place if undo or redo were invoked, by calling the
appropriate methods in the <code>DOMEditAction</code> instances.  Return
the empty string if the right one of canUndo()/canRedo() says
no.</li>
<li>Add undo and redo methods to the <code>LurchEditor</code> class that move
the index pointer up and down the stack, calling undo/redo in
each action as they do so.</li>
</ul>
<h2><a name='test-environment'></a>Test environment &nbsp;  <font size=-1><a href='#test-environment'><img src="link.png" class="anchor"></a></font></h2><h3><a name='test-app'></a>Test app &nbsp;  <font size=-1><a href='#test-app'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>Import into the project a UI toolkit such as
<a href="http://getbootstrap.com">Bootstrap</a>.
(If you use bootstrap, replace your link png with its link
glyphicon.)</li>
<li>Import that UI into both the app and test app pages, rewriting
them to fit its format if necessary.</li>
<li>Split the test app into tabs, one containing a view that shows
the document as HTML source.</li>
<li>Add to the test app a user interface for making any of the
editing API calls on any Node in the <code>LurchEditor</code>&#39;s main HTML
element (could be just a JS eval of the code in an input box).</li>
<li>Update the source view after every API call.</li>
</ul>
<h3><a name='easy-test-generation'></a>Easy test generation &nbsp;  <font size=-1><a href='#easy-test-generation'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>Have test app save the state of the model at the start and
after every API call, as well as storing all API calls, thus
keeping a full history.  API calls are recorded as the actual
code that was evaluated, easy to replay later (and objective).</li>
<li>Add buttons to the test app for marking points in the history
as correct or incorrect (with optional comments) and store
that data in the history as well</li>
<li>Create a UI for viewing that history, giving it a name, and
downloading it as a JSON file <code>putTestNameHere.json</code>.</li>
<li>Create a method in <a href="phantom-utils.litcoffee.html">phantom-utils</a>
(possibly rename to <code>test-utils</code>?) that can run such a test
history inside a jasmine test (i.e., one <code>describe</code> with a bunch
of <code>it</code>s and <code>expect</code>s in it.</li>
<li>Create a folder in the repository for holding such test JSON
files and organize it hierarchically by topic</li>
<li>Add to the <code>cake test</code> procedure the running of all test
histories, verifying each step, and outputting a report,
in <a href="https://daringfireball.net/projects/markdown/">Markdown</a>.</li>
<li>Categorize the outputs with section headers, etc., imitating
the structure of the folder hierarchy.</li>
</ul>
<h3><a name='better-access-to-automated-testing-results'></a>Better access to automated testing results &nbsp;  <font size=-1><a href='#better-access-to-automated-testing-results'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>As part of the <code>cake test</code> procedure, unite the JSON of all
the saved test histories into one big JSON object and create a
<code>.js</code> file that assigns that object to a global variable.</li>
<li>Import that <code>.js</code> file into the test app.</li>
<li>Create a UI for choosing a test to run from a hierarchical
list generated from that variable&#39;s value.</li>
<li>Create functionality that can replay the chosen test one
step at a time and show the expected vs. the actual, with
differences highlighted.</li>
</ul>
<h3><a name='later-when-you-put-the-repository-on-a-server'></a>Later, when you put the repository on a server &nbsp;  <font size=-1><a href='#later-when-you-put-the-repository-on-a-server'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>Have the server nightly do a git pull of the latest version.
Once that&#39;s working, have it run a shell script that does the
following.<ul>
<li>Back up the old HTML version of the test suite output.</li>
<li>Run the test suite.</li>
<li>Email the developers if and only if the new output differs
from the old in an important way (i.e., not just timings,
but results).</li>
</ul>
</li>
</ul>
<h2><a name='more-word-processing-foundation'></a>More Word Processing Foundation &nbsp;  <font size=-1><a href='#more-word-processing-foundation'><img src="link.png" class="anchor"></a></font></h2><h3><a name='events'></a>Events &nbsp;  <font size=-1><a href='#events'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>Make each call to <code>nodeEditHappened</code> (as well as each call to
undo or redo in a <code>DOMEditTracker</code>) fire events about which
address(es) in the DOM (below the tracker&#39;s main HTML element)
changed.  These events can be listened to by later bubbling and
validation features.</li>
<li>Have the test app update the HTML source view when it hears
one of those events, rather than after every API call.</li>
</ul>
<h3><a name='cursor'></a>Cursor &nbsp;  <font size=-1><a href='#cursor'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>Build the <code>LurchEditor</code> API for placing a cursor in the
document, or nowhere, depending on whether the document has
focus.</li>
<li>Add all the functions for dealing with that cursor as if it
were a real cursor<ul>
<li>insert a cursor before/after a given sub-node of the
editable DOM element (iff one isn’t already in the element
somewhere).</li>
<li>get the existing cursor object.</li>
<li>jump to abs pos, with or without moving the anchor</li>
<li>move by rel amt, with or without moving the anchor</li>
<li>insert text, HTML, or entire object before cursor</li>
<li>split content at cursor</li>
<li>replace selection with text, HTML, or entire object</li>
<li>change properties of selection (e.g., font, color)</li>
<li>delete character before/after cursor</li>
<li>delete selection</li>
<li>change properties of paragraph around cursor
(e.g., justification, indentation)</li>
<li>cut, copy, and paste
(See <a href="http://stackoverflow.com/a/11347714/670492">this StackOverflow answer</a> for a possibly
helpful way to put complex content on the clipboard from
JavaScript.)<ul>
<li>implement copy, and then cut is copy-then-delete</li>
<li>implement paste when there is no selection, and then paste
when there is a selection is just delete-then-paste</li>
</ul>
</li>
</ul>
</li>
<li>As you create each, create tests for it as well, and save
them in the repository</li>
</ul>
<h3><a name='keyboard'></a>Keyboard &nbsp;  <font size=-1><a href='#keyboard'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>Layer on top of the cursor functions a set of keyboard event
handlers, which call the cursor functions under the hood.<ul>
<li>text character = insert text before cursor or replace
selection with text</li>
<li>left/right arrow = move by rel amt +/-1</li>
<li>shift left/right arrow = same but without moving anchor</li>
<li>up, down, home, end, page up, page down = also movement,
but need to be more sophisticated about querying the view
(<a href="http://stackoverflow.com/a/3710561/670492">see if this information helps</a>)</li>
<li>enter = split paragraph into two</li>
<li>backspace = delete character before cursor, or cursor
selection</li>
<li>delete = delete character after cursor, or cursor
selection</li>
<li>Ctrl + B/I/U/L/R/E = apply properties to selection or
paragraph around cursor, as appropriate</li>
<li>Ctrl + X/C/V = cut/copy/paste</li>
</ul>
</li>
<li>In the test app, when the JS eval
input does not have focus (and yet we&#39;re in one of the main
view tabs, not the export-a-test-JSON view) react to
keyboard events by calling the <code>LurchEditor</code>&#39;s appropriate
keyboard API functions.</li>
<li>When the main controller is generating a test record, it
should record the calls it&#39;s sending to that API.
This may require extending the test
runner to also use that same API.</li>
</ul>
<h3><a name='mouse'></a>Mouse &nbsp;  <font size=-1><a href='#mouse'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>Should be handled similarly to Up, Home, etc. keys:
Create an API that sits on top of the low-level cursor API
and can accept mouse clicks and drags, translating them into
calls to the low-level API functions.</li>
<li>Connect mouse events in the app and test app to calls to this
new API in <code>LurchEditor</code>.</li>
<li><a href="http://jsfiddle.net/Xotic750/M7mgv/">How to detect on which element inside a large region the
user clicked</a></li>
<li><a href="http://stackoverflow.com/a/3710561/670492">How to find the particular character on which the user
clicked</a></li>
</ul>
<h3><a name='load-and-save'></a>Load and save &nbsp;  <font size=-1><a href='#load-and-save'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>Add to the main app the ability to load and save documents
from web storage</li>
<li>Add the ability to upload and download documents from the
local machine into/out of web storage</li>
<li>Add the ability to share documents that are in your web
storage with the world using something like
<a href="https://www.firebase.com/">Firebase</a> or a custom server.</li>
</ul>
<h2><a name='logical-foundation'></a>Logical Foundation &nbsp;  <font size=-1><a href='#logical-foundation'><img src="link.png" class="anchor"></a></font></h2><h3><a name='dependencies'></a>Dependencies &nbsp;  <font size=-1><a href='#dependencies'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>Create a way to give a document a title, author, language,
and version, like we did before.  But perhaps we can drop
language?  Version?</li>
<li>Create a way to find a document in the user&#39;s web storage
based on its URN.</li>
</ul>
<h3><a name='math'></a>Math &nbsp;  <font size=-1><a href='#math'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>Create a button or keystroke that allows you to insert a
<a href="http://mathquill.com/">MathQuill</a> instance in your document,
and stores it as a special kind of content.</li>
<li>Whenever the cursor (the browser&#39;s one, not the model&#39;s one)
is inside a MathQuill instance, frequently recompute the
content of that instance and store it in that content object
in the document.</li>
<li>Make ordinary keyboard motions of the cursor able to enter
and exit MathQuill instances.</li>
<li>Consider whether you can render the MathQuill using
<a href="http://www.mathjax.org/">MathJax</a> when the cursor exits,
to get prettier results.</li>
<li>Consider whether you can add the capability to do
MathJax-rendered LaTeX source, with a popup text box, like
in the Simple Math Editor in the desktop Lurch.</li>
</ul>
<h3><a name='groupers'></a>Groupers &nbsp;  <font size=-1><a href='#groupers'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>(throughout all the to-dos in this category, be sure to
create unit tests and verify that the test script can handle
them, to keep all of this honest and solid)</li>
<li>Give <code>LurchEditor</code> the ability to create groupers in pairs
(correctly nested) and if one is deleted its partner is
automatically deleted as well.</li>
<li>Create all the corresponding API, such as querying and
navigating the group hierarchy.</li>
<li>Decide the UI for groups, tags, etc.:
Same as old Lurch?  Something different?  Easier?  Better?</li>
<li>Build the 3 foundational grouper types, although so far all
that&#39;s happening is that the data about the user&#39;s choices
is getting stored in each group, but the groups don&#39;t
compute their meanings, don&#39;t modify one another, nothing
except store a record of the user&#39;s choices for later
computation by background workers.</li>
</ul>
<h3><a name='background-processing'></a>Background processing &nbsp;  <font size=-1><a href='#background-processing'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>Create the structure for running computations in the
background.  I think it will work like this:<ul>
<li>Add to the <code>LurchEditor</code> class a list of computations
that must be run on the document before it&#39;s done/stable.
This should be an attribute of the document that gets
preserved across load/save.</li>
<li>Upon each change, the editor will know whether that
change requires any recomputation, and if so, it enqueues
it in that attribute.<ul>
<li>The enqueue function is smart enough to dispatch a
WebWorker to handle anything enqueued, provided that
there are not too many workers already dispatched.</li>
<li>Whenever a worker completes its task, if there are
tasks on the queue, it gets given another.</li>
<li>The result of worker computations will often be just
the first step in a process, and thus will involve
enqueueing yet still more to-dos.  E.g., meaning
recomputation -&gt; revalidation -&gt; revalidation of
later stuff -&gt; etc.</li>
</ul>
</li>
</ul>
</li>
<li>All of the following test-related tools should know to wait
for all background processing to complete before examining
the result of any given action on the document and calling
that the &quot;next state&quot; of the document.  This can be achieved
by <code>LurchEditor</code> providing a function to say whether it&#39;s
still computing stuff or not.<ul>
<li>automated headless test runner</li>
<li>web-based test generator</li>
<li>web-based test replayer</li>
</ul>
</li>
</ul>
<h3><a name='background-computation-of-the-property-graph'></a>Background computation of the property graph &nbsp;  <font size=-1><a href='#background-computation-of-the-property-graph'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>more detail needed here later</li>
<li>create unit tests as you go</li>
</ul>
<h3><a name='background-computation-of-bubble-meanings'></a>Background computation of bubble meanings &nbsp;  <font size=-1><a href='#background-computation-of-bubble-meanings'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>(yes, that is a huge task that is contingent upon decisions
about parsing, etc., but simple defaults could be put in
place to start, such as a sensible interpretation of
MathQuill content, or simpleLob notation only, or whatever)</li>
<li>create unit tests as you go</li>
</ul>
<h3><a name='background-validation-probably-in-stages'></a>Background validation, probably in stages &nbsp;  <font size=-1><a href='#background-validation-probably-in-stages'><img src="link.png" class="anchor"></a></font></h3><ul>
<li>(again, first we should check to see if validation was
redesigned in any important way, including any relevant
theorems proven based on assumptions that you therefore must
guarantee hold in your implementation)</li>
<li>create unit tests as you go</li>
</ul>
<h2><a name='for-later'></a>For later &nbsp;  <font size=-1><a href='#for-later'><img src="link.png" class="anchor"></a></font></h2><p>The following unit tests were skipped earlier in development,
because they are less important than the ones that were written,
and yet are included here for the sake of completeness, and so that
they are not forgotten.  A complete unit testing suite would have
tests for all of the following cases.</p>
<ul>
<li><a href="domeditaction-spec.litcoffee.html">The tests for the DOMEditAction constructor</a> test every constructor by
passing it correct parameters.  They do not do any testing to
ensure that the constructor throws an error upon receiving
incorrect parameters, except one test that ensures that the
action type is valid.  In particular, no testing is done to
ensure that the node must be valid, nor that for each individual
action type, the parameters must be given correctly.</li>
</ul>
<p>Documentation in most unit test spec files promises that <a href="basic-spec.litcoffee.html">the
basic spec file</a> will provide complete
documentation on how to read and understand a test spec file.  But
it does not.</p>
<ul>
<li>Add documentation to that file so that someone who does not know
how to read a test spec file could learn it from that file.</li>
</ul>

        </div>
        <div id="right">
            <h3 align=center>Navigation</h3><br><h3><a href='index.md.html'>webLurch home</a></h3><p>.</p><ul><li><a href='buildutils.litcoffee.html'>buildutils.litcoffee</a></li><li><a href='cake.litcoffee.html'>cake.litcoffee</a></li></ul><p>./app</p><ul><li><a href='../app/index.html'>index.html</a></li></ul><p>./doc</p><ul><li><a href='plan.md.html'>plan.md</a></li><li><a href='progress.md.html'>progress.md</a></li><li><a href='test-results.md.html'>test-results.md</a></li></ul><p>./src</p><ul><li><a href='domeditaction.litcoffee.html'>domeditaction.litcoffee</a></li><li><a href='domedittracker.litcoffee.html'>domedittracker.litcoffee</a></li><li><a href='domutils.litcoffee.html'>domutils.litcoffee</a></li><li><a href='lurcheditor.litcoffee.html'>lurcheditor.litcoffee</a></li></ul><p>./test</p><ul><li><a href='basic-spec.litcoffee.html'>basic-spec.litcoffee</a></li><li><a href='domeditaction-spec.litcoffee.html'>domeditaction-spec.litcoffee</a></li><li><a href='domedittracker-spec.litcoffee.html'>domedittracker-spec.litcoffee</a></li><li><a href='domutils-spec.litcoffee.html'>domutils-spec.litcoffee</a></li><li><a href='lurcheditor-spec.litcoffee.html'>lurcheditor-spec.litcoffee</a></li><li><a href='phantom-utils.litcoffee.html'>phantom-utils.litcoffee</a></li><li><a href='undoredo-spec.litcoffee.html'>undoredo-spec.litcoffee</a></li></ul><p>./testapp</p><ul><li><a href='utils.litcoffee.html'>utils.litcoffee</a></li><li><a href='../testapp/index.html'>index.html</a></li></ul>
        </div>
    </body>
</html>
