<html>
    <head>
        <link rel="stylesheet"
              href="../bootstrap/css/bootstrap.min.css"/>
        <link rel="stylesheet" href="./main.css"/>
        <link rel="stylesheet" href="./obsidian.css"/>
        <link rel="shortcut icon" href="favicon.png"/>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config( {
              tex2jax: { inlineMath: [ [ '$', '$' ], [ '\\(', '\\)' ] ] }
            } );
        </script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <title>webLurch docs: buildutils</title>
    </head>
    <body>
        <div id="left">
            <p align=center>Page contents</p>
<p><a href='#utility-functions-supporting-the-build-process'>Utility functions supporting the build process</a></p><ul>
<li><a href='#task-queue'>Task queue</a></li><ul>
<li><a href='#enqueueing-and-dequeueing-tasks'>Enqueueing and dequeueing tasks</a></li><li><a href='#automatic-dequeueing-and-messaging'>Automatic dequeueing and messaging</a></li></ul>
<li><a href='#verifying-npm-install-has-been-run'>Verifying npm install has been run</a></li><li><a href='#fetching-filenames-from-a-folder'>Fetching filenames from a folder</a></li><li><a href='#loading-contents-of-text-files'>Loading contents of text files</a></li><li><a href='#compile-literate-coffeescript-files'>Compile literate coffeescript files</a></li><li><a href='#converting-markdown-to-html'>Converting Markdown to HTML</a></li>
        </div>
        <div id="middle">
            <h1><a name='utility-functions-supporting-the-build-process'></a>Utility functions supporting the build process &nbsp;  <font size=-1><a href='#utility-functions-supporting-the-build-process'><span class="glyphicon glyphicon-link"></span></a></font></h1><p>Several places in this module we access the filesystem, or spawn
child processes with <code>exec</code>.  So import those modules up front.</p>
<pre class="hljs"><code>fs = <span class="hljs-built_in">require</span> <span class="hljs-string">'fs'</span>
{ exec } = <span class="hljs-built_in">require</span> <span class="hljs-string">'child_process'</span>
</code></pre><h2><a name='task-queue'></a>Task queue &nbsp;  <font size=-1><a href='#task-queue'><span class="glyphicon glyphicon-link"></span></a></font></h2><h3><a name='enqueueing-and-dequeueing-tasks'></a>Enqueueing and dequeueing tasks &nbsp;  <font size=-1><a href='#enqueueing-and-dequeueing-tasks'><span class="glyphicon glyphicon-link"></span></a></font></h3><p>The next few functions make it possible to add tasks to a queue and
dequeue them later into active duty.  Enqueueing any string stores
it for later execution, which happens when you dequeue; that passes
the string to <code>cake</code>&#39;s <code>invoke</code>.  Such strings should be names of
tasks defined in the cakefile.</p>
<p>First, we need an empty queue.</p>
<pre class="hljs"><code>queue = []
</code></pre><p>Next, the enqueue function simply pushes onto that array.</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">enqueue</span> = <span class="hljs-params">( tasks... )</span> -&gt;</span>
    queue = queue.concat tasks
</code></pre><p>The dequeue function passes the next task name on the queue to
<code>cake</code>&#39;s <code>invoke</code> function (thereby removing it from the queue), if
and only if there is a next task to dequeue.  The exception to this
is that if the next task on the queue is not a string (a task name)
but instead is a function, then we just call it.</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">dequeue</span> = -&gt;</span>
    <span class="hljs-keyword">if</span> queue.length &gt; <span class="hljs-number">0</span>
        next = queue.shift()
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> next <span class="hljs-keyword">is</span> <span class="hljs-string">'string'</span> <span class="hljs-keyword">then</span> invoke next <span class="hljs-keyword">else</span> next()
</code></pre><h3><a name='automatic-dequeueing-and-messaging'></a>Automatic dequeueing and messaging &nbsp;  <font size=-1><a href='#automatic-dequeueing-and-messaging'><span class="glyphicon glyphicon-link"></span></a></font></h3><p>Each task function would therefore have to end with a call to
<code>dequeue</code>, so that after each task is completed, if there are more
tasks still in the queue, the next one gets run.  But that is
undesirable.  It would be better if the task definer provided by
<code>cake</code> did this for us.  So we redefine it to do so.</p>
<p>While we&#39;re at it, we will print messages saying which tasks are
being started/completed, so that the individual tasks no longer
need to handle that on their own.</p>
<p>First, define a new task function unique to this module.</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">task</span> = <span class="hljs-params">( name, description, func )</span> -&gt;</span>
</code></pre><p>Call the cake task function, but this time supply a different task
execution function, one that does whatever the actual task function
is, then calls dequeue.</p>
<pre class="hljs"><code>    task name, description,<span class="hljs-function"> -&gt;</span>
        <span class="hljs-built_in">console</span>.log <span class="hljs-string">"Begin building <span class="hljs-subst">#{name}</span>..."</span>
        func()
        <span class="hljs-built_in">console</span>.log <span class="hljs-string">"Done building <span class="hljs-subst">#{name}</span>."</span>
        <span class="hljs-built_in">exports</span>.dequeue()
</code></pre><p>Now, some build tasks may be asynchronous, and we&#39;ll need to wait
until they&#39;re done before calling dequeue.  So here&#39;s a way to
define asynchronous tasks whose task functions will take a <code>done</code>
function that you should call when the task is done.</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">asyncTask</span> = <span class="hljs-params">( name, description, func )</span> -&gt;</span>
    task name, description,<span class="hljs-function"> -&gt;</span>
        <span class="hljs-built_in">console</span>.log <span class="hljs-string">"Begin building <span class="hljs-subst">#{name}</span>..."</span>
        func<span class="hljs-function"> -&gt;</span>
            <span class="hljs-built_in">console</span>.log <span class="hljs-string">"Done building <span class="hljs-subst">#{name}</span>."</span>
            <span class="hljs-built_in">exports</span>.dequeue()
</code></pre><p>Those last lines mean that your asynchronous task function needs to
take a <code>done</code> function as parameter, and call it when the task is
finally complete.  It will then print done and do a dequeue.</p>
<h2><a name='verifying-npm-install-has-been-run'></a>Verifying npm install has been run &nbsp;  <font size=-1><a href='#verifying-npm-install-has-been-run'><span class="glyphicon glyphicon-link"></span></a></font></h2><p>It is useful to verify that <code>npm install</code> has been run in this
folder before attempting to load <code>node</code> modules mentioned in the
<code>package.json</code> file.</p>
<p>This is because the build process relies on a few such modules, and
it is very frustrating for the build process to crash because it&#39;s
missing one of them, showing what would be a cryptic error message
to a new downloader.  So this routine first checks to be sure that
the required modules are present, and exits with a helpful error
message if any are not.</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">verifyPackagesInstalled</span> = -&gt;</span>
    pj = JSON.parse fs.readFileSync <span class="hljs-string">'package.json'</span>
    missing = ( key <span class="hljs-keyword">for</span> key <span class="hljs-keyword">of</span> pj.dependencies <span class="hljs-keyword">when</span> \
        <span class="hljs-keyword">not</span> fs.existsSync <span class="hljs-string">"./node_modules/<span class="hljs-subst">#{key}</span>"</span> )
        .join <span class="hljs-string">', '</span>
    <span class="hljs-keyword">if</span> missing <span class="hljs-keyword">isnt</span> <span class="hljs-string">''</span>
        <span class="hljs-built_in">console</span>.log <span class="hljs-string">"""
                    This folder is not yet set up.
                    Missing node.js package(s): <span class="hljs-subst">#{missing}</span>
                    To fix this, run: npm install
                    """</span>
        process.exit <span class="hljs-number">1</span>
</code></pre><h2><a name='fetching-filenames-from-a-folder'></a>Fetching filenames from a folder &nbsp;  <font size=-1><a href='#fetching-filenames-from-a-folder'><span class="glyphicon glyphicon-link"></span></a></font></h2><p>Often during the build process, we need a list of all files of a
certain type in a certain directory.  This simple function does
that for us, returning the result as an array.</p>
<p>It takes parameters in pairs, a folder as a string, then a regexp
to use for filtering files in that folder (only those that match
are returned).  As many folder-regexp pairs as you want may be
passed; the concatenated results are returned, each as a string
that begins with the folder name it belongs in (e.g.,
<code>&#39;data/images/thing.png&#39;</code>).</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">dir</span> = <span class="hljs-params">( args... )</span> -&gt;</span>
    result = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>..args.length-<span class="hljs-number">1</span>] <span class="hljs-keyword">by</span> <span class="hljs-number">2</span>
        <span class="hljs-keyword">if</span> args[i][-<span class="hljs-number">1.</span>.] != <span class="hljs-string">'/'</span> <span class="hljs-keyword">then</span> args[i] += <span class="hljs-string">'/'</span>
        <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> fs.readdirSync args[i]
            <span class="hljs-keyword">if</span> args[i+<span class="hljs-number">1</span>].test file
                result.push args[i]+file
    result
</code></pre><h2><a name='loading-contents-of-text-files'></a>Loading contents of text files &nbsp;  <font size=-1><a href='#loading-contents-of-text-files'><span class="glyphicon glyphicon-link"></span></a></font></h2><p>It is convenient to be able to load the contents of many text files
at once, and this function does so.  Pass it an array of filenames,
and you get back an object whose keys are those filenames and whose
values are the text contents of the files.</p>
<p>Obviously for many very large files, this will use a lot of memory.
For a reasonable number of text files, there is no problem.</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">readFiles</span> = <span class="hljs-params">( names )</span> -&gt;</span>
    result = { }
    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names
        <span class="hljs-built_in">console</span>.log <span class="hljs-string">"\tReading <span class="hljs-subst">#{name}</span>..."</span>
        result[name] = fs.readFileSync name, <span class="hljs-string">'utf8'</span>
    result
</code></pre><h2><a name='compile-literate-coffeescript-files'></a>Compile literate coffeescript files &nbsp;  <font size=-1><a href='#compile-literate-coffeescript-files'><span class="glyphicon glyphicon-link"></span></a></font></h2><p>Call this function with an input filename and a callback function.
The input filename should contain the path also, unless it is the
current directory.</p>
<p>The input file should be a <code>.litcoffee</code> file, and this function
will generate a corresponding <code>.js</code> file (compiled coffeescript),
<code>.min.js</code> file (minified version of the previous), and
<code>.map</code> and <code>.min.js.map</code> files (source map files for both).
When the compilation is done, the callback function will be called.</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">compile</span> = <span class="hljs-params">( srcfile, callback )</span> -&gt;</span>
</code></pre><p>Separate the path and filename out from one another.</p>
<pre class="hljs"><code>    [ all, path, file ] = <span class="hljs-regexp">/^(.*)\/([^\\]*)$/</span>.exec srcfile
    <span class="hljs-built_in">console</span>.log <span class="hljs-string">"\tCompiling <span class="hljs-subst">#{srcfile}</span>..."</span>
</code></pre><p>Run the <code>coffee</code> compiler on the file, also creating a source map.
This generates both <code>.js</code> and <code>.js.map</code> files.</p>
<pre class="hljs"><code>    exec <span class="hljs-string">"coffee --map --compile <span class="hljs-subst">#{file}</span>"</span>, { cwd : path },
    <span class="hljs-function"><span class="hljs-params">( err, stdout, stderr )</span> -&gt;</span>
        <span class="hljs-built_in">console</span>.log stdout + stderr <span class="hljs-keyword">if</span> stdout + stderr
        <span class="hljs-keyword">throw</span> err <span class="hljs-keyword">if</span> err
</code></pre><p>Run <a href="http://github.com/mishoo/UglifyJS">uglifyjs</a> to minify the
results, taking source maps into account.  Call the callback when
done, or throw an error if there was one.</p>
<p>(The <code>uglify</code> output is not printed unless there was an error,
because <code>uglify</code> dumps a bit of spam I&#39;m suppressing.)</p>
<pre class="hljs"><code>        base = <span class="hljs-regexp">/^(.*)\.[^.]*$/</span>.exec( file )[<span class="hljs-number">1</span>]
        <span class="hljs-built_in">console</span>.log <span class="hljs-string">"\tMinifying <span class="hljs-subst">#{base}</span>.js..."</span>
        exec <span class="hljs-string">"../node_modules/uglify-js/bin/uglifyjs "</span> +
             <span class="hljs-string">"-c -m -v false --in-source-map <span class="hljs-subst">#{base}</span>.map "</span> +
             <span class="hljs-string">"-o <span class="hljs-subst">#{base}</span>.min.js "</span> +
             <span class="hljs-string">"--source-map <span class="hljs-subst">#{base}</span>.min.js.map"</span>, { cwd : path },
        <span class="hljs-function"><span class="hljs-params">( err, stdout, stderr )</span> -&gt;</span>
            <span class="hljs-keyword">if</span> err <span class="hljs-keyword">then</span> <span class="hljs-built_in">console</span>.log stdout + stderr ; <span class="hljs-keyword">throw</span> err
            callback()
</code></pre><h2><a name='converting-markdown-to-html'></a>Converting Markdown to HTML &nbsp;  <font size=-1><a href='#converting-markdown-to-html'><span class="glyphicon glyphicon-link"></span></a></font></h2><p>The following function uses the
<a href="http://github.com/chjj/marked">marked</a> module to parse
<a href="http://daringfireball.net/projects/markdown">Markdown</a>, including
syntax highlighting of indented code blocks as
<a href="http://coffeescript.org">coffeescript</a>.  The highlighting is done
by <a href="http://highlightjs.org">highlight.js</a>, and one of its
stylehseets is already installed in the <code>doc/</code> output folder.</p>
<p>The following image is used to indicate an anchor.</p>
<pre class="hljs"><code>linkcode = <span class="hljs-string">'&lt;span class="glyphicon glyphicon-link"&gt;&lt;/span&gt;'</span>
</code></pre><p>And now, the conversion function.</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">md2html</span> = <span class="hljs-params">( infile )</span> -&gt;</span>
    marked = <span class="hljs-built_in">require</span> <span class="hljs-string">'marked'</span>
</code></pre><p>We install a routine that creates headings in the format we want
them for our documentation.  This routine makes each heading an
anchor so that links can point to it.  It also makes headings in
test files include links to the results of those tests.  Finally,
it remembers all the headings it makes in a file, and returns not
only the generated HTML but a corresponding table of contents (TOC)
with links to each of the anchors in each of the generated
headings.</p>
<pre class="hljs"><code>    renderer = <span class="hljs-keyword">new</span> marked.Renderer()
    toc = <span class="hljs-string">''</span>
    lastlevel = <span class="hljs-number">1</span>
    renderer.<span class="hljs-function"><span class="hljs-title">heading</span> = <span class="hljs-params">( text, level )</span> -&gt;</span>
</code></pre><p>Remove any instances of XHTML escape characters before creating
links, to be consistent with anchor names generated elsewhere.</p>
<pre class="hljs"><code>        collapsed = text.replace( <span class="hljs-regexp">/&amp;\w+;/g</span>, <span class="hljs-string">' '</span> )
        <span class="hljs-keyword">if</span> m = <span class="hljs-regexp">/^(.*) \([0-9.]+ ms\)/</span>.exec collapsed
            escapedText = <span class="hljs-built_in">exports</span>.escapeHeading m[<span class="hljs-number">1</span>]
        <span class="hljs-keyword">else</span>
            escapedText = <span class="hljs-built_in">exports</span>.escapeHeading collapsed
</code></pre><p>If this is a heading in a test suite, create a link to the test
results.  The only exception is top-level headings, which do not
have corresponding entries in the test suite resutls page.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> level &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-regexp">/-spec\.litcoffee/</span>.test infile
            results = <span class="hljs-string">"&lt;font size=-1&gt;&lt;a href='"</span> +
                      <span class="hljs-string">"test-results.md.html#"</span> +
                      <span class="hljs-string">"<span class="hljs-subst">#{escapedText}</span>'&gt;see results&lt;/a&gt;&lt;/font&gt;"</span>
        <span class="hljs-keyword">else</span>
            results = <span class="hljs-string">''</span>
</code></pre><p>Accrue headings in the <code>toc</code> variable declared above.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> level &gt; lastlevel
            toc += <span class="hljs-string">'&lt;ul&gt;\n'</span>
            lastlevel = level
        <span class="hljs-keyword">while</span> level &lt; lastlevel
            toc += <span class="hljs-string">'&lt;/ul&gt;\n'</span>
            lastlevel = level
        toc += <span class="hljs-string">"&lt;<span class="hljs-subst">#{<span class="hljs-keyword">if</span> level &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> <span class="hljs-string">'li'</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'p'</span>}</span>&gt;"</span> +
               <span class="hljs-string">"&lt;a href='#<span class="hljs-subst">#{escapedText}</span>'&gt;<span class="hljs-subst">#{text}</span>&lt;/a&gt;"</span> +
               <span class="hljs-string">"&lt;/<span class="hljs-subst">#{<span class="hljs-keyword">if</span> level &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> <span class="hljs-string">'li'</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'p'</span>}</span>&gt;"</span>
</code></pre><p>Return the final HTML string for the heading</p>
<pre class="hljs"><code>        <span class="hljs-string">"&lt;h<span class="hljs-subst">#{level}</span>&gt;&lt;a name='<span class="hljs-subst">#{escapedText}</span>'&gt;&lt;/a&gt;<span class="hljs-subst">#{text}</span> "</span> +
        <span class="hljs-string">"&amp;nbsp; <span class="hljs-subst">#{results}</span> &lt;font size=-1&gt;&lt;a href='"</span> +
        <span class="hljs-string">"#<span class="hljs-subst">#{escapedText}</span>'&gt;<span class="hljs-subst">#{linkcode}</span>&lt;/a&gt;&lt;/font&gt;&lt;/h<span class="hljs-subst">#{level}</span>&gt;"</span>
</code></pre><p>Install the renderer just created, as well as highlighting support
provided by <code>highlight.js</code>.</p>
<pre class="hljs"><code>    marked.setOptions
        <span class="hljs-attribute">highlight</span>: <span class="hljs-function"><span class="hljs-params">( code )</span> -&gt;</span>
            <span class="hljs-built_in">require</span>( <span class="hljs-string">'highlight.js'</span> )
                .highlight( <span class="hljs-string">'coffeescript'</span>, code ).value
        <span class="hljs-attribute">renderer</span>: renderer
</code></pre><p>The return value is an object, containing both the HTML for the
page and the HTML for the page&#39;s table of contents (<code>toc</code>).</p>
<pre class="hljs"><code>    {
        html : marked fs.readFileSync infile, <span class="hljs-string">'utf8'</span>
        toc : toc
    }
</code></pre><p>This utility function escapes text into lower-case with no spaces,
and is used in a routine above, as well as other parts of the build
process.</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">escapeHeading</span> = <span class="hljs-params">( text )</span> -&gt;</span>
    text.toLowerCase().replace <span class="hljs-regexp">/[^\w]+/g</span>, <span class="hljs-string">'-'</span>
</code></pre>
        </div>
        <div id="right">
            <h3 align=center>Navigation</h3><br><h3><a href='index.md.html'>webLurch home</a></h3><p>.</p><ul><li><a href='buildutils.litcoffee.html'>buildutils.litcoffee</a></li><li><a href='cake.litcoffee.html'>cake.litcoffee</a></li></ul><p>./app</p><ul><li><a href='../app/index.html'>index.html</a></li></ul><p>./doc</p><ul><li><a href='plan.md.html'>plan.md</a></li><li><a href='progress.md.html'>progress.md</a></li><li><a href='test-app-help.md.html'>test-app-help.md</a></li><li><a href='test-results.md.html'>test-results.md</a></li></ul><p>./src</p><ul><li><a href='domeditaction.litcoffee.html'>domeditaction.litcoffee</a></li><li><a href='domedittracker.litcoffee.html'>domedittracker.litcoffee</a></li><li><a href='domutils.litcoffee.html'>domutils.litcoffee</a></li><li><a href='lurcheditor.litcoffee.html'>lurcheditor.litcoffee</a></li></ul><p>./test</p><ul><li><a href='all-histories-spec.litcoffee.html'>all-histories-spec.litcoffee</a></li><li><a href='basic-spec.litcoffee.html'>basic-spec.litcoffee</a></li><li><a href='domeditaction-spec.litcoffee.html'>domeditaction-spec.litcoffee</a></li><li><a href='domedittracker-spec.litcoffee.html'>domedittracker-spec.litcoffee</a></li><li><a href='domutils-spec.litcoffee.html'>domutils-spec.litcoffee</a></li><li><a href='lurcheditor-spec.litcoffee.html'>lurcheditor-spec.litcoffee</a></li><li><a href='phantom-utils.litcoffee.html'>phantom-utils.litcoffee</a></li><li><a href='undoredo-spec.litcoffee.html'>undoredo-spec.litcoffee</a></li></ul><p>./testapp</p><ul><li><a href='utils.litcoffee.html'>utils.litcoffee</a></li><li><a href='../testapp/index.html'>index.html</a></li></ul>
        </div>
    </body>
</html>
