<html>
    <head>
        <link rel="stylesheet"
              href="../bootstrap/css/bootstrap.min.css"/>
        <link rel="stylesheet" href="./main.css"/>
        <link rel="stylesheet" href="./obsidian.css"/>
        <link rel="shortcut icon" href="favicon.png"/>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config( {
              tex2jax: { inlineMath: [ [ '$', '$' ], [ '\\(', '\\)' ] ] }
            } );
        </script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <title>webLurch docs: domedittracker</title>
    </head>
    <body>
        <div id="left">
            <p align=center>Page contents</p>
<p><a href='#dom-edit-tracker-class'>DOM Edit Tracker class</a></p><ul>
<li><a href='#tracking-instances'>Tracking instances</a></li><li><a href='#constructor'>Constructor</a></li><li><a href='#getters'>Getters</a></li><li><a href='#setters'>Setters</a></li><li><a href='#undo-redo-stack'>Undo/redo stack</a></li><li><a href='#listeners'>Listeners</a></li>
        </div>
        <div id="middle">
            <h1><a name='dom-edit-tracker-class'></a>DOM Edit Tracker class &nbsp;  <font size=-1><a href='#dom-edit-tracker-class'><span class="glyphicon glyphicon-link"></span></a></font></h1><pre class="hljs"><code><span class="hljs-built_in">window</span>.DOMEditTracker = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DOMEditTracker</span></span>
</code></pre><p>A <code>DOMEditTracker</code> is responsible for watching the edits to the
DOM within a single HTML DIV element, and thus it takes such a DIV
at construction time.</p>
<h2><a name='tracking-instances'></a>Tracking instances &nbsp;  <font size=-1><a href='#tracking-instances'><span class="glyphicon glyphicon-link"></span></a></font></h2><p>The class itself also tracks all instances thereof currently in
memory, so that it can find the one whose DIV contains any given
DOM Node.  This way when changes take place in a DOM Node, the
corresponding edit tracker, if any, can be notified.</p>
<pre class="hljs"><code>    <span class="hljs-property">@instances</span> = []
</code></pre><p>Here is the class method taht finds the edit tracker instance in
charge of an ancestor of any given DOM Node.  It returns the
<code>DOMEditTracker</code> instance if there is one, and null otherwise.</p>
<pre class="hljs"><code>    <span class="hljs-property">@instanceOver</span> = <span class="hljs-function"><span class="hljs-params">( node )</span> -&gt;</span>
        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Node <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        <span class="hljs-keyword">for</span> tracker <span class="hljs-keyword">in</span> <span class="hljs-property">@instances</span>
            <span class="hljs-keyword">if</span> tracker.getElement() <span class="hljs-keyword">is</span> node
                <span class="hljs-keyword">return</span> tracker
        <span class="hljs-property">@instanceOver</span> node.parentNode
</code></pre><h2><a name='constructor'></a>Constructor &nbsp;  <font size=-1><a href='#constructor'><span class="glyphicon glyphicon-link"></span></a></font></h2><pre class="hljs"><code>    <span class="hljs-attribute">constructor</span>: <span class="hljs-function"><span class="hljs-params">( div )</span> -&gt;</span>
</code></pre><p>If they passed <em>something</em> as the <code>div</code> parameter, but it wasn&#39;t a
DIV, then throw an Error.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> div <span class="hljs-keyword">and</span> div?.tagName <span class="hljs-keyword">isnt</span> <span class="hljs-string">'DIV'</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error <span class="hljs-string">'DOMEditTracker can only be '</span> +
                            <span class="hljs-string">'constructed in a DIV node'</span>
</code></pre><p>Since the div was not an error, store it, or if they omitted it,
store null.</p>
<pre class="hljs"><code>        <span class="hljs-property">@element</span> = div <span class="hljs-keyword">or</span> <span class="hljs-literal">null</span>
</code></pre><p>In either case, initialize the internal undo/redo stack of
<code>DOMEditAction</code> instances to be empty, with a stack pointer of
zero.  (Documentation on how this stack pointer behaves appears in
the <a href="#undo-redo-stack">undo/redo stack section</a>, below.)</p>
<pre class="hljs"><code>        <span class="hljs-property">@stack</span> = []
        <span class="hljs-property">@stackPointer</span> = <span class="hljs-number">0</span>
</code></pre><p>Furthermore, we keep a boolean about whether we&#39;re supposed to add
actions to that stack or not as they occur.  By default it is
always on, but is disabled briefly when undo/redo actions take
place.</p>
<pre class="hljs"><code>        <span class="hljs-property">@stackRecording</span> = <span class="hljs-literal">true</span>
</code></pre><p>Sometimes actions recorded on the stack happen in a block, and
should form a compound action for placement on the stack.  As such
action sequences are coming in, they are stored in the following
temporary variable.  When it is null, no compound action is being
constructed, and the tracker should just push each individual edit
action onto the stack separately.  The &quot;actions&quot; variable will be
an array and the &quot;name&quot; variable a string naming it, during
recording of a compound action.</p>
<pre class="hljs"><code>        <span class="hljs-property">@compoundActions</span> = <span class="hljs-literal">null</span>
        <span class="hljs-property">@compoundName</span> = <span class="hljs-literal">null</span>
</code></pre><p>Each instance will also have a list of listeners that should be
notified whenever changes take place in this instance&#39;s element.
We store those listeners as an array of callbacks, in this member.</p>
<pre class="hljs"><code>        <span class="hljs-property">@listeners</span> = []
</code></pre><p>And add this newly created instance to the list of all instances.</p>
<pre class="hljs"><code>        DOMEditTracker.instances.push <span class="hljs-keyword">this</span>
</code></pre><h2><a name='getters'></a>Getters &nbsp;  <font size=-1><a href='#getters'><span class="glyphicon glyphicon-link"></span></a></font></h2><p>Although in CoffeeScript, no members are truly private, the
intent is that the fields of an object should not be directly
accessed from outside the class except through getters and
setters.</p>
<p>The first is for querying the element passed at construction time,
over which this object has taken &quot;ownership.&quot;</p>
<pre class="hljs"><code>    <span class="hljs-attribute">getElement</span>:<span class="hljs-function"> -&gt;</span> <span class="hljs-property">@element</span>
</code></pre><p>Then we provide one for querying the stack of edit actions.  A copy
of the stack is returned, so that the caller may modify it as they
see fit without harming this object.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">getEditActions</span>:<span class="hljs-function"> -&gt;</span> <span class="hljs-property">@stack</span>[..]
</code></pre><h2><a name='setters'></a>Setters &nbsp;  <font size=-1><a href='#setters'><span class="glyphicon glyphicon-link"></span></a></font></h2><p>The user can ask to clear out the edit actions stack with the
following method.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">clearStack</span>:<span class="hljs-function"> -&gt;</span> <span class="hljs-property">@stack</span> = []
</code></pre><h2><a name='undo-redo-stack'></a>Undo/redo stack &nbsp;  <font size=-1><a href='#undo-redo-stack'><span class="glyphicon glyphicon-link"></span></a></font></h2><p>The stack pointer initialized in the <a href="#constructor">constructor</a> is
an integer that is one greater than the index of the last performed
action.  It satisfies the following criteria.</p>
<ul>
<li>When it equals the stack length, then the last action done is
the last action on the stack, and was <em>not</em> an &quot;undo.&quot;  It was
either an action done for the first time, or was a &quot;redo.&quot;</li>
<li>When it is less than the stack length, then the last action
done was either an &quot;undo&quot; or a &quot;redo,&quot; as the user navigated
the undo/redo stack with buttons/keyboard shortcuts/etc.</li>
</ul>
<p>To preserve these two properties, we implement the following
features.</p>
<p>When any editing takes place inside the DOM tree watched by an
instance of this class, the instance needs to be notified of it.
We therefore provide this method by which it can be notified.</p>
<p>It not only pushes the action onto the undo/redo stack, but,
if needed, it also truncates the stack to have length equal to the
stack pointer before using the superclass&#39;s implementation to
append the latest action to that stack.  After doing so, it updates
the pointer to equal the stack length, thus preserving the
invariant that the final action on the stack was the most recently
completed one.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">nodeEditHappened</span>: <span class="hljs-function"><span class="hljs-params">( action )</span> -&gt;</span>
</code></pre><p>The one parameter should be an instance of the <code>DOMEditAction</code>
class.  If it is not, it is ignored.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> action <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> DOMEditAction <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span>
</code></pre><p>If this action is a null action, then ignore it.  Listeners and the
undo/redo stack only want to track actual changes, but null actions
represent no change.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> action.isNullAction() <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span>
</code></pre><p>Even if we&#39;re not recording the actions on our internal undo/redo
stack, we must still notify any listeners of any changes that
happen.</p>
<pre class="hljs"><code>        listener action <span class="hljs-keyword">for</span> listener <span class="hljs-keyword">in</span> <span class="hljs-property">@listeners</span>
</code></pre><p>The only further actions this routine takes are recording the
action on the undo/redo stack, so now is when we should quit if
stack recording is turned off.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-property">@stackRecording</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span>
</code></pre><p>If this object is building a compound action, then append the
current action to that pending compound action, but do nothing
else.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> <span class="hljs-property">@compoundActions</span> <span class="hljs-keyword">isnt</span> <span class="hljs-literal">null</span>
            <span class="hljs-property">@compoundActions</span>.push action
            <span class="hljs-keyword">return</span>
</code></pre><p>Truncate the stack if necessary, then push the value onto it.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> <span class="hljs-property">@stackPointer</span> &lt; <span class="hljs-property">@stack</span>.length
            <span class="hljs-property">@stack</span> = <span class="hljs-property">@stack</span>[...<span class="hljs-property">@stackPointer</span>]
        <span class="hljs-property">@stack</span>.push action
</code></pre><p>The stack pointer must always be after the last-performed action,
so we must update it here, having just recorded a newly-performed
action.</p>
<pre class="hljs"><code>        <span class="hljs-property">@stackPointer</span> = <span class="hljs-property">@stack</span>.length
</code></pre><p>When actions are being recorded, the user can stipulate that a
sequence of successive actions form a logical unit, and thus should
be recorded as a compound action.  We provide the following two
methods for indicating the start and end of a compound action.</p>
<p>The user can flag the beginning of a sequence of actions using the
following routine.  It does nothing if another sequence is already
underway.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">startCompoundAction</span>: <span class="hljs-function"><span class="hljs-params">( name )</span> -&gt;</span>
        <span class="hljs-keyword">if</span> <span class="hljs-property">@compoundActions</span> <span class="hljs-keyword">isnt</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span>
        <span class="hljs-property">@compoundActions</span> = []
        <span class="hljs-property">@compoundName</span> = name
</code></pre><p>The user later flags the end of the sequence of actions using the
following routine.  It does nothing if no sequence is underway.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">endCompoundAction</span>:<span class="hljs-function"> -&gt;</span>
        <span class="hljs-keyword">if</span> <span class="hljs-property">@compoundActions</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span>
</code></pre><p>Create the new action and clear out the temporary variables.</p>
<pre class="hljs"><code>        action = <span class="hljs-keyword">new</span> DOMEditAction <span class="hljs-string">'compound'</span>, <span class="hljs-property">@compoundActions</span>
        <span class="hljs-keyword">if</span> <span class="hljs-property">@compoundName</span> <span class="hljs-keyword">then</span> action.name = <span class="hljs-property">@compoundName</span>
        <span class="hljs-property">@compoundActions</span> = <span class="hljs-literal">null</span>
        <span class="hljs-property">@compoundName</span> = <span class="hljs-literal">null</span>
</code></pre><p>Inform this object that the comound edit happened, so that it can
be recorded on the stack.</p>
<pre class="hljs"><code>        <span class="hljs-property">@nodeEditHappened</span> action
</code></pre><p>We add <code>canUndo</code> and <code>canRedo</code> methods to the class that just
report whether the stack pointer isn&#39;t at the top or bottom of the
stack.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">canUndo</span>:<span class="hljs-function"> -&gt;</span> <span class="hljs-property">@stackPointer</span> &gt; <span class="hljs-number">0</span>
    <span class="hljs-attribute">canRedo</span>:<span class="hljs-function"> -&gt;</span> <span class="hljs-property">@stackPointer</span> &lt; <span class="hljs-property">@stack</span>.length
</code></pre><p>We add methods that can describe the atcions that would take place
if undo or redo were invoked, returning the empty string if one
cannot undo/redo.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">undoDescription</span>:<span class="hljs-function"> -&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@stackPointer</span> <span class="hljs-keyword">is</span> <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-string">''</span> <span class="hljs-keyword">else</span>
            <span class="hljs-string">"Undo <span class="hljs-subst">#{<span class="hljs-property">@stack</span>[<span class="hljs-property">@stackPointer</span> - <span class="hljs-number">1</span>].toString()}</span>"</span>
    <span class="hljs-attribute">redoDescription</span>:<span class="hljs-function"> -&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@stackPointer</span> <span class="hljs-keyword">is</span> <span class="hljs-property">@stack</span>.length <span class="hljs-keyword">then</span> <span class="hljs-string">''</span> <span class="hljs-keyword">else</span>
            <span class="hljs-string">"Redo <span class="hljs-subst">#{<span class="hljs-property">@stack</span>[<span class="hljs-property">@stackPointer</span>].toString()}</span>"</span>
</code></pre><p>We add <code>undo</code> and <code>redo</code> methods that move the stack pointer after
calling the <code>undo</code> and <code>redo</code> methods in the appropriate actions on
the stack.  Stack recording is disabled while they act, so that
they do not get doubly recorded.</p>
<p>Calling <code>undo</code> implicitly terminates any ongoing compound action
that may be being recorded.  If one <em>was</em> being recorded, then it
will be <em>that</em> new, compound action that gets undone.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">undo</span>:<span class="hljs-function"> -&gt;</span>
        <span class="hljs-property">@endCompoundAction</span>()
        <span class="hljs-keyword">if</span> <span class="hljs-property">@stackPointer</span> &gt; <span class="hljs-number">0</span>
            <span class="hljs-property">@stackRecording</span> = <span class="hljs-literal">false</span>
            <span class="hljs-property">@stack</span>[<span class="hljs-property">@stackPointer</span> - <span class="hljs-number">1</span>].undo()
            <span class="hljs-property">@stackRecording</span> = <span class="hljs-literal">true</span>
            <span class="hljs-property">@stackPointer</span>--
</code></pre><p>If a compound action is being recorded, redo does nothing.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">redo</span>:<span class="hljs-function"> -&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@compoundActions</span> <span class="hljs-keyword">isnt</span> <span class="hljs-literal">null</span>
        <span class="hljs-keyword">if</span> <span class="hljs-property">@stackPointer</span> &lt; <span class="hljs-property">@stack</span>.length
            <span class="hljs-property">@stackRecording</span> = <span class="hljs-literal">false</span>
            <span class="hljs-property">@stack</span>[<span class="hljs-property">@stackPointer</span>].redo()
            <span class="hljs-property">@stackRecording</span> = <span class="hljs-literal">true</span>
            <span class="hljs-property">@stackPointer</span>++
</code></pre><h2><a name='listeners'></a>Listeners &nbsp;  <font size=-1><a href='#listeners'><span class="glyphicon glyphicon-link"></span></a></font></h2><p>Anyone interested in changes that take place in the document
monitored by this <code>DOMEditTracker</code> instance can add a callback
function to the instance&#39;s list, using the following method.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">listen</span>: <span class="hljs-function"><span class="hljs-params">( callback )</span> -&gt;</span> <span class="hljs-property">@listeners</span>.push callback
</code></pre><p>Those callbacks are called every time a change takes place in the
DOM tree beneath the element tracked by this instance.  They are
passed one parameter, the
<a href="domeditaction.litcoffee.html"><code>DOMEditAction</code></a> instance
representing the change.  Its <code>.node</code> member will contain the
address where the change took place.</p>

        </div>
        <div id="right">
            <h3 align=center>Navigation</h3><br><h3><a href='index.md.html'>webLurch home</a></h3><p>.</p><ul><li><a href='buildutils.litcoffee.html'>buildutils.litcoffee</a></li><li><a href='cake.litcoffee.html'>cake.litcoffee</a></li></ul><p>./app</p><ul><li><a href='../app/index.html'>index.html</a></li></ul><p>./doc</p><ul><li><a href='overview.md.html'>overview.md</a></li><li><a href='plan.md.html'>plan.md</a></li><li><a href='progress.md.html'>progress.md</a></li><li><a href='test-app-help.md.html'>test-app-help.md</a></li><li><a href='test-results.md.html'>test-results.md</a></li><li><a href='wp-spec.md.html'>wp-spec.md</a></li></ul><p>./src</p><ul><li><a href='domeditaction.litcoffee.html'>domeditaction.litcoffee</a></li><li><a href='domedittracker.litcoffee.html'>domedittracker.litcoffee</a></li><li><a href='domutils.litcoffee.html'>domutils.litcoffee</a></li><li><a href='lurcheditor.litcoffee.html'>lurcheditor.litcoffee</a></li><li><a href='utils.litcoffee.html'>utils.litcoffee</a></li></ul><p>./test</p><ul><li><a href='all-histories-spec.litcoffee.html'>all-histories-spec.litcoffee</a></li><li><a href='basic-spec.litcoffee.html'>basic-spec.litcoffee</a></li><li><a href='domeditaction-spec.litcoffee.html'>domeditaction-spec.litcoffee</a></li><li><a href='domedittracker-spec.litcoffee.html'>domedittracker-spec.litcoffee</a></li><li><a href='domutils-spec.litcoffee.html'>domutils-spec.litcoffee</a></li><li><a href='lurcheditor-spec.litcoffee.html'>lurcheditor-spec.litcoffee</a></li><li><a href='phantom-utils.litcoffee.html'>phantom-utils.litcoffee</a></li><li><a href='undoredo-spec.litcoffee.html'>undoredo-spec.litcoffee</a></li><li><a href='utils-spec.litcoffee.html'>utils-spec.litcoffee</a></li></ul><p>./testapp</p><ul><li><a href='utils.litcoffee.html'>utils.litcoffee</a></li><li><a href='../testapp/index.html'>index.html</a></li></ul>
        </div>
    </body>
</html>
