<html>
    <head>
        <link rel="stylesheet"
              href="../bootstrap/css/bootstrap.min.css"/>
        <link rel="stylesheet" href="./main.css"/>
        <link rel="stylesheet" href="./obsidian.css"/>
        <link rel="shortcut icon" href="favicon.png"/>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config( {
              tex2jax: { inlineMath: [ [ '$', '$' ], [ '\\(', '\\)' ] ] }
            } );
        </script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <title>webLurch docs: domeditaction</title>
    </head>
    <body>
        <div id="left">
            <p align=center>Page contents</p>
<p><a href='#dom-edit-action'>DOM Edit Action</a></p><ul>
<li><a href='#constructor'>Constructor</a></li><li><a href='#non-actions'>Non-actions</a></li><li><a href='#description'>Description</a></li><li><a href='#serialization'>Serialization</a></li><li><a href='#undo-redo'>Undo/redo</a></li>
        </div>
        <div id="middle">
            <h1><a name='dom-edit-action'></a>DOM Edit Action &nbsp;  <font size=-1><a href='#dom-edit-action'><span class="glyphicon glyphicon-link"></span></a></font></h1><p>This class will embody a single, atomic edit to a DOM tree.  This
includes all the kinds of edit performable with the usual Node
API, including inserting, removing, and replacing children,
setting and removing attributes, and normalizing nodes.</p>
<p>An instance will store all the data needed to undo or redo the
action it represents, so that a stack of such instances can form
the undo/redo stack for an application.</p>
<p>The protocol for what data to store in each case is described here.</p>
<ul>
<li><code>N.appendChild(node)</code><ul>
<li>returns <code>node</code></li>
<li>event contains <code>N</code>&#39;s address and the serialized node</li>
</ul>
</li>
<li><code>N.insertBefore(node,beforeThisChild)</code><ul>
<li>returns <code>node</code></li>
<li>if <code>beforeThisChild</code> is omitted, it&#39;s the same as append</li>
<li>event contains <code>N</code>&#39;s address, the serialized node, and the
index of <code>beforeThisChild</code> (or child node length if absent)</li>
</ul>
</li>
<li><code>N.normalize()</code><ul>
<li>no return value</li>
<li>removes empty text nodes</li>
<li>joins adjacent text nodes, recursively</li>
<li>event contains <code>N</code>&#39;s address together with a map from
addresses within a normalized <code>N</code> to the sequences of text
nodes that went together to form the normalized ones, i.e.,
address <code>A</code> is mapped to the array of 2 or more strings that
combined to form the text node at the new <code>N.index A</code>.
<code>A</code> is stored as a JSON string, so <code>[0,1]</code> becomes <code>&quot;[0,1]&quot;</code>.</li>
</ul>
</li>
<li><code>N.removeAttribute(name)</code><ul>
<li>no return value</li>
<li>event contains <code>N</code>&#39;s address, <code>name</code>, and original attribute
<code>value</code></li>
</ul>
</li>
<li><code>N.removeAttributeNode(attrNode)</code><ul>
<li>returns <code>attrNode</code></li>
<li>e.g.: <code>N.removeAttributeNode(N.getAttributeNode(&#39;style&#39;))</code></li>
<li>event contains <code>N</code>&#39;s address and original attribute <code>name</code> and
<code>value</code></li>
</ul>
</li>
<li><code>N.removeChild(childNode)</code><ul>
<li>returns <code>childNode</code></li>
<li>event contains <code>N</code>&#39;s address, the child&#39;s original index
within <code>N</code>, and a serialization of the child</li>
</ul>
</li>
<li><code>N.replaceChild(newnode,oldnode)</code><ul>
<li>returns <code>oldnode</code>, I think</li>
<li>event contains <code>N</code>&#39;s address, the child&#39;s original index
within <code>N</code>, and serializations of both <code>oldnode</code> and <code>newnode</code></li>
</ul>
</li>
<li><code>N.setAttribute(name,value)</code><ul>
<li>no return value</li>
<li>both strings</li>
<li>event contains <code>N</code>&#39;s address, <code>name</code>, and <code>value</code>, as well as
the original value of the attribute beforehand</li>
</ul>
</li>
<li><code>N.setAttributeNode(attrNode)</code><ul>
<li>returns replaced node if any, otherwise null</li>
<li>E.g.: <br>
<code>atr = document.createAttribute &#39;class&#39;</code> <br>
<code>atr.nodeValue = &#39;democlass&#39;</code> <br>
<code>myDiv.setAttributeNode atr</code></li>
<li>event contains <code>N</code>&#39;s address, the name and value of the
attribute after setting, as well as the original value of the
attribute beforehand</li>
</ul>
</li>
<li>Note that <code>element.dataset.foo</code> is not supported.</li>
<li>There is also a compound action that does not correspond to any
of the <code>Node</code> member functions listed above, but rather that
serves to aggregate a sequence of such editing actions into one.
It stores only the array of atomic edit actions that comprise
it.</li>
</ul>
<p>Now begins the code for the class.</p>
<pre class="hljs"><code><span class="hljs-built_in">window</span>.DOMEditAction = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DOMEditAction</span></span>
</code></pre><h2><a name='constructor'></a>Constructor &nbsp;  <font size=-1><a href='#constructor'><span class="glyphicon glyphicon-link"></span></a></font></h2><p>The constructor requires that the data given be of the appropriate
form for one of the nine acceptable ways to instantiate this class.
They are these:</p>
<ul>
<li>type &quot;appendChild&quot;, with data the parent node and child to
append</li>
<li>type &quot;insertBefore&quot;, with data the parent node, the child to
insert, and the child before which to insert it, which may be
omitted to mean the same thing as append</li>
<li>type &quot;normalize&quot;, with data the parent node</li>
<li>type &quot;removeAttribute&quot;, with data the node from which to remove
the attribute, and name of the attribute to remove</li>
<li>type &quot;removeAttributeNode&quot;, with data the node from which to
remove the attribute, and the attribute node to remove</li>
<li>type &quot;removeChild&quot;, with data the parent node and the child to
remove</li>
<li>type &quot;replaceChild&quot;, with data the parent node, the new node to
replace the child with, and then the child to replace</li>
<li>type &quot;setAttribute&quot;, with data the node whose attribute should
be set, the name of the attribute to set, and the value to which
it should be set</li>
<li>type &quot;setAttributeNode&quot;, with data the node whose attribute
should be set and the new attribute node to set on it</li>
<li>type &quot;compound&quot;, with data the array of atomic actions that
comprise the compound action; the <code>node</code> member for a compound
action is the common ancestor of the atomic actions inside it</li>
</ul>
<p>We write the signature for the constructor with parameter names
that expect the construction of an atomic action type, since that
will be the most common occurrence.  But we handle the special case
of the compound type immediately.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">constructor</span>: <span class="hljs-function"><span class="hljs-params">( type, node, data... )</span> -&gt;</span>
</code></pre><p>If this is the compound case, then the user will call <code>new
DOMEditAction &#39;compound&#39;, arrayOfActions</code> or <code>new DOMEditAction
&#39;compound&#39;, action1, ..., actionN</code>.  We handle either of those
cases here, because they do not involve passing a node parameter.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> type <span class="hljs-keyword">is</span> <span class="hljs-string">'compound'</span>
            <span class="hljs-property">@type</span> = type
</code></pre><p>First, unite the array case and the many-parameters case into one
by forming an <code>actionList</code> array.</p>
<pre class="hljs"><code>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node?
                <span class="hljs-property">@subactions</span> = []
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> node <span class="hljs-keyword">instanceof</span> Array
                <span class="hljs-property">@subactions</span> = node
            <span class="hljs-keyword">else</span>
                <span class="hljs-property">@subactions</span> = [ node ].concat data
</code></pre><p>Now verify that its elements are all actions.</p>
<pre class="hljs"><code>            <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> <span class="hljs-property">@subactions</span>
                <span class="hljs-keyword">if</span> action <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> DOMEditAction
                    <span class="hljs-keyword">throw</span> Error <span class="hljs-string">"Compound action array
                        contained a non-action: <span class="hljs-subst">#{action}</span>"</span>
</code></pre><p>Find the common ancestor for all their addresses.</p>
<pre class="hljs"><code>            <span class="hljs-keyword">if</span> <span class="hljs-property">@subactions</span>.length <span class="hljs-keyword">is</span> <span class="hljs-number">0</span>
                <span class="hljs-property">@node</span> = []
                <span class="hljs-property">@tracker</span> = <span class="hljs-literal">null</span>
            <span class="hljs-keyword">else</span>
                <span class="hljs-property">@node</span> = <span class="hljs-property">@subactions</span>[<span class="hljs-number">0</span>].node
                <span class="hljs-property">@tracker</span> = <span class="hljs-property">@subactions</span>[<span class="hljs-number">0</span>].tracker
                <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> <span class="hljs-property">@subactions</span>[<span class="hljs-number">1.</span>.]
                    end = action.length
                    end = <span class="hljs-property">@node</span>.length <span class="hljs-keyword">if</span> end &gt; <span class="hljs-property">@node</span>.length
                    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1.</span>..end]
                        <span class="hljs-keyword">if</span> <span class="hljs-property">@node</span>[i] <span class="hljs-keyword">isnt</span> action[i]
                            <span class="hljs-property">@node</span> = <span class="hljs-property">@node</span>[...i]
                            <span class="hljs-keyword">break</span>
</code></pre><p>Return this instance, so that the constructor terminates now; this
is the end of the compound case.</p>
<pre class="hljs"><code>            <span class="hljs-property">@description</span> = <span class="hljs-string">'Document edit'</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
</code></pre><p>Now that the compound case is taken care of, we can return to all
the other atomic cases, in which the <code>node</code> parameter must actually
be a DOM Node; otherwise, this constructor cannot function.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Node
            <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'This is not a node: '</span> + node
</code></pre><p>The <code>DOMEditTracker</code> instance in which all of this will operate is
stored in the member <code>@tracker</code>.  If there is no such tracker, that
member will be null.</p>
<pre class="hljs"><code>        <span class="hljs-property">@tracker</span> = DOMEditTracker.instanceOver node
</code></pre><p>Also remember the type of action.</p>
<pre class="hljs"><code>        <span class="hljs-property">@type</span> = type
</code></pre><p>The node itself is stored in <code>@node</code> as the address within the
given edit tracker, or within its topmost ancestor if there is no
tracker.  (But this class is not very useful if there is no edit
tracker; we avoid throwing an error mainly for the convenience of
the caller.)</p>
<pre class="hljs"><code>        <span class="hljs-property">@node</span> = node.address <span class="hljs-property">@tracker</span>?.getElement()
</code></pre><p>For type &quot;appendChild&quot;, the node to append is stored serialized,
in <code>@toAppend</code>.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> type <span class="hljs-keyword">is</span> <span class="hljs-string">'appendChild'</span>
            <span class="hljs-keyword">if</span> data.length <span class="hljs-keyword">isnt</span> <span class="hljs-number">1</span>
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Wrong # of parameters: '</span> + data
            <span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Node
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Invalid parameter: '</span> + data
            <span class="hljs-property">@toAppend</span> = data[<span class="hljs-number">0</span>].toJSON()
</code></pre><p>For type &quot;insertBefore&quot;, the node to insert is stored serialized,
in <code>@toInsert</code>, and the node before which to insert it is stored as
its index, or the previous number of children if this parameter was
omitted, in <code>@insertBefore</code>.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> type <span class="hljs-keyword">is</span> <span class="hljs-string">'insertBefore'</span>
            <span class="hljs-keyword">if</span> data.length <span class="hljs-keyword">isnt</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> data.length <span class="hljs-keyword">isnt</span> <span class="hljs-number">2</span>
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Wrong # of parameters: '</span> + data
            <span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Node
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Invalid parameter: '</span> + data[<span class="hljs-number">0</span>]
            <span class="hljs-property">@toInsert</span> = data[<span class="hljs-number">0</span>].toJSON()
            <span class="hljs-keyword">if</span> data.length <span class="hljs-keyword">is</span> <span class="hljs-number">2</span>
                <span class="hljs-keyword">if</span> data[<span class="hljs-number">1</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Node
                    <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Invalid parameter: '</span> + data[<span class="hljs-number">1</span>]
                <span class="hljs-keyword">if</span> data[<span class="hljs-number">1</span>].parentNode <span class="hljs-keyword">isnt</span> node
                    <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Invalid child: '</span> + data[<span class="hljs-number">1</span>]
                <span class="hljs-property">@insertBefore</span> = data[<span class="hljs-number">1</span>].indexInParent()
            <span class="hljs-keyword">else</span>
                <span class="hljs-property">@insertBefore</span> = node.childNodes.length
</code></pre><p>For type &quot;normalize&quot;, we store a map from addresses in the
normalized version (which isn&#39;t even yet computed) to sequences of
strings that will be amalgamated to appear at those addresses.
We store it in <code>@sequences</code>, thus making this edit action
invertible later if necessary.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> type <span class="hljs-keyword">is</span> <span class="hljs-string">'normalize'</span>
            <span class="hljs-keyword">if</span> data.length <span class="hljs-keyword">isnt</span> <span class="hljs-number">0</span>
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Wrong # of parameters: '</span> + data
            <span class="hljs-property">@sequences</span> = {}
</code></pre><p>We create a function that recursively processes the DOM tree from
any node <code>N</code> downward, then call it on our <code>node</code>.  The variable
<code>index</code> in the following code walks one step at a time, even when
<code>child</code> jumps many sequential text nodes at once, so that we build
addresses that the text nodes will have after normalization.</p>
<pre class="hljs"><code>            that = <span class="hljs-keyword">this</span>
            <span class="hljs-function"><span class="hljs-title">process</span> = <span class="hljs-params">( N, address = [] )</span> =&gt;</span>
                child = N.childNodes[<span class="hljs-number">0</span>]
                index = <span class="hljs-number">0</span>
                <span class="hljs-keyword">while</span> child
</code></pre><p>If we&#39;ve found a sequence of two or more adjacent text nodes, build
an array of them and record it in the <code>sequences</code> field.</p>
<pre class="hljs"><code>                    nextAddr = address.concat [ index ]
                    <span class="hljs-keyword">if</span> child <span class="hljs-keyword">instanceof</span> Text <span class="hljs-keyword">and</span>
                       child.nextSibling <span class="hljs-keyword">instanceof</span> Text
                        strings = []
                        <span class="hljs-keyword">while</span> child <span class="hljs-keyword">instanceof</span> Text
                            strings.push child.textContent
                            child = child.nextSibling
                        key = JSON.stringify nextAddr
                        <span class="hljs-property">@sequences</span>[key] = strings
</code></pre><p>Otherwise, just move on to the next child.</p>
<pre class="hljs"><code>                    <span class="hljs-keyword">else</span>
                        process child, nextAddr
                        child = child.nextSibling
</code></pre><p>In either case, advance <code>index</code> by just one step.</p>
<pre class="hljs"><code>                    index++
            process node
</code></pre><p>For type &quot;removeAttribute&quot;, we store the name of the attribute
in <code>@name</code>, together with its original value in <code>@value</code>.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> type <span class="hljs-keyword">is</span> <span class="hljs-string">'removeAttribute'</span>
            <span class="hljs-keyword">if</span> data.length <span class="hljs-keyword">isnt</span> <span class="hljs-number">1</span>
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Wrong # of parameters: '</span> + data
            <span class="hljs-property">@name</span> = data[<span class="hljs-number">0</span>] + <span class="hljs-string">''</span>
            <span class="hljs-property">@value</span> = node.getAttribute <span class="hljs-property">@name</span>
</code></pre><p>For type &quot;removeAttributeNode&quot;, we store the same data as in the
previous type, under the same names.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> type <span class="hljs-keyword">is</span> <span class="hljs-string">'removeAttributeNode'</span>
            <span class="hljs-keyword">if</span> data.length <span class="hljs-keyword">isnt</span> <span class="hljs-number">1</span>
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Wrong # of parameters: '</span> + data
            <span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Attr
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Invalid attribute node: '</span> +
                            data[<span class="hljs-number">0</span>]
            { <span class="hljs-property">@name</span> } = data[<span class="hljs-number">0</span>]
            <span class="hljs-property">@value</span> = node.getAttribute <span class="hljs-property">@name</span>
</code></pre><p>For type &quot;removeChild&quot;, we store the child&#39;s original index within
<code>@node</code> as <code>@childIndex</code>, and a serialization of the child, as
<code>@child</code>.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> type <span class="hljs-keyword">is</span> <span class="hljs-string">'removeChild'</span>
            <span class="hljs-keyword">if</span> data.length <span class="hljs-keyword">isnt</span> <span class="hljs-number">1</span>
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Wrong # of parameters: '</span> + data
            <span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Node
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Invalid parameter: '</span> + data[<span class="hljs-number">0</span>]
            <span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>].parentNode <span class="hljs-keyword">isnt</span> node
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Invalid child: '</span> + data[<span class="hljs-number">0</span>]
            <span class="hljs-property">@childIndex</span> = data[<span class="hljs-number">0</span>].indexInParent()
            <span class="hljs-property">@child</span> = data[<span class="hljs-number">0</span>].toJSON()
</code></pre><p>For type &quot;replaceChild&quot;, we store the child&#39;s original index within
<code>@node</code> as <code>@childIndex</code>, a serialization of the child, as
<code>@oldChild</code>, and a serialization of the replacement, as
<code>@newChild</code>.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> type <span class="hljs-keyword">is</span> <span class="hljs-string">'replaceChild'</span>
            <span class="hljs-keyword">if</span> data.length <span class="hljs-keyword">isnt</span> <span class="hljs-number">2</span>
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Wrong # of parameters: '</span> + data
            <span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Node
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Invalid parameter: '</span> + data[<span class="hljs-number">0</span>]
            <span class="hljs-keyword">if</span> data[<span class="hljs-number">1</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Node
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Invalid parameter: '</span> + data[<span class="hljs-number">1</span>]
            <span class="hljs-keyword">if</span> data[<span class="hljs-number">1</span>].parentNode <span class="hljs-keyword">isnt</span> node
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Invalid child: '</span> + data[<span class="hljs-number">1</span>]
            <span class="hljs-property">@childIndex</span> = data[<span class="hljs-number">1</span>].indexInParent()
            <span class="hljs-property">@oldChild</span> = data[<span class="hljs-number">1</span>].toJSON()
            <span class="hljs-property">@newChild</span> = data[<span class="hljs-number">0</span>].toJSON()
</code></pre><p>For type &quot;setAttribute&quot;, we store the name and value to which the
attribute will be set, in <code>@name</code> and <code>@newValue</code>, respectively, as
well as the attribute&#39;s original value, in <code>@oldValue</code>.  If the
old value is null, we store the empty string instead, so that
JSON serialization is possible.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> type <span class="hljs-keyword">is</span> <span class="hljs-string">'setAttribute'</span>
            <span class="hljs-keyword">if</span> data.length <span class="hljs-keyword">isnt</span> <span class="hljs-number">2</span>
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Wrong # of parameters: '</span> + data
            <span class="hljs-property">@name</span> = data[<span class="hljs-number">0</span>] + <span class="hljs-string">''</span>
            <span class="hljs-property">@newValue</span> = data[<span class="hljs-number">1</span>] + <span class="hljs-string">''</span>
            <span class="hljs-property">@oldValue</span> = ( node.getAttribute <span class="hljs-property">@name</span> ) <span class="hljs-keyword">or</span> <span class="hljs-string">''</span>
</code></pre><p>For type &quot;setAttributeNode&quot;, we store the same data as in the
previous case, and under the same names.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> type <span class="hljs-keyword">is</span> <span class="hljs-string">'setAttributeNode'</span>
            <span class="hljs-keyword">if</span> data.length <span class="hljs-keyword">isnt</span> <span class="hljs-number">1</span>
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Wrong # of parameters: '</span> + data
            <span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">instanceof</span> Attr
                <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Invalid parameter: '</span> + data[<span class="hljs-number">0</span>]
            <span class="hljs-property">@name</span> = data[<span class="hljs-number">0</span>].name
            <span class="hljs-property">@newValue</span> = data[<span class="hljs-number">0</span>].value
            <span class="hljs-property">@oldValue</span> = ( node.getAttribute <span class="hljs-property">@name</span> ) <span class="hljs-keyword">or</span> <span class="hljs-string">''</span>
</code></pre><p>If none of the above types were what the caller was trying to
construct, throw an error, because they&#39;re the only types
supported.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Invalid DOMEditAction type: '</span> + type
</code></pre><h2><a name='non-actions'></a>Non-actions &nbsp;  <font size=-1><a href='#non-actions'><span class="glyphicon glyphicon-link"></span></a></font></h2><p>It is possible to create edit actions that do not actually change
the document in any way.  For instance, a normalize action might
be called when there are not any adjacent text nodes, so it does
nothing.  Or a replaceChild action might be performed, replacing
an existing child with one that is indistinguishable from it.</p>
<p>We wish to be able to detect when an edit action is really a
non-action, for a few reasons.</p>
<ul>
<li>Let&#39;s not push onto the undo/redo stack actions that will do
nothing if the user undoes/redoes them.  This would be confusing
to the user.</li>
<li>Let&#39;s not notify listeners of null changes, because whatever
processing the listeners would do upon changes would then be
wasted effort, since the document has not really changed.</li>
</ul>
<p>Thus the following member function of the <code>DOMEditAction</code> class
returns whether or not the action is null.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">isNullAction</span>:<span class="hljs-function"> -&gt;</span>
</code></pre><p>Appending, inserting, or remvoing a child always changes the
document.  (If the attempt had been to append or insert something
invalid, or remove something invalid, this object would not have
completed its constructor.  The fact that it did means that the
addition or removal is a valid action.)</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'appendChild'</span> <span class="hljs-keyword">or</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'insertBefore'</span> <span class="hljs-keyword">or</span>
           <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'removeChild'</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">no</span>
</code></pre><p>Removing an attribute is null if and only if the node did not have
the attribute, in which case <code>@value</code> will be null.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'removeAttribute'</span> <span class="hljs-keyword">or</span>
           <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'removeAttributeNode'</span>
            <span class="hljs-keyword">return</span> <span class="hljs-property">@value</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>
</code></pre><p>Normalize is a null action iff the constructor did not find any
sequences of adjacent text nodes anywhere in the node to be
normalized.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'normalize'</span>
            <span class="hljs-keyword">return</span> JSON.equals <span class="hljs-property">@sequences</span>, {}
</code></pre><p>Replacing a child with another is an actual modification iff the
&quot;before&quot; child is distinguishable from the &quot;after&quot; child.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'replaceChild'</span>
            <span class="hljs-keyword">return</span> JSON.equals <span class="hljs-property">@oldChild</span>, <span class="hljs-property">@newChild</span>
</code></pre><p>Setting an attribute is an actual modification iff the new value
is a different string than the old value.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'setAttribute'</span> <span class="hljs-keyword">or</span>
                <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'setAttributeNode'</span>
            <span class="hljs-keyword">return</span> <span class="hljs-property">@oldValue</span> <span class="hljs-keyword">is</span> <span class="hljs-property">@newValue</span>
</code></pre><p>A compound action is a null action iff all its elements are.
Although we could make it null iff the combined sequence of actions
is guaranteed to yield the same document as before, but that is
both less useful and harder to compute.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'compound'</span>
            <span class="hljs-keyword">for</span> subaction <span class="hljs-keyword">in</span> <span class="hljs-property">@subactions</span>
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> subaction.isNullAction() <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">no</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">yes</span>
</code></pre><p>And those are all the types we know.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> Error <span class="hljs-string">'Invalid DOMEditAction type: '</span> + <span class="hljs-property">@type</span>
</code></pre><h2><a name='description'></a>Description &nbsp;  <font size=-1><a href='#description'><span class="glyphicon glyphicon-link"></span></a></font></h2><p>Instance of the class need to be able to provide descriptions of
themselves, for use on undo/redo stacks.  We provide this
functionality with a <code>toString</code> method.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">toString</span>:<span class="hljs-function"> -&gt;</span>
</code></pre><p>We simply check each of the nine valid action types, and create a
sensible string representation for each.  Sections of quoted text
are capped at 50 characters, but that can easily be changed here:</p>
<pre class="hljs"><code>        max = <span class="hljs-number">50</span>
</code></pre><p>I do not document each of the individual parts of the following
simple <code>if</code>-<code>else</code> code, but suffice it to say that the forms of
the output are on the following list.</p>
<ul>
<li>Add [text appended]</li>
<li>Insert [text inserted]</li>
<li>Normalize text</li>
<li>Remove [name] attribute</li>
<li>Remove [text removed]</li>
<li>Replace [text] with [text]</li>
<li><p>Change [attribute name] from [old value] to [new value]
For compound actions, the output will be the vague phrase
&quot;Document edit&quot; unless it has been changed by calling
<code>action.description = &#39;Other content here&#39;</code>.</p>
<pre class="hljs"><code>     <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'appendChild'</span>
         text = Node.fromJSON( <span class="hljs-property">@toAppend</span> ).textContent
         <span class="hljs-keyword">if</span> text.length &gt; max <span class="hljs-keyword">then</span> text = text[..max]+<span class="hljs-string">'...'</span>
         <span class="hljs-keyword">if</span> text.length <span class="hljs-keyword">is</span> <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> text = <span class="hljs-string">'a node'</span>
         <span class="hljs-string">"Add <span class="hljs-subst">#{text}</span>"</span>
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'insertBefore'</span>
         text = Node.fromJSON( <span class="hljs-property">@toInsert</span> ).textContent
         <span class="hljs-keyword">if</span> text.length &gt; max <span class="hljs-keyword">then</span> text = text[..max]+<span class="hljs-string">'...'</span>
         <span class="hljs-keyword">if</span> text.length <span class="hljs-keyword">is</span> <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> text = <span class="hljs-string">'a node'</span>
         <span class="hljs-string">"Insert <span class="hljs-subst">#{text}</span>"</span>
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'normalize'</span>
         <span class="hljs-string">"Normalize text"</span>
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'removeAttribute'</span> <span class="hljs-keyword">or</span>
             <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'removeAttributeNode'</span>
         <span class="hljs-string">"Remove <span class="hljs-subst">#{<span class="hljs-property">@name</span>}</span> attribute"</span>
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'removeChild'</span>
         text = Node.fromJSON( <span class="hljs-property">@child</span> ).textContent
         <span class="hljs-keyword">if</span> text.length &gt; max <span class="hljs-keyword">then</span> text = text[..max]+<span class="hljs-string">'...'</span>
         <span class="hljs-keyword">if</span> text.length <span class="hljs-keyword">is</span> <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> text = <span class="hljs-string">'a node'</span>
         <span class="hljs-string">"Remove <span class="hljs-subst">#{text}</span>"</span>
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'replaceChild'</span>
         orig = Node.fromJSON( <span class="hljs-property">@oldChild</span> ).textContent
         <span class="hljs-keyword">if</span> orig.length &gt; max <span class="hljs-keyword">then</span> orig = orig[..max]+<span class="hljs-string">'...'</span>
         <span class="hljs-keyword">if</span> orig.length <span class="hljs-keyword">is</span> <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> orig = <span class="hljs-string">'a node'</span>
         repl = Node.fromJSON( <span class="hljs-property">@newChild</span> ).textContent
         <span class="hljs-keyword">if</span> repl.length &gt; max <span class="hljs-keyword">then</span> repl = repl[..max]+<span class="hljs-string">'...'</span>
         <span class="hljs-keyword">if</span> repl.length <span class="hljs-keyword">is</span> <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> repl = <span class="hljs-string">'a node'</span>
         <span class="hljs-string">"Replace <span class="hljs-subst">#{orig}</span> with <span class="hljs-subst">#{repl}</span>"</span>
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'setAttribute'</span> <span class="hljs-keyword">or</span>
             <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'setAttributeNode'</span>
         oldv = <span class="hljs-property">@oldValue</span> <span class="hljs-keyword">or</span> <span class="hljs-string">'empty'</span>
         newv = <span class="hljs-property">@newValue</span> <span class="hljs-keyword">or</span> <span class="hljs-string">'empty'</span>
         <span class="hljs-string">"Change <span class="hljs-subst">#{<span class="hljs-property">@name</span>}</span> from <span class="hljs-subst">#{oldv}</span> to <span class="hljs-subst">#{newv}</span>"</span>
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'compound'</span>
         <span class="hljs-property">@description</span>
</code></pre></li>
</ul>
<p>An error message is returned as a string if none of the nine valid
action types is stored in this object (i.e., the object is
corrupt).</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span>
            <span class="hljs-string">"Error, unknown edit action type: <span class="hljs-subst">#{<span class="hljs-property">@type</span>}</span>"</span>
</code></pre><h2><a name='serialization'></a>Serialization &nbsp;  <font size=-1><a href='#serialization'><span class="glyphicon glyphicon-link"></span></a></font></h2><p>The class also provides a serialization method, mostly for use in
unit testing, because instances of the object can then be sent in
and out of a headless browser as JSON.  This implementation just
copies into an object all possibly-relevant fields of the object,
ready for later JSON stringification, should that be useful.</p>
<p>This function is indirectly tested in that many other unit tests
depend upon it to test other functionality.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">toJSON</span>:<span class="hljs-function"> -&gt;</span> {
        <span class="hljs-property">@type</span>, <span class="hljs-property">@node</span>, <span class="hljs-property">@toAppend</span>, <span class="hljs-property">@toInsert</span>, <span class="hljs-property">@insertBefore</span>,
        <span class="hljs-property">@sequences</span>, <span class="hljs-property">@name</span>, <span class="hljs-property">@value</span>, <span class="hljs-property">@child</span>, <span class="hljs-property">@childIndex</span>,
        <span class="hljs-property">@oldChild</span>, <span class="hljs-property">@newChild</span>, <span class="hljs-property">@oldValue</span>, <span class="hljs-property">@newValue</span>,
        <span class="hljs-property">@description</span>, <span class="hljs-property">@subactions</span>
    }
</code></pre><h2><a name='undo-redo'></a>Undo/redo &nbsp;  <font size=-1><a href='#undo-redo'><span class="glyphicon glyphicon-link"></span></a></font></h2><p>Edit actions, because they are actions, will sit on an undo/redo
stack, and thus must be able to be applied, either forwards or
backwards.  The following two methods support this need.</p>
<p>Each method assumes that it is being called at a time that makes
sense.  E.g., an undo is being performed right after the action
was performed, or with the <code>DOMEditTracker</code> element in a state
equivalent to such a time.  And a redo should only be performed if
the action was just undone, or an equivalent state (such as doing
one further undo, then redoing that action).</p>
<p>Furthermore, these methods make changes to the DOM, and thus will
generate more <code>DOMEditAction</code> events, which will propagate to the
<code>DOMEditTracker</code> stored in this object&#39;s <code>tracker</code> field.  Thus it
is the business of the tracker, before asking one of the actions on
its undo/redo stack to perform an undo/redo, to temporarily pause
its own recording of such actions.  This will prevent corruption of
the undo/redo stack in question.</p>
<p>First, we consider the forward case.  It could be named simply
<code>do</code> but the action is almost never created in order to be applied;
rather, it is created as an event that records an action that was
done via the ordinary DOM API, and can thus be undone/redone later.
Hence, we call this <code>redo</code> since it is almost always called for
that purpose.  Also, it gives a nice symmetry with <code>undo</code>.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">redo</span>:<span class="hljs-function"> -&gt;</span>
</code></pre><p>In every case, we need to know what object was &quot;<code>this</code>&quot; when the
event was created.  Its address within the containing
<code>DOMEditTracker</code> is stored in our <code>node</code> field, so we find it that
way.  If there is no tracker, this will fail.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-property">@tracker</span>
            <span class="hljs-keyword">throw</span> Error \
                <span class="hljs-string">'Cannot redo action with no DOMEditTracker'</span>
        original = <span class="hljs-property">@tracker</span>.getElement().index <span class="hljs-property">@node</span>
</code></pre><p>Now we consider each possible action type separately, in a big
<code>if</code>-<code>else</code> clause, as in the <code>toString</code> method, above.</p>
<p>In the case of &quot;appendChild&quot;, we simply unserialize the stored
child and append it.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'appendChild'</span>
            original.appendChild Node.fromJSON <span class="hljs-property">@toAppend</span>
</code></pre><p>In the case of &quot;insertBefore&quot;, we simply unserialize the stored
child and either insert or append it, depending on the index.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'insertBefore'</span>
            newnode = Node.fromJSON <span class="hljs-property">@toInsert</span>
            <span class="hljs-keyword">if</span> <span class="hljs-property">@insertBefore</span> <span class="hljs-keyword">is</span> original.childNodes.length
                original.appendChild newnode
            <span class="hljs-keyword">else</span>
                original.insertBefore newnode,
                    original.childNodes[<span class="hljs-property">@insertBefore</span>]
</code></pre><p>Normalization is simple because it takes no parameters.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'normalize'</span>
            original.normalize()
</code></pre><p>Removing an attribute is also straightforward, because the only
parameter we need is the attribute name, stored in our <code>name</code>
field.</p>
<p>I handle both the attribute and attribute-node cases in the same
manner, because we are only concerned here with final results, not
with the specific events generated along the way.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'removeAttribute'</span> <span class="hljs-keyword">or</span>
                <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'removeAttributeNode'</span>
            original.removeAttribute <span class="hljs-property">@name</span>
</code></pre><p>Removing a child is straightforward because we have the only
parameter we need, its index, stored in our <code>childIndex</code> field.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'removeChild'</span>
            original.removeChild \
                original.childNodes[<span class="hljs-property">@childIndex</span>]
</code></pre><p>Replacing a child requires first unserializing the replacement from
our <code>newChild</code> field, then calling doing the replacement using the
usual DOM API.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'replaceChild'</span>
            replacement = Node.fromJSON <span class="hljs-property">@newChild</span>
            original.replaceChild replacement,
                original.childNodes[<span class="hljs-property">@childIndex</span>]
</code></pre><p>Changing an attribute is easy, because the key-value pair is stored
in this object under the <code>name</code> and <code>newValue</code> fields.</p>
<p>I handle both the attribute and attribute-node cases in the same
manner, because we are only concerned here with final results, not
with the specific events generated along the way.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'setAttribute'</span> <span class="hljs-keyword">or</span>
                <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'setAttributeNode'</span>
            original.setAttribute <span class="hljs-property">@name</span>, <span class="hljs-property">@newValue</span>
</code></pre><p>If it&#39;s a compound action, just run all the subactions in order.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'compound'</span>
            action.redo() <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> <span class="hljs-property">@subactions</span>
</code></pre><p>Next, we consider the backward case.  I provide fewer comments in
the code below, because it is simply the inverse of the routine
just built above, which is liberally commented.  Refer to the
routine above for more detailed explanations of each part below.</p>
<pre class="hljs"><code>    <span class="hljs-attribute">undo</span>:<span class="hljs-function"> -&gt;</span>
</code></pre><p>As above, compute the original &quot;<code>this</code>&quot; node.  If there is no
tracker, this will fail.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-property">@tracker</span>
            <span class="hljs-keyword">throw</span> Error \
                <span class="hljs-string">'Cannot undo action with no DOMEditTracker'</span>
        original = <span class="hljs-property">@tracker</span>.getElement().index <span class="hljs-property">@node</span>
</code></pre><p>The inverse of &quot;appendChild&quot; is to remove the last child.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'appendChild'</span>
            original.removeChild original.childNodes[ \
                original.childNodes.length - <span class="hljs-number">1</span>]
</code></pre><p>The inverse of &quot;insertBefore&quot; is to remove the inserted child node.
The insertion index stored in <code>insertBefore</code> is the index of the
child to remove.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'insertBefore'</span>
            original.removeChild \
                original.childNodes[<span class="hljs-property">@insertBefore</span>]
</code></pre><p>The inverse of normalization is to break up any text fragments that
were adjacent before the normalization, but which got united
because of it.</p>
<p>For each key in the sequences object, we use it as an address to
look up the descendant of <code>original</code> that resulted from
amalgamating the sequence into one text node.  After all these
lookups, we then take each and break them up using the <code>splitText</code>
method of the <code>Text</code> prototype.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'normalize'</span>
</code></pre><p>First look up all the descendants in advance, before expanding any,
so that all addresses are valid throughout this process.</p>
<pre class="hljs"><code>            descendants = {}
            <span class="hljs-keyword">for</span> own key <span class="hljs-keyword">of</span> <span class="hljs-property">@sequences</span>
                descendants[key] = \
                    original.index JSON.parse key
</code></pre><p>Next split each such descendant into pieces, based on the lengths
of the strings stored in the <code>sequences</code> object.</p>
<pre class="hljs"><code>            <span class="hljs-keyword">for</span> own key <span class="hljs-keyword">of</span> <span class="hljs-property">@sequences</span>
                d = descendants[key]
                <span class="hljs-keyword">for</span> string <span class="hljs-keyword">in</span> <span class="hljs-property">@sequences</span>[key]
                    <span class="hljs-keyword">if</span> string.length &lt; d.textContent.length
                        d.splitText string.length
                        d = d.nextSibling
</code></pre><p>The inverse of removing an attribute to put it back in, with both
the key and value we recorded for this purpose, before its removal.</p>
<p>I handle both the attribute and attribute-node cases in the same
manner, because we are only concerned here with final results, not
with the specific events generated along the way.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'removeAttribute'</span> <span class="hljs-keyword">or</span>
                <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'removeAttributeNode'</span>
            original.setAttribute <span class="hljs-property">@name</span>, <span class="hljs-property">@value</span>
</code></pre><p>The inverse of removing a child is to add the child back in, which
we can do because we stored a serialized version of the child in
this object.  We take care to differentiate the cases of insertion
vs. appending.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'removeChild'</span>
            addBack = Node.fromJSON <span class="hljs-property">@child</span>
            <span class="hljs-keyword">if</span> <span class="hljs-property">@childIndex</span> <span class="hljs-keyword">is</span> original.childNodes.length
                original.appendChild addBack
            <span class="hljs-keyword">else</span>
                original.insertBefore addBack,
                    original.childNodes[<span class="hljs-property">@childIndex</span>]
</code></pre><p>The inverse of replacing a child is actually still replacing a
child, just with the old and new reversed.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'replaceChild'</span>
            replacement = Node.fromJSON <span class="hljs-property">@oldChild</span>
            original.replaceChild replacement,
                original.childNodes[<span class="hljs-property">@childIndex</span>]
</code></pre><p>The inverse of changing an attribute is to change it back to its
former value, if it had one, but if it did not, then remove the
attribute entirely.</p>
<p>I handle both the attribute and attribute-node cases in the same
manner, because we are only concerned here with final results, not
with the specific events generated along the way.</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'setAttribute'</span> <span class="hljs-keyword">or</span>
                <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'setAttributeNode'</span>
            <span class="hljs-keyword">if</span> <span class="hljs-property">@oldValue</span> <span class="hljs-keyword">isnt</span> <span class="hljs-string">''</span>
                original.setAttribute <span class="hljs-property">@name</span>, <span class="hljs-property">@oldValue</span>
            <span class="hljs-keyword">else</span>
                original.removeAttribute <span class="hljs-property">@name</span>
</code></pre><p>If it&#39;s a compound action, undo all the subactions, in reverse
order from how they were originally performed.  (Note that the code
below copies the array before reversing it, because the reverse
happens in-place, impacting the array itself.)</p>
<pre class="hljs"><code>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-property">@type</span> <span class="hljs-keyword">is</span> <span class="hljs-string">'compound'</span>
            <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> <span class="hljs-property">@subactions</span>[..].reverse()
                action.undo()
</code></pre>
        </div>
        <div id="right">
            <h3 align=center>Navigation</h3><br><h3><a href='index.md.html'>webLurch home</a></h3><p>.</p><ul><li><a href='buildutils.litcoffee.html'>buildutils.litcoffee</a></li><li><a href='cake.litcoffee.html'>cake.litcoffee</a></li></ul><p>./app</p><ul><li><a href='../app/index.html'>index.html</a></li></ul><p>./doc</p><ul><li><a href='overview.md.html'>overview.md</a></li><li><a href='plan.md.html'>plan.md</a></li><li><a href='progress.md.html'>progress.md</a></li><li><a href='test-app-help.md.html'>test-app-help.md</a></li><li><a href='test-results.md.html'>test-results.md</a></li><li><a href='wp-spec.md.html'>wp-spec.md</a></li></ul><p>./src</p><ul><li><a href='domeditaction.litcoffee.html'>domeditaction.litcoffee</a></li><li><a href='domedittracker.litcoffee.html'>domedittracker.litcoffee</a></li><li><a href='domutils.litcoffee.html'>domutils.litcoffee</a></li><li><a href='lurcheditor.litcoffee.html'>lurcheditor.litcoffee</a></li><li><a href='utils.litcoffee.html'>utils.litcoffee</a></li></ul><p>./test</p><ul><li><a href='all-histories-spec.litcoffee.html'>all-histories-spec.litcoffee</a></li><li><a href='basic-spec.litcoffee.html'>basic-spec.litcoffee</a></li><li><a href='domeditaction-spec.litcoffee.html'>domeditaction-spec.litcoffee</a></li><li><a href='domedittracker-spec.litcoffee.html'>domedittracker-spec.litcoffee</a></li><li><a href='domutils-spec.litcoffee.html'>domutils-spec.litcoffee</a></li><li><a href='lurcheditor-spec.litcoffee.html'>lurcheditor-spec.litcoffee</a></li><li><a href='phantom-utils.litcoffee.html'>phantom-utils.litcoffee</a></li><li><a href='undoredo-spec.litcoffee.html'>undoredo-spec.litcoffee</a></li><li><a href='utils-spec.litcoffee.html'>utils-spec.litcoffee</a></li></ul><p>./testapp</p><ul><li><a href='utils.litcoffee.html'>utils.litcoffee</a></li><li><a href='../testapp/index.html'>index.html</a></li></ul>
        </div>
    </body>
</html>
