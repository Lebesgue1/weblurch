<html>
    <head>
        <link rel="stylesheet"
              href="../bootstrap/css/bootstrap.min.css"/>
        <link rel="stylesheet" href="./main.css"/>
        <link rel="stylesheet" href="./obsidian.css"/>
        <link rel="shortcut icon" href="favicon.png"/>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config( {
              tex2jax: { inlineMath: [ [ '$', '$' ], [ '\\(', '\\)' ] ] }
            } );
        </script>
        <script type="text/javascript"
                src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <title>webLurch docs: phantom-utils</title>
    </head>
    <body>
        <div id="left">
            <p align=center>Page contents</p>
<p><a href='#utilities-useful-to-the-testing-suite'>Utilities useful to the testing suite</a></p><p><a href='#the-main-api-code-phantomdescribe-code-'>The main API, <code>phantomDescribe</code></a></p><p><a href='#private-api'>Private API</a></p><p><a href='#public-api'>Public API</a></p><p><a href='#example'>Example</a></p><p><a href='#logging-unit-test-names-and-filenames'>Logging unit test names and filenames</a></p><p><a href='#running-test-app-histories'>Running test app histories</a></p><p><a href='#convenience-function-for-tests'>Convenience function for tests</a></p>
        </div>
        <div id="middle">
            <h1><a name='utilities-useful-to-the-testing-suite'></a>Utilities useful to the testing suite &nbsp;  <font size=-1><a href='#utilities-useful-to-the-testing-suite'><span class="glyphicon glyphicon-link"></span></a></font></h1><p>The compiled app runs in a web browser, so this module provides
utility functions for dealing with the headless browser
<a href="http://phantomjs.org/">PhantomJS</a> for use in automated testing.
This is done through a bridge from <a href="http://nodejs.org/">node.js</a>
to PhantomJS, called <a href="https://npmjs.org/package/node-phantom-simple">node-phantom-simple</a>.</p>
<p>We also include
<a href="https://www.npmjs.org/package/stack-trace">stack-trace</a> because
it is useful for knowing which files call <code>phantomDescribe</code>,
below, so that those files can be logged for use in documentation
generation later.</p>
<pre class="hljs"><code>nps = <span class="hljs-built_in">require</span> <span class="hljs-string">'node-phantom-simple'</span>
st = <span class="hljs-built_in">require</span> <span class="hljs-string">'stack-trace'</span>
</code></pre><h1><a name='the-main-api-code-phantomdescribe-code-'></a>The main API, <code>phantomDescribe</code> &nbsp;  <font size=-1><a href='#the-main-api-code-phantomdescribe-code-'><span class="glyphicon glyphicon-link"></span></a></font></h1><p>The <code>phantomDescribe</code> function makes it easy to set up a PhantomJS
instance and load into it a page from a given URL.  If any errors
take place during the loading process, they are thrown as
exceptions, or recorded as attributes of the page object.</p>
<ul>
<li><code>page.reserr</code> will be a resource error object, if there was a
resource error</li>
<li><code>page.err</code> will be a generic error object, if there was a
generic error</li>
</ul>
<p>This can easily be used within the asynchronous test framework in
<a href="http://jasmine.github.io/">Jasmine</a> by replacing a call to
Jasmine&#39;s <code>describe</code> function with a call to <code>phantomDescribe</code>.
An example appears <a href="#example">further below</a>.</p>
<h1><a name='private-api'></a>Private API &nbsp;  <font size=-1><a href='#private-api'><span class="glyphicon glyphicon-link"></span></a></font></h1><p>Here is a global variable in which I store the one PhantomJS
instance I create.  (Creating many PhantomJS instances
leads to errors about too many listeners for an <code>EventEmitter</code>, so
I use one global PhantomJS instance.)  It starts uninitialized,
and I prove a function for querying whether it has been
initialized since then.</p>
<pre class="hljs"><code>P = <span class="hljs-attribute">phantom</span>: <span class="hljs-literal">null</span>, <span class="hljs-attribute">page</span>: <span class="hljs-literal">null</span>
<span class="hljs-function"><span class="hljs-title">phantomInitialized</span> = -&gt;</span> P?.phantom <span class="hljs-keyword">and</span> P?.page
</code></pre><p>This function loads into that global instance any given URL.
It does not check <code>phantomInitialized</code> first; that is the business
of the next function, below.
Once the URL is loaded, this function calls the given callback.</p>
<p>It sets <code>P.page</code> to be false before the page opening is attempted,
and sets it to true if the opening complets without error.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-title">loadURLInPhantom</span> = <span class="hljs-params">( url, callback )</span> -&gt;</span>
    P.page.loaded = <span class="hljs-literal">no</span>
    P.page.open url, <span class="hljs-function"><span class="hljs-params">( err, status )</span> -&gt;</span>
        <span class="hljs-keyword">if</span> err <span class="hljs-keyword">then</span> <span class="hljs-built_in">console</span>.log err ; <span class="hljs-keyword">throw</span> err
        P.page.loaded = <span class="hljs-literal">yes</span>
        callback()
</code></pre><p>This function initializes the global variable <code>P</code>, loads the given
URL into the page stored in that global variable, and then calls a
callback function.  If <code>P</code> was already initialized, then this just
calls the callback.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-title">initializePhantom</span> = <span class="hljs-params">( url, callback )</span> -&gt;</span>
    <span class="hljs-keyword">if</span> phantomInitialized()
        loadURLInPhantom url, callback
    <span class="hljs-keyword">else</span>
        nps.create <span class="hljs-function"><span class="hljs-params">( err, ph )</span> -&gt;</span>
            <span class="hljs-keyword">if</span> err <span class="hljs-keyword">then</span> <span class="hljs-built_in">console</span>.log err ; <span class="hljs-keyword">throw</span> err
            P.phantom = ph
            P.phantom.createPage <span class="hljs-function"><span class="hljs-params">( err, pg )</span> -&gt;</span>
                <span class="hljs-keyword">if</span> err <span class="hljs-keyword">then</span> <span class="hljs-built_in">console</span>.log err ; <span class="hljs-keyword">throw</span> err
                P.page = pg
                P.page.<span class="hljs-function"><span class="hljs-title">onResourceError</span> = <span class="hljs-params">( err )</span> -&gt;</span>
                    <span class="hljs-built_in">console</span>.log <span class="hljs-string">'Page resource error:'</span>, err
                    P.page.reserr = err
                P.page.<span class="hljs-function"><span class="hljs-title">onError</span> = <span class="hljs-params">( err )</span> -&gt;</span>
                    <span class="hljs-built_in">console</span>.log <span class="hljs-string">'Page error:'</span>, err
                    P.page.err = err
                P.page.<span class="hljs-function"><span class="hljs-title">onConsoleMessage</span> = <span class="hljs-params">( message )</span> -&gt;</span>
                    <span class="hljs-built_in">console</span>.log message
                loadURLInPhantom url, callback
</code></pre><h1><a name='public-api'></a>Public API &nbsp;  <font size=-1><a href='#public-api'><span class="glyphicon glyphicon-link"></span></a></font></h1><p>And now we define the one function this module exports, which will
initialize the members of <code>P</code> if and when needed.</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">phantomDescribe</span> = <span class="hljs-params">( text, url, tests )</span> -&gt;</span>
</code></pre><p>First, we record which unit test called this function.  See the
documentation for <code>logUnitTestName</code> below for additional details.</p>
<pre class="hljs"><code>    logUnitTestName text
    describe text,<span class="hljs-function"> -&gt;</span>
</code></pre><p>Before each test, load the given page into the headless browser and
be sure it loaded successfully.</p>
<pre class="hljs"><code>        beforeEach <span class="hljs-function"><span class="hljs-params">( done )</span> -&gt;</span> initializePhantom url, done
</code></pre><p>Run the tests that the user passed in as a function.
Provide the user the <code>phantom</code> and <code>page</code> objects from earlier
as attributes of the <code>this</code> object when <code>tests</code> is run.
Thus they can access them as <code>@phantom</code> and <code>@page</code>.</p>
<pre class="hljs"><code>        tests.apply P
</code></pre><h1><a name='example'></a>Example &nbsp;  <font size=-1><a href='#example'><span class="glyphicon glyphicon-link"></span></a></font></h1><p>Example use (note the very important <code>=&gt;</code> for preserving <code>this</code>):</p>
<pre class="hljs"><code><span class="hljs-comment"># phantomDescribe 'My page', './index.html', -&gt;</span>
<span class="hljs-comment">#     it 'must load', ( done ) =&gt;</span>
<span class="hljs-comment">#         expect( @page.loaded ).toBeTruthy()</span>
<span class="hljs-comment">#         done()</span>
</code></pre><h1><a name='logging-unit-test-names-and-filenames'></a>Logging unit test names and filenames &nbsp;  <font size=-1><a href='#logging-unit-test-names-and-filenames'><span class="glyphicon glyphicon-link"></span></a></font></h1><p>We want to keep track of the mapping from unit test names to
filenames in which they were defined, so that documentation
generation can create links from test results to files that
define those tests.  This function uses the stack trace to find
which unit test file (of the form <code>\*-spec.litcoffee</code>) made a
call to <code>phantomDescribe</code>, and logs that data in a JSON file in
the test reports directory.</p>
<pre class="hljs"><code>savefile = <span class="hljs-string">'./reports/unit-test-names.json'</span>
<span class="hljs-function"><span class="hljs-title">logUnitTestName</span> = <span class="hljs-params">( name )</span> -&gt;</span>
    fs = <span class="hljs-built_in">require</span> <span class="hljs-string">'fs'</span>
    <span class="hljs-keyword">try</span>
        mapping = JSON.parse fs.readFileSync savefile
    <span class="hljs-keyword">catch</span> error
        mapping = { }
    <span class="hljs-keyword">for</span> frame <span class="hljs-keyword">in</span> st.get()
        fn = frame.getFileName()
        <span class="hljs-keyword">if</span> <span class="hljs-regexp">/-spec\.litcoffee/</span>.test fn
            mapping[name] = ( fn.split <span class="hljs-string">'/'</span> ).pop()
            fs.writeFileSync savefile,
                             JSON.stringify mapping, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>
            <span class="hljs-keyword">break</span>
</code></pre><h1><a name='running-test-app-histories'></a>Running test app histories &nbsp;  <font size=-1><a href='#running-test-app-histories'><span class="glyphicon glyphicon-link"></span></a></font></h1><p>Load <a href="../testapp/index.html">the testapp page</a> and execute in it
all the commands contained in the JSON data stored in the given
file.  After each command, if the recorded state of the editor is
marked as correct (or incorrect) in the JSON data, test to verify
that the result in the page equals (or does not equal) that
recorded state.</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">runTestHistory</span> = <span class="hljs-params">( filename )</span> -&gt;</span>
</code></pre><p>Start a test for the given filename, whether or not it even exists.</p>
<pre class="hljs"><code>    <span class="hljs-built_in">exports</span>.phantomDescribe <span class="hljs-string">"Test history in <span class="hljs-subst">#{filename}</span>"</span>, \
    <span class="hljs-string">'./testapp/index.html'</span>,<span class="hljs-function"> -&gt;</span>
</code></pre><p>The first test it must pass is that the file must exist and be
readable as the JSON data for an array.</p>
<pre class="hljs"><code>        fs = <span class="hljs-built_in">require</span> <span class="hljs-string">'fs'</span>
        canLoad = <span class="hljs-literal">yes</span>
        <span class="hljs-keyword">try</span>
            testHistory = JSON.parse fs.readFileSync filename
        <span class="hljs-keyword">catch</span> error
            canLoad = error
        it <span class="hljs-string">'exists on disk'</span>, <span class="hljs-function"><span class="hljs-params">( done )</span> =&gt;</span>
            expect( canLoad ).toEqual <span class="hljs-literal">yes</span>
            done()
        it <span class="hljs-string">'contains a JSON array'</span>, <span class="hljs-function"><span class="hljs-params">( done )</span> =&gt;</span>
            expect( testHistory <span class="hljs-keyword">instanceof</span> Array ).toBeTruthy()
            done()
</code></pre><p>Now we re-run, in the page, the entire test history.</p>
<pre class="hljs"><code>        it <span class="hljs-string">'was correctly replayed (in full)'</span>, <span class="hljs-function"><span class="hljs-params">( done )</span> =&gt;</span>
            <span class="hljs-property">@page</span>.evaluate <span class="hljs-function"><span class="hljs-params">( history )</span> -&gt;</span>
                result = []
                <span class="hljs-keyword">for</span> step, index <span class="hljs-keyword">in</span> history
</code></pre><p>For each step, if there is code to run (i.e., it&#39;s not the
initialization step) then run it and be sure there are no errors.
We include the index in the output so that if a test fails later,
it will be obvious which step of the test failed.</p>
<pre class="hljs"><code>                    <span class="hljs-keyword">if</span> step.code.length &gt; <span class="hljs-number">0</span>
                        <span class="hljs-keyword">try</span>
                            eval step.code
                            result.push \
                                <span class="hljs-string">"no error in command <span class="hljs-subst">#{index}</span>"</span>
                        <span class="hljs-keyword">catch</span> error
                            result.push error
                    <span class="hljs-keyword">else</span>
                        result.push \
                            <span class="hljs-string">"no error in command <span class="hljs-subst">#{index}</span>"</span>
</code></pre><p>Now in case there is any comparison to do with the main div&#39;s
state, we record that state here as a JSON string.</p>
<pre class="hljs"><code>                    result.push LE.getElement().toJSON()
                result
            , <span class="hljs-function"><span class="hljs-params">( err, result )</span> -&gt;</span>
</code></pre><p>Now we repeat the same loop through the test history after we&#39;ve
obtained the page results, and verify that they&#39;re what they
should be.  The first two lines pick out the two relelvant elements
from the results array, one the result of running any code at that
step and the other the DOM state achieved by that code.</p>
<pre class="hljs"><code>                <span class="hljs-keyword">for</span> step, index <span class="hljs-keyword">in</span> testHistory
                    codeResult = result[index*<span class="hljs-number">2</span>]
                    state = result[index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]
</code></pre><p>Verify that no errors occurred when the code ran.</p>
<pre class="hljs"><code>                    expect( codeResult ).toEqual \
                        <span class="hljs-string">"no error in command <span class="hljs-subst">#{index}</span>"</span>
</code></pre><p>Now, in case one of the tests below fails, we&#39;ll want its index in
the output, so we place that index in the objects here, just as a
convenience to the reader.</p>
<pre class="hljs"><code>                    state.index = step.state.index = index
</code></pre><p>Verify that the states match or do not match, whichever the test
data requires.</p>
<pre class="hljs"><code>                    <span class="hljs-keyword">if</span> step.correct <span class="hljs-keyword">is</span> <span class="hljs-literal">yes</span>
                        expect( state ).toEqual step.state
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> step.correct <span class="hljs-keyword">is</span> <span class="hljs-literal">no</span>
                        expect( state ).<span class="hljs-keyword">not</span>.toEqual step.state
                done()
</code></pre><p>This is the additional (optional) parameter passed to the function
that <code>@page.evaluate</code> will run, the test history as a big, JSONable
object.</p>
<pre class="hljs"><code>            , testHistory
</code></pre><h1><a name='convenience-function-for-tests'></a>Convenience function for tests &nbsp;  <font size=-1><a href='#convenience-function-for-tests'><span class="glyphicon glyphicon-link"></span></a></font></h1><p>In order to make writing tests shorter, we provide the following
convenience function.  Consider the following idiom.</p>
<pre class="hljs"><code><span class="hljs-comment"># it 'name of test here', ( done ) =&gt;</span>
<span class="hljs-comment">#     @page.evaluate =&gt;</span>
<span class="hljs-comment">#         result = []</span>
<span class="hljs-comment">#         result.push( statement1 we want to test )</span>
<span class="hljs-comment">#         result.push( statement2 we want to test )</span>
<span class="hljs-comment">#         result.push( statement3 we want to test )</span>
<span class="hljs-comment">#         result</span>
<span class="hljs-comment">#     , ( err, result ) -&gt;</span>
<span class="hljs-comment">#         expect( err ).toBeNull()</span>
<span class="hljs-comment">#         expect( result[0] ).toBeSuchAndSuch()</span>
<span class="hljs-comment">#         expect( result[1] ).toBeSuchAndSuch()</span>
<span class="hljs-comment">#         expect( result[2] ).toEqual soAndSo</span>
<span class="hljs-comment">#         done()</span>
</code></pre><p>This pattern would appear throughout our testing suite, and thus
can be made shorter by defining the following functions.  This one
can be used as in the example below to store the <code>done</code> function
in the global object <code>P</code> for later use.</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">inPage</span> = <span class="hljs-params">( func )</span> -&gt;</span>
    <span class="hljs-function"><span class="hljs-params">( done )</span> -&gt;</span>
        P.done = done
        func()
</code></pre><p>This one can be used in place of <code>expect</code> to provide the extra
checks we desire, and cause <code>done</code> to be called for us.</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">pageExpects</span> = <span class="hljs-params">( func, check, args... )</span> -&gt;</span>
    P.page.evaluate <span class="hljs-function"><span class="hljs-params">( evaluateThis )</span> -&gt;</span>
        result = <span class="hljs-keyword">try</span> eval evaluateThis <span class="hljs-keyword">catch</span> e <span class="hljs-keyword">then</span> e
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> result <span class="hljs-keyword">is</span> <span class="hljs-string">'undefined'</span>
            result = [ <span class="hljs-string">'undefined'</span> ]
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>
            result = [ <span class="hljs-string">'null'</span> ]
        <span class="hljs-keyword">else</span>
            result = [ <span class="hljs-string">'value'</span>, result ]
        result
    , <span class="hljs-function"><span class="hljs-params">( err, result )</span> -&gt;</span>
        expect( err ).toBeNull()
        <span class="hljs-keyword">if</span> result?[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-string">'null'</span>
            result = <span class="hljs-literal">null</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> result?[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-string">'value'</span>
            result = result[<span class="hljs-number">1</span>]
        <span class="hljs-keyword">else</span>
            result = <span class="hljs-literal">undefined</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span> result <span class="hljs-keyword">isnt</span> <span class="hljs-string">'undefined'</span>
            expect( result )[check](args...)
        <span class="hljs-keyword">else</span>
            expect( <span class="hljs-literal">undefined</span> )[check](args...)
        P.done()
    , <span class="hljs-string">"(<span class="hljs-subst">#{func.toString()}</span>)()"</span>
</code></pre><p>The new idiom that can replace the old is therefore the following.</p>
<pre class="hljs"><code><span class="hljs-comment"># it 'name of test here', inPage -&gt;</span>
<span class="hljs-comment">#     pageExpects ( -&gt; statement1 we want to test ),</span>
<span class="hljs-comment">#         'toBeSuchAndSuch'</span>
<span class="hljs-comment">#     pageExpects ( -&gt; statement2 we want to test ),</span>
<span class="hljs-comment">#         'toBeSuchAndSuch'</span>
<span class="hljs-comment">#     pageExpects ( -&gt; statement3 we want to test ),</span>
<span class="hljs-comment">#         'toEqual', soAndSo</span>
</code></pre><p>If you expect an error, you can do so with this routine.  The
<code>check</code> and <code>args</code> parameters are optional, and will be used on the
error object (if one exists) if and only if they&#39;re provided.</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">pageExpectsError</span> = <span class="hljs-params">( func, check, args... )</span> -&gt;</span>
    P.page.evaluate <span class="hljs-function"><span class="hljs-params">( evaluateThis )</span> -&gt;</span>
        <span class="hljs-keyword">try</span> eval evaluateThis ; <span class="hljs-literal">null</span> <span class="hljs-keyword">catch</span> e <span class="hljs-keyword">then</span> e
    , <span class="hljs-function"><span class="hljs-params">( err, result )</span> -&gt;</span>
        expect( err ).toBeNull()
        expect( result ).<span class="hljs-keyword">not</span>.toBeNull()
        <span class="hljs-keyword">if</span> check <span class="hljs-keyword">then</span> expect( result.message )[check](args...)
        P.done()
    , <span class="hljs-string">"(<span class="hljs-subst">#{func.toString()}</span>)()"</span>
</code></pre><p>Use it as per the following examples.</p>
<pre class="hljs"><code><span class="hljs-comment"># it 'name of test here', inPage -&gt;</span>
<span class="hljs-comment">#     pageExpectsError ( -&gt; undefinedVar )</span>
<span class="hljs-comment">#     pageExpectsError ( -&gt; foo('hello') ),</span>
<span class="hljs-comment">#         'toMatch', /parameter must be an integer/</span>
</code></pre><p>Furthermore, if some setup code needs to be run in the page, which
does not require any tests to be called on it, but still needs to
run without errors, then the following may be useful.</p>
<pre class="hljs"><code><span class="hljs-built_in">exports</span>.<span class="hljs-function"><span class="hljs-title">pageDo</span> = <span class="hljs-params">( func )</span> -&gt;</span>
    P.page.evaluate func, <span class="hljs-function"><span class="hljs-params">( err, result )</span> -&gt;</span>
        expect( err ).toBeNull()
        P.done()
</code></pre><p>One can then do the following.</p>
<pre class="hljs"><code><span class="hljs-comment"># it 'name of test here', inPage -&gt;</span>
<span class="hljs-comment">#     pageDo -&gt;</span>
<span class="hljs-comment">#         ...put a lot of code here, and if assigning to any</span>
<span class="hljs-comment">#         variables, be sure to use window.varName...</span>
<span class="hljs-comment">#     pageExpects ( -&gt; back to more tests here ),</span>
<span class="hljs-comment">#         'toBeTruthyOrWhatever'</span>
</code></pre>
        </div>
        <div id="right">
            <h3 align=center>Navigation</h3><br><h3><a href='index.md.html'>webLurch home</a></h3><p>.</p><ul><li><a href='buildutils.litcoffee.html'>buildutils.litcoffee</a></li><li><a href='cake.litcoffee.html'>cake.litcoffee</a></li></ul><p>./app</p><ul><li><a href='../app/index.html'>index.html</a></li></ul><p>./doc</p><ul><li><a href='plan.md.html'>plan.md</a></li><li><a href='progress.md.html'>progress.md</a></li><li><a href='test-results.md.html'>test-results.md</a></li></ul><p>./src</p><ul><li><a href='domeditaction.litcoffee.html'>domeditaction.litcoffee</a></li><li><a href='domedittracker.litcoffee.html'>domedittracker.litcoffee</a></li><li><a href='domutils.litcoffee.html'>domutils.litcoffee</a></li><li><a href='lurcheditor.litcoffee.html'>lurcheditor.litcoffee</a></li></ul><p>./test</p><ul><li><a href='all-histories-spec.litcoffee.html'>all-histories-spec.litcoffee</a></li><li><a href='basic-spec.litcoffee.html'>basic-spec.litcoffee</a></li><li><a href='domeditaction-spec.litcoffee.html'>domeditaction-spec.litcoffee</a></li><li><a href='domedittracker-spec.litcoffee.html'>domedittracker-spec.litcoffee</a></li><li><a href='domutils-spec.litcoffee.html'>domutils-spec.litcoffee</a></li><li><a href='lurcheditor-spec.litcoffee.html'>lurcheditor-spec.litcoffee</a></li><li><a href='phantom-utils.litcoffee.html'>phantom-utils.litcoffee</a></li><li><a href='undoredo-spec.litcoffee.html'>undoredo-spec.litcoffee</a></li></ul><p>./testapp</p><ul><li><a href='utils.litcoffee.html'>utils.litcoffee</a></li><li><a href='../testapp/index.html'>index.html</a></li></ul>
        </div>
    </body>
</html>
